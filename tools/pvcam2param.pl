#!/usr/bin/perl -w

use strict;

use IO::File;

# For each parameter P, this will create several methods:
#
#   getP - read CURRENT value
#   countP - read COUNT value
#   minP - read MIN value
#   maxP - read MAX value
#   defaultP - read DEFAULT value
#   stepP - read INCREMENT value
#   accessP - read ACCESS value
#   availP - read AVAIL value
#   setP - set CURRENT value
#
# Headers are written to several .h files, one per PVCAM CLASS. These headers
# should be included inside a class definition. The appropriate C++ class names
# are specified in the CLASSNAMES map below.
# Code is written to several .cpp files, one per PVCAM CLASS. These files may
# be compiled separately, or included in the .cpp file that defines the
# relevant C++ class.

my %CLASSNAMES = (
		  0 => "Camera",
		  2 => "Camera",
		  3 => "Camera"
		 );

my %TYPENAMES = (
		 "BOOLEAN" => "bool",
		 "INT8" => "signed char",
		 "UNS8" => "unsigned char",
		 "INT16" => "int16_t",
		 "UNS16" => "uint16_t",
		 "INT32" => "int32_t",
		 "UNS32" => "uint32_t",
		 "INT64" => "int64_t",
		 "UNS64" => "uint64_t",
		 "FLT32" => "double",
		 "FLT64" => "double",
		 "VOID_PTR" => "void *",
		 "VOID_PTR_PTR" => "void **",
                 "CHAR_PTR" => "QString",
		);

my %NAMELENGTHS = ("DD_INFO" => "getDdInfoLength()",
		   "CHIP_NAME" => "CCD_NAME_LEN",
		   "SYSTEM_NAME" => "MAX_SYSTEM_NAME_LEN",
		   "VENDOR_NAME" => "MAX_VENDOR_NAME_LEN",
		   "PRODUCT_NAME" => "MAX_PRODUCT_NAME_LEN",
		   "CAMERA_PART_NUMBER" => "MAX_CAM_PART_NUM_LEN",
		   "HEAD_SER_NUM_ALPHA" => "MAX_ALPHA_SER_NUM_LEN",
		   "GAIN_NAME" => "MAX_GAIN_NAME_LEN",
		   "PP_FEAT_NAME" => "MAX_PP_NAME_LEN",
		   "PP_PARAM_NAME" => "MAX_PP_NAME_LEN");

# Read input
open PVC, "<pvcam/pvcam.h" or die "Cannot read pvcam.h\n";
my @pvclines = <PVC>;
close PVC;

# Open outputs
my @fh;
my @fcpp;
for (keys %CLASSNAMES) {
  $fh[$_] = new IO::File;
  $fh[$_]->open(">src/pvp/pvp_Class$_.h") or die "Cannot write pvp_Class$_.h\n";
  $fh[$_]->print("// pvp_Class$_.h - generated by pvcam2param.pl. Do not Edit.\n\n");
  $fcpp[$_] = new IO::File;
  $fcpp[$_]->open(">src/pvp/pvp_Class$_.cpp") or die "Cannot write pvp_Class$_.cpp\n";
  $fcpp[$_]->print("// pvp_Class$_.cpp - generated by pvcam2param.pl. Do not Edit.\n\n");
  $fcpp[$_]->print("#include <pvp/pvp$CLASSNAMES{$_}.h>\n");
  $fcpp[$_]->print("#include <QTextStream>\n");
  $fcpp[$_]->print("#include <pvp/dwpvcam.h>\n\n");
}

# Scan for enums and enum values
my %enums;
my $primer="";
my $enum=0;
my %currentenum;
my $nextenumvalue=0;
my %enumvalues;

$enums{BINNING_SER} = binning_enum();
$enums{BINNING_PAR} = binning_enum();

for (@pvclines) {
  if (/#define\s+([A-Z_]+)\s+(\d+)/) {
    $enumvalues{$1} = $2;
  }
  $primer=$1 if /sed with.*PARAM_([A-Z_]+)/;
  if ($primer ne "") {
    $enum=1 if /enum/;
  }
  if ($enum==1) {
    $enum=2 if s/\{//;
  }
  if ($enum==3) {
    if (s/.*?\*\///) {
      $enum=2;
    }
  }
  if ($enum==2) {
    # Let's get stuff
    chomp;
    s/\/\/.*//;
    s/\/\*.*?\*\///g;
    if (s/\/\*.*//) {
      $enum=3;
    }
    s/\/\*.*\*\///g;
    s/\r/ /;
    s/\}.*// and $enum=0;
    s/^ +//;
    s/ +$//;
    my @words = split(/, */,$_);
    for (@words) {
      if (/([A-Za-z0-9_]+)\s*=\s*(.+)/) {
        $nextenumvalue = evaluateenum($2);
        $enumvalues{$1} = $nextenumvalue;
	$currentenum{$1} = $nextenumvalue++;
      } elsif (/[A-Za-z0-9_]/) {
        $enumvalues{$_} = $nextenumvalue;
	$currentenum{$_} = $nextenumvalue++;
      }
    }
    if ($enum==0) {
      my %thisenum = %currentenum;
#      print "hello $primer: ", keys(%thisenum), "\n";
      $enums{$primer} = \%thisenum;
      %currentenum = ();
      $primer = "";
      $nextenumvalue = 0;
    }
  }
}

# Clean up enums
for my $k (sort keys %enums) {
  $enums{$k} = stripenum($k,$enums{$k});
  my $e = $enums{$k};
  #print "Got enum $k { ";
  #for (sort {$e->{$a} <=> $e->{$b}} keys %{$e}) {
  #  print "$_=$e->{$_}, ";
  #}
  #print "}\n";
}

my @paramlists;
for (keys %CLASSNAMES) {
  my @lst;
  $paramlists[$_] = \@lst;
}

# Several parameters have been deprecated in recent PVCam SDK:
my @deprecated = qw/SERIAL_NUM CCS_STATUS FW_FULL_VERSION EXP_MIN_TIME CURRENT_PVTIME/;

my %deprecated;
$deprecated{$_} = 1 for @deprecated;

# Scan for params
for (@pvclines) {
  chomp;
  /define PARAM/ or next;
  /PARAM_([A-Z_]+).*CLASS(\d+).*TYPE_([A-Z0-9_]+)/ or next;
  next if exists $deprecated{$1};
  my $pname = $1;
  my $pclass = $2;
  my $ptype = $3;
  my $nicename = join("",map(ucfirst(lc($_)),split(/_/,$pname)));
  handleparam($nicename, $pname, $pclass, $ptype);
  push @{$paramlists[$pclass]}, $nicename;
}

for my $c (keys %CLASSNAMES) {
  $fh[$c]->print("  void reportClass$c() /*throw(pvpException)*/;\n");
  close($fh[$c]);

  $fcpp[$c]->print("void pvp$CLASSNAMES{$c}::reportClass$c() /*throw(pvpException)*/ {\n");
  for (@{$paramlists[$c]}) {
    $fcpp[$c]->print("  report$_();\n");
  }
  $fcpp[$c]->print("}\n\n");
  close($fcpp[$c]);
}

exit 0;

######################################################################
sub stripenum {
  my ($ename, $enump) = @_;
  my @kk = keys(%{$enump});
  my $base = $kk[0];
  my @base = split(/_/,$base);
  pop @base;
  for my $k (keys(%{$enump})) {
    while (scalar(@base)) {
      $base = join("_",@base);
      last if $k =~ /^${base}_/;
      pop @base;
    }
  }
  my %newenum;
  $base = join("_",@base);
  for my $k (keys %{$enump}) {
    my $l = $k; $l =~ s/^${base}_//;
    $l = join("",map(ucfirst(lc($_)),split(/_/,$l)));
    $l = "X$l" if $l =~ /^\d/;
    $newenum{$l} = $enump->{$k};
  }
  print "enum '$ename'. base = '$base'\n";
  return \%newenum;
}

sub handleparam {
  my ($nicename, $pname, $pclass, $ptype) = @_;
  print "Working on '$nicename' ($pname) in class '$pclass' (type '$ptype')\n";
  if ($ptype eq "ENUM") {
    outputenum($pname, $pclass);
  }
  my $nicetype;
  if ($ptype eq "ENUM") {
    $nicetype = "pvp$CLASSNAMES{$pclass}::$nicename";
  } else {
    $nicetype = $TYPENAMES{$ptype};
  }
  die "No mapping for $ptype\n" unless defined $nicetype;

  $fh[$pclass]->print(<<"EOF");
  bool avail$nicename() /*throw(pvpException)*/;
  pvpAccess access$nicename() /*throw(pvpException)*/;
  $nicetype get$nicename() /*throw(pvpException)*/;
  $nicetype min$nicename() /*throw(pvpException)*/;
  $nicetype max$nicename() /*throw(pvpException)*/;
  $nicetype default$nicename() /*throw(pvpException)*/;
  $nicetype step$nicename() /*throw(pvpException)*/;
  int count$nicename() /*throw(pvpException)*/;
  void set$nicename($nicetype) /*throw(pvpException)*/;
  void report$nicename() /*throw(pvpException)*/;

EOF

  $fcpp[$pclass]->print(<<"EOF");
bool pvp$CLASSNAMES{$pclass}::avail$nicename() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_$pname,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get $pname availability");
  return avail;
}

pvpAccess pvp$CLASSNAMES{$pclass}::access$nicename() /*throw(pvpException)*/ {
  uns16 access;
  if (!avail$nicename())
    throw pvpException("$pname not available");
  if (!pl_get_param(camh,PARAM_$pname,ATTR_ACCESS,&access))
    throw pvpException("Cannot get $pname accessibility");
  return pvpAccess(access);
}

int pvp$CLASSNAMES{$pclass}::count$nicename() /*throw(pvpException)*/ {
  uns32 count;
  if (!avail$nicename())
    throw pvpException("$pname not available");
  if (!pl_get_param(camh,PARAM_$pname,ATTR_COUNT,&count))
    throw pvpException("Cannot get $pname count");
  return count;
}

$nicetype pvp$CLASSNAMES{$pclass}::get$nicename() /*throw(pvpException)*/ {
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
EOF

  my $ref = "&x";
  my $lcptype = ($ptype eq "ENUM") ? "uns32"
    : ($ptype eq "CHAR_PTR") ? "char *"
    : ($ptype eq "BOOLEAN") ? "rs_bool"
    : $TYPENAMES{$ptype};# was: lc($ptype);
  die "Unknown type $ptype" unless defined $lcptype;
  if ($ptype eq "CHAR_PTR") {
    my $lentxt = $NAMELENGTHS{$pname};
    unless (defined $lentxt) {
      die "Do not know how much space to allocate for $pname in get\n";
    }
    $fcpp[$pclass]->print("    QByteArray ar($lentxt, 0);\n");
    $ref = "ar.data()";
  } else {
    $fcpp[$pclass]->print("    $lcptype x;\n");
  }
  $fcpp[$pclass]->print(<<"EOF");
    if (!pl_get_param(camh,PARAM_$pname,ATTR_CURRENT,$ref))
      throw pvpException("Cannot read $pname");
EOF
  if ($ptype eq "CHAR_PTR") {
  $fcpp[$pclass]->print(<<"EOF");
    QString y = $ref;
    return y;
EOF
  } else {
  $fcpp[$pclass]->print(<<"EOF");
    return x;
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
  } else {
    throw pvpException("$pname not accessible for reading");
  }
}

$nicetype pvp$CLASSNAMES{$pclass}::default$nicename() /*throw(pvpException)*/ {
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
EOF
  $ref = "&x";
  if ($ptype eq "CHAR_PTR") {
    my $lentxt = $NAMELENGTHS{$pname};
    unless (defined $lentxt) {
      die "Do not know how much space to allocate for $pname in default\n";
    }
    $fcpp[$pclass]->print("    QByteArray ar($lentxt, 0);\n");
    $ref = "ar.data()";
  } else {
    $fcpp[$pclass]->print("    $lcptype x;\n");
  }
  $fcpp[$pclass]->print(<<"EOF");
    if (!pl_get_param(camh,PARAM_$pname,ATTR_DEFAULT,$ref))
      throw pvpException("Cannot read default of $pname");
EOF
  if ($ptype eq "CHAR_PTR") {
  $fcpp[$pclass]->print(<<"EOF");
    QString y = $ref;
    return y;
EOF
  } else {
  $fcpp[$pclass]->print(<<"EOF");
    return x;
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
  } else {
    throw pvpException("$pname not accessible for reading");
  }
}

$nicetype pvp$CLASSNAMES{$pclass}::min$nicename() /*throw(pvpException)*/ {
EOF
  if ($ptype eq "CHAR_PTR") {
    $fcpp[$pclass]->print("    return \"\";\n"); #throw pvpException(\"min not defined for string-typed $pname\");\n");
  } else {
    $fcpp[$pclass]->print(<<"EOF");
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    $lcptype x;
    if (!pl_get_param(camh,PARAM_$pname,ATTR_MIN,\&x))
      throw pvpException("Cannot read min of $pname");
    return x;
  } else {
    throw pvpException("$pname not accessible for reading");
  }
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
}

$nicetype pvp$CLASSNAMES{$pclass}::max$nicename() /*throw(pvpException)*/ {
EOF
  if ($ptype eq "CHAR_PTR") {
    $fcpp[$pclass]->print("    return \"\";\n"); # throw pvpException(\"max not defined for string-typed $pname\");\n");
  } else {
    $fcpp[$pclass]->print(<<"EOF");
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    $lcptype x;
    if (!pl_get_param(camh,PARAM_$pname,ATTR_MAX,\&x))
      throw pvpException("Cannot read max of $pname");
    return x;
  } else {
    throw pvpException("$pname not accessible for reading");
  }
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
}

void pvp$CLASSNAMES{$pclass}::set$nicename($nicetype x) /*throw(pvpException)*/ {
  pvpAccess a = access$nicename();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
EOF
  if ($ptype eq "CHAR_PTR") {
    $ref = "x.toUtf8().data()";
  } else {
    $ref = "&y";
    if ($ptype eq "ENUM") {
      $fcpp[$pclass]->print("    uns32 y = x;\n");
    } else {
      $fcpp[$pclass]->print("    $lcptype y = x;\n");
    }
  }
  $fcpp[$pclass]->print(<<"EOF");
    if (!pl_set_param(camh,PARAM_$pname,(void*)($ref)))
      throw pvpException("Cannot set $pname");
  }
}

EOF
  if ($ptype eq "ENUM") {
    $ref = ".decode()"; 
  } else {
    $ref ="";
  }
  $fcpp[$pclass]->print(<<"EOF");
void pvp$CLASSNAMES{$pclass}::report$nicename() /*throw(pvpException)*/ {
  if (avail$nicename()) {
    pvpAccess a = access$nicename();
    printf("$nicename: \%s\\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << get$nicename()$ref <<"\\n";
        ss << "  min value: " << min$nicename()$ref <<"\\n";
        ss << "  max value: " << max$nicename()$ref <<"\\n";
        ss << "  default value: " << default$nicename()$ref <<"\\n";
      }
      printf("\%s",s.toUtf8().data());
    }
    printf("  count: %i\\n",count$nicename());
  } else {
    printf("$nicename is not available.\\n");
  }
}

EOF
}

sub outputenum {
  my ($ename, $eclass) = @_;
  my $enum = $enums{$ename};
  die "Unknown enum $ename\n" unless defined $enum;

  my $nicename = join("",map(ucfirst(lc($_)),split(/_/,$ename)));

  $fh[$eclass]->print(<<"EOF");
  class $nicename {
  public:
    enum V {
EOF
  my $nextval=0;
  for my $k (sort { $enum->{$a} <=> $enum->{$b} } keys %{$enum}) {
    my $v=$enum->{$k};
    if ($v eq $nextval) {
      $fh[$eclass]->print("      $k,\n");
    } else {
      $fh[$eclass]->print("      $k = $v,\n");
    }
    $nextval=$v+1;
  }
  $fh[$eclass]->print(<<"EOF");
    };
    $nicename(${nicename}::V x): x(x) {}
    $nicename(int x0=0) { x=(V)(x0); }
    operator pvpEnumInt() const { return x; }
    char const *decode() const;
  private:
    V x;
  };

EOF

  $fcpp[$eclass]->print(<<"EOF");
char const *pvp$CLASSNAMES{$eclass}::${nicename}::decode() const {
  switch (x) {
EOF
  my %done;
  for my $k (sort { $enum->{$a} <=> $enum->{$b} } keys %{$enum}) {
    $fcpp[$eclass]->print("    case $k: return \"$k\";\n") unless exists $done{$enum->{$k}};
    $done{$enum->{$k}} = 1;
  }
  $fcpp[$eclass]->print(<<"EOF");
    default: return "UNKNOWN";
  }
}

EOF
}

sub evaluateenum {
  my $str = shift;
  # Evalue STR as C code that may contain enum values
  my $cp = $str;
  while ($cp =~ s/([A-Z_]+)//) {
    unless (exists $enumvalues{$1}) {
      print join(":", keys %enumvalues), "\n";
      die "Unknown enum value $1\n";
    }
  }
  $cp = $str;
  $str =~ s/([A-Z_]+)/$enumvalues{$1}/g;
  print "evaluating $cp: $str\n";
  return eval($str);
}

sub binning_enum {
  my %en;
  $en{ONE} = 1;
  $en{TWO} = 2;
  $en{THREE} = 3;
  $en{FOUR} = 4;
  return \%en;
}

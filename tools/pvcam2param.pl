#!/usr/bin/perl -w

use strict;

use IO::File;

# For each parameter P, this will create several methods:
#
#   getP - read CURRENT value
#   countP - read COUNT value
#   minP - read MIN value
#   maxP - read MAX value
#   defaultP - read DEFAULT value
#   stepP - read INCREMENT value
#   accessP - read ACCESS value
#   availP - read AVAIL value
#   setP - set CURRENT value
#
# Headers are written to several .h files, one per PVCAM CLASS. These headers
# should be included inside a class definition. The appropriate C++ class names
# are specified in the CLASSNAMES map below.
# Code is written to several .cpp files, one per PVCAM CLASS. These files may
# be compiled separately, or included in the .cpp file that defines the
# relevant C++ class.

my %CLASSNAMES = (
		  0 => "Camera",
		  2 => "Camera",
		  3 => "Camera"
		 );

my %TYPENAMES = (
		 "CHAR" => "QString",
		 "BOOLEAN" => "bool",
		 "INT8" => "signed char",
		 "UNS8" => "unsigned char",
		 "INT16" => "short",
		 "UNS16" => "unsigned short",
		 "INT32" => "long",
		 "UNS32" => "unsigned long",
		 "FLT64" => "float",
		 "VOID_PTR" => "void *",
		 "VOID_PTR_PTR" => "void **",
		);

# Read input
open PVC, "<linuxpvcam.h" or die "Cannot read pvcam.h\n";
my @pvclines = <PVC>;
close PVC;

# Open outputs
my @fh;
my @fcpp;
for (keys %CLASSNAMES) {
  $fh[$_] = new IO::File;
  $fh[$_]->open(">pvp_Class$_.h") or die "Cannot write pvp_Class$_.h\n";
  $fh[$_]->print("// pvp_Class$_.h - generated by pvcam2param.pl. Do not Edit.\n\n");
  $fcpp[$_] = new IO::File;
  $fcpp[$_]->open(">pvp_Class$_.cpp") or die "Cannot write pvp_Class$_.cpp\n";
  $fcpp[$_]->print("// pvp_Class$_.cpp - generated by pvcam2param.pl. Do not Edit.\n\n");
  $fcpp[$_]->print("#include <pvp/pvp$CLASSNAMES{$_}.h>\n");
  $fcpp[$_]->print("#include <QTextStream>\n");
  $fcpp[$_]->print("#include <pvp/dwpvcam.h>\n\n");
}

# Scan for enums
my %enums;
my $primer="";
my $enum=0;
my %currentenum;
my $nextenumvalue=0;
for (@pvclines) {
  $primer=$1 if /used with.*PARAM_([A-Z_]+)/;
  if ($primer ne "") {
    $enum=1 if /enum/;
  }
  if ($enum==1) {
    $enum=2 if s/\{//;
  }
  if ($enum==2) {
    # Let's get stuff
    chomp;
    s/\/\*.*\*\///g;
    s/\r/ /;
    s/\}.*// and $enum=0;
    s/^ +//;
    s/ +$//;
    my @words = split(/, */,$_);
    for (@words) {
      if (/([A-Za-z0-9_]+)\s*=\s*([A-Z0-9a-z_]+)/) {
	$currentenum{$1} = $2;
	$nextenumvalue = $2 + 1;
      } elsif (/[A-Za-z0-9_]/) {
	$currentenum{$_} = $nextenumvalue++;
      }
    }
    if ($enum==0) {
      my %thisenum = %currentenum;
#      print "hello $primer: ", keys(%thisenum), "\n";
      $enums{$primer} = \%thisenum;
      %currentenum = ();
      $primer = "";
      $nextenumvalue = 0;
    }
  }
}

for my $k (sort keys %enums) {
  $enums{$k} = stripenum($k,$enums{$k});
  my $e = $enums{$k};
  #print "Got enum $k { ";
  #for (sort {$e->{$a} <=> $e->{$b}} keys %{$e}) {
  #  print "$_=$e->{$_}, ";
  #}
  #print "}\n";
}

my @paramlists;
for (keys %CLASSNAMES) {
  my @lst;
  $paramlists[$_] = \@lst;
}

# Scan for params
for (@pvclines) {
  chomp;
  /define PARAM/ or next;
  /PARAM_([A-Z_]+).*CLASS(\d+).*TYPE_([A-Z0-9]+)/ or next;
  my $pname = $1;
  my $pclass = $2;
  my $ptype = $3;
  my $nicename = join("",map(ucfirst(lc($_)),split(/_/,$pname)));
  handleparam($nicename, $pname, $pclass, $ptype);
  push @{$paramlists[$pclass]}, $nicename;
}

for my $c (keys %CLASSNAMES) {
  $fh[$c]->print("  void reportClass$c() throw(pvpException);\n");
  close($fh[$c]);

  $fcpp[$c]->print("void pvp$CLASSNAMES{$c}::reportClass$c() throw(pvpException) {\n");
  for (@{$paramlists[$c]}) {
    $fcpp[$c]->print("  report$_();\n");
  }
  $fcpp[$c]->print("}\n\n");
  close($fcpp[$c]);
}

exit 0;

######################################################################
sub stripenum {
  my ($ename, $enump) = @_;
  my @kk = keys(%{$enump});
  my $base = $kk[0];
  my @base = split(/_/,$base);
  pop @base;
  for my $k (keys(%{$enump})) {
    while (scalar(@base)) {
      $base = join("_",@base);
      last if $k =~ /^${base}_/;
      pop @base;
    }
  }
  my %newenum;
  $base = join("_",@base);
  for my $k (keys %{$enump}) {
    my $l = $k; $l =~ s/^${base}_//;
    $l = join("",map(ucfirst(lc($_)),split(/_/,$l)));
    $newenum{$l} = $enump->{$k};
  }
#print "enum '$ename'. base = '$base'\n";
  return \%newenum;
}

sub handleparam {
  my ($nicename, $pname, $pclass, $ptype) = @_;
  #print "Working on '$nicename' ($pname) in class '$pclass' (type '$ptype')\n";
  if ($ptype eq "ENUM") {
    outputenum($pname, $pclass);
  }
  my $nicetype;
  if ($ptype eq "ENUM") {
    $nicetype = "pvp$CLASSNAMES{$pclass}::$nicename";
  } else {
    $nicetype = $TYPENAMES{$ptype};
  }
  die "No mapping for $ptype\n" unless defined $nicetype;

  $fh[$pclass]->print(<<"EOF");
  bool avail$nicename() throw(pvpException);
  pvpAccess access$nicename() throw(pvpException);
  $nicetype get$nicename() throw(pvpException);
  $nicetype min$nicename() throw(pvpException);
  $nicetype max$nicename() throw(pvpException);
  $nicetype default$nicename() throw(pvpException);
  $nicetype step$nicename() throw(pvpException);
  int count$nicename() throw(pvpException);
  void set$nicename($nicetype) throw(pvpException);
  void report$nicename() throw(pvpException);

EOF

  $fcpp[$pclass]->print(<<"EOF");
bool pvp$CLASSNAMES{$pclass}::avail$nicename() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_$pname,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get $pname availability");
  return avail;
}

pvpAccess pvp$CLASSNAMES{$pclass}::access$nicename() throw(pvpException) {
  uns16 access;
  if (!avail$nicename())
    throw pvpException("$pname not available");
  if (!pl_get_param(camh,PARAM_$pname,ATTR_ACCESS,&access))
    throw pvpException("Cannot get $pname accessibility");
  return pvpAccess(access);
}

int pvp$CLASSNAMES{$pclass}::count$nicename() throw(pvpException) {
  uns32 count;
  if (!avail$nicename())
    throw pvpException("$pname not available");
  if (!pl_get_param(camh,PARAM_$pname,ATTR_COUNT,&count))
    throw pvpException("Cannot get $pname count");
  return count;
}

$nicetype pvp$CLASSNAMES{$pclass}::get$nicename() throw(pvpException) {
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
EOF
  my $ref = "&x";
  my $lcptype = ($ptype eq "ENUM") ? "uns32" : lc($ptype);
  if ($ptype eq "CHAR") {
    if ($pname eq "DD_INFO") {
      $fcpp[$pclass]->print("    QByteArray ar(getDdInfoLength(), 0);\n");
    } else {
      $fcpp[$pclass]->print("    QByteArray ar(count$nicename(), 0);\n");
    }
    $ref = "ar.data()";
  } else {
    $fcpp[$pclass]->print("    $lcptype x;\n");
  }
  $fcpp[$pclass]->print(<<"EOF");
    if (!pl_get_param(camh,PARAM_$pname,ATTR_CURRENT,$ref))
      throw pvpException("Cannot read $pname");
EOF
  if ($ptype eq "CHAR") {
  $fcpp[$pclass]->print(<<"EOF");
    QString y = $ref;
    return y;
EOF
  } else {
  $fcpp[$pclass]->print(<<"EOF");
    return x;
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
  } else {
    throw pvpException("$pname not accessible for reading");
  }
}

$nicetype pvp$CLASSNAMES{$pclass}::default$nicename() throw(pvpException) {
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
EOF
  $ref = "&x";
  if ($ptype eq "CHAR") {
    if ($pname eq "DD_INFO") {
      $fcpp[$pclass]->print("    char x[getDdInfoLength()];\n");
    } else {
      $fcpp[$pclass]->print("    char x[count$nicename()];\n");
    }
    $ref = "x";
  } else {
    $fcpp[$pclass]->print("    $lcptype x;\n");
  }
  $fcpp[$pclass]->print(<<"EOF");
    if (!pl_get_param(camh,PARAM_$pname,ATTR_DEFAULT,$ref))
      throw pvpException("Cannot read default of $pname");
    return x;
  } else {
    throw pvpException("$pname not accessible for reading");
  }
}

$nicetype pvp$CLASSNAMES{$pclass}::min$nicename() throw(pvpException) {
EOF
  if ($ptype eq "CHAR") {
    $fcpp[$pclass]->print("    return \"\";\n"); #throw pvpException(\"min not defined for string-typed $pname\");\n");
  } else {
    $fcpp[$pclass]->print(<<"EOF");
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    $lcptype x;
    if (!pl_get_param(camh,PARAM_$pname,ATTR_MIN,\&x))
      throw pvpException("Cannot read min of $pname");
    return x;
  } else {
    throw pvpException("$pname not accessible for reading");
  }
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
}

$nicetype pvp$CLASSNAMES{$pclass}::max$nicename() throw(pvpException) {
EOF
  if ($ptype eq "CHAR") {
    $fcpp[$pclass]->print("    return \"\";\n"); # throw pvpException(\"max not defined for string-typed $pname\");\n");
  } else {
    $fcpp[$pclass]->print(<<"EOF");
  pvpAccess a = access$nicename();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    $lcptype x;
    if (!pl_get_param(camh,PARAM_$pname,ATTR_MAX,\&x))
      throw pvpException("Cannot read max of $pname");
    return x;
  } else {
    throw pvpException("$pname not accessible for reading");
  }
EOF
  }
  $fcpp[$pclass]->print(<<"EOF");
}

void pvp$CLASSNAMES{$pclass}::set$nicename($nicetype x) throw(pvpException) {
  pvpAccess a = access$nicename();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
EOF
  if ($ptype eq "CHAR") {
    $ref = "x.unicode().data()";
  } else {
    $ref = "&y";
    if ($ptype eq "ENUM") {
      $fcpp[$pclass]->print("    uns32 y = x;\n");
    } else {
      $fcpp[$pclass]->print("    $lcptype y = x;\n");
    }
  }
  $fcpp[$pclass]->print(<<"EOF");
    if (!pl_set_param(camh,PARAM_$pname,(void*)($ref)))
      throw pvpException("Cannot set $pname");
  }
}

EOF
  if ($ptype eq "ENUM") {
    $ref = ".decode()"; 
  } else {
    $ref ="";
  }
  $fcpp[$pclass]->print(<<"EOF");
void pvp$CLASSNAMES{$pclass}::report$nicename() throw(pvpException) {
  if (avail$nicename()) {
    pvpAccess a = access$nicename();
    printf("$nicename: \%s\\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << get$nicename()$ref <<"\\n";
        ss << "  min value: " << min$nicename()$ref <<"\\n";
        ss << "  max value: " << max$nicename()$ref <<"\\n";
        ss << "  default value: " << default$nicename()$ref <<"\\n";
      }
      printf("\%s",s.toUtf8().data());
    }
    printf("  count: %i\\n",count$nicename());
  } else {
    printf("$nicename is not available.\\n");
  }
}

EOF
}

sub outputenum {
  my ($ename, $eclass) = @_;
  my $enum = $enums{$ename};
  die "Unknown enum $ename\n" unless defined $enum;

  my $nicename = join("",map(ucfirst(lc($_)),split(/_/,$ename)));

  $fh[$eclass]->print(<<"EOF");
  class $nicename {
  public:
    enum V {
EOF
  my $nextval=0;
  for my $k (sort { $enum->{$a} <=> $enum->{$b} } keys %{$enum}) {
    my $v=$enum->{$k};
    if ($v eq $nextval) {
      $fh[$eclass]->print("      $k,\n");
    } else {
      $fh[$eclass]->print("      $k = $v,\n");
    }
    $nextval=$v+1;
  }
  $fh[$eclass]->print(<<"EOF");
    };
    $nicename(${nicename}::V x): x(x) {}
    $nicename(int x0=0) { x=(V)(x0); }
    operator pvpEnumInt() const { return x; }
    char const *decode() const;
  private:
    V x;
  };

EOF

  $fcpp[$eclass]->print(<<"EOF");
char const *pvp$CLASSNAMES{$eclass}::${nicename}::decode() const {
  switch (x) {
EOF
  my %done;
  for my $k (sort { $enum->{$a} <=> $enum->{$b} } keys %{$enum}) {
    $fcpp[$eclass]->print("    case $k: return \"$k\";\n") unless exists $done{$enum->{$k}};
    $done{$enum->{$k}} = 1;
  }
  $fcpp[$eclass]->print(<<"EOF");
    default: return "UNKNOWN";
  }
}

EOF
}


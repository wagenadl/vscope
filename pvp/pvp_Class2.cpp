// pvp_Class2.cpp - generated by pvcam2param.pl. Do not Edit.

#include <pvp/pvpCamera.h>
#include <QTextStream>
#include <pvp/dwpvcam.h>

#include <base/memalloc.h>

bool pvpCamera::availMinBlock() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get MIN_BLOCK availability");
  return avail;
}

pvpAccess pvpCamera::accessMinBlock() throw(pvpException) {
  uns16 access;
  if (!availMinBlock())
    throw pvpException("MIN_BLOCK not available");
  if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get MIN_BLOCK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countMinBlock() throw(pvpException) {
  uns32 count;
  if (!availMinBlock())
    throw pvpException("MIN_BLOCK not available");
  if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_COUNT,&count))
    throw pvpException("Cannot get MIN_BLOCK count");
  return count;
}

short pvpCamera::getMinBlock() throw(pvpException) {
  pvpAccess a = accessMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read MIN_BLOCK");
    return x;
  } else {
    throw pvpException("MIN_BLOCK not accessible for reading");
  }
}

short pvpCamera::defaultMinBlock() throw(pvpException) {
  pvpAccess a = accessMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of MIN_BLOCK");
    return x;
  } else {
    throw pvpException("MIN_BLOCK not accessible for reading");
  }
}

short pvpCamera::minMinBlock() throw(pvpException) {
  pvpAccess a = accessMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of MIN_BLOCK");
    return x;
  } else {
    throw pvpException("MIN_BLOCK not accessible for reading");
  }
}

short pvpCamera::maxMinBlock() throw(pvpException) {
  pvpAccess a = accessMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_MIN_BLOCK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of MIN_BLOCK");
    return x;
  } else {
    throw pvpException("MIN_BLOCK not accessible for reading");
  }
}

void pvpCamera::setMinBlock(short x) throw(pvpException) {
  pvpAccess a = accessMinBlock();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_MIN_BLOCK,(void*)(&y)))
      throw pvpException("Cannot set MIN_BLOCK");
  }
}

void pvpCamera::reportMinBlock() throw(pvpException) {
  if (availMinBlock()) {
    pvpAccess a = accessMinBlock();
    printf("MinBlock: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getMinBlock() <<"\n";
        ss << "  min value: " << minMinBlock() <<"\n";
        ss << "  max value: " << maxMinBlock() <<"\n";
        ss << "  default value: " << defaultMinBlock() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countMinBlock());
  } else {
    printf("MinBlock is not available.\n");
  }
}

bool pvpCamera::availNumMinBlock() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get NUM_MIN_BLOCK availability");
  return avail;
}

pvpAccess pvpCamera::accessNumMinBlock() throw(pvpException) {
  uns16 access;
  if (!availNumMinBlock())
    throw pvpException("NUM_MIN_BLOCK not available");
  if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get NUM_MIN_BLOCK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countNumMinBlock() throw(pvpException) {
  uns32 count;
  if (!availNumMinBlock())
    throw pvpException("NUM_MIN_BLOCK not available");
  if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_COUNT,&count))
    throw pvpException("Cannot get NUM_MIN_BLOCK count");
  return count;
}

short pvpCamera::getNumMinBlock() throw(pvpException) {
  pvpAccess a = accessNumMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read NUM_MIN_BLOCK");
    return x;
  } else {
    throw pvpException("NUM_MIN_BLOCK not accessible for reading");
  }
}

short pvpCamera::defaultNumMinBlock() throw(pvpException) {
  pvpAccess a = accessNumMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of NUM_MIN_BLOCK");
    return x;
  } else {
    throw pvpException("NUM_MIN_BLOCK not accessible for reading");
  }
}

short pvpCamera::minNumMinBlock() throw(pvpException) {
  pvpAccess a = accessNumMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of NUM_MIN_BLOCK");
    return x;
  } else {
    throw pvpException("NUM_MIN_BLOCK not accessible for reading");
  }
}

short pvpCamera::maxNumMinBlock() throw(pvpException) {
  pvpAccess a = accessNumMinBlock();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_MIN_BLOCK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of NUM_MIN_BLOCK");
    return x;
  } else {
    throw pvpException("NUM_MIN_BLOCK not accessible for reading");
  }
}

void pvpCamera::setNumMinBlock(short x) throw(pvpException) {
  pvpAccess a = accessNumMinBlock();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_NUM_MIN_BLOCK,(void*)(&y)))
      throw pvpException("Cannot set NUM_MIN_BLOCK");
  }
}

void pvpCamera::reportNumMinBlock() throw(pvpException) {
  if (availNumMinBlock()) {
    pvpAccess a = accessNumMinBlock();
    printf("NumMinBlock: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getNumMinBlock() <<"\n";
        ss << "  min value: " << minNumMinBlock() <<"\n";
        ss << "  max value: " << maxNumMinBlock() <<"\n";
        ss << "  default value: " << defaultNumMinBlock() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countNumMinBlock());
  } else {
    printf("NumMinBlock is not available.\n");
  }
}

bool pvpCamera::availSkipAtOnceBlk() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SKIP_AT_ONCE_BLK availability");
  return avail;
}

pvpAccess pvpCamera::accessSkipAtOnceBlk() throw(pvpException) {
  uns16 access;
  if (!availSkipAtOnceBlk())
    throw pvpException("SKIP_AT_ONCE_BLK not available");
  if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SKIP_AT_ONCE_BLK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSkipAtOnceBlk() throw(pvpException) {
  uns32 count;
  if (!availSkipAtOnceBlk())
    throw pvpException("SKIP_AT_ONCE_BLK not available");
  if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_COUNT,&count))
    throw pvpException("Cannot get SKIP_AT_ONCE_BLK count");
  return count;
}

long pvpCamera::getSkipAtOnceBlk() throw(pvpException) {
  pvpAccess a = accessSkipAtOnceBlk();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int32 x;
    if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SKIP_AT_ONCE_BLK");
    return x;
  } else {
    throw pvpException("SKIP_AT_ONCE_BLK not accessible for reading");
  }
}

long pvpCamera::defaultSkipAtOnceBlk() throw(pvpException) {
  pvpAccess a = accessSkipAtOnceBlk();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int32 x;
    if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SKIP_AT_ONCE_BLK");
    return x;
  } else {
    throw pvpException("SKIP_AT_ONCE_BLK not accessible for reading");
  }
}

long pvpCamera::minSkipAtOnceBlk() throw(pvpException) {
  pvpAccess a = accessSkipAtOnceBlk();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int32 x;
    if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SKIP_AT_ONCE_BLK");
    return x;
  } else {
    throw pvpException("SKIP_AT_ONCE_BLK not accessible for reading");
  }
}

long pvpCamera::maxSkipAtOnceBlk() throw(pvpException) {
  pvpAccess a = accessSkipAtOnceBlk();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int32 x;
    if (!pl_get_param(camh,PARAM_SKIP_AT_ONCE_BLK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SKIP_AT_ONCE_BLK");
    return x;
  } else {
    throw pvpException("SKIP_AT_ONCE_BLK not accessible for reading");
  }
}

void pvpCamera::setSkipAtOnceBlk(long x) throw(pvpException) {
  pvpAccess a = accessSkipAtOnceBlk();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int32 y = x;
    if (!pl_set_param(camh,PARAM_SKIP_AT_ONCE_BLK,(void*)(&y)))
      throw pvpException("Cannot set SKIP_AT_ONCE_BLK");
  }
}

void pvpCamera::reportSkipAtOnceBlk() throw(pvpException) {
  if (availSkipAtOnceBlk()) {
    pvpAccess a = accessSkipAtOnceBlk();
    printf("SkipAtOnceBlk: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSkipAtOnceBlk() <<"\n";
        ss << "  min value: " << minSkipAtOnceBlk() <<"\n";
        ss << "  max value: " << maxSkipAtOnceBlk() <<"\n";
        ss << "  default value: " << defaultSkipAtOnceBlk() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countSkipAtOnceBlk());
  } else {
    printf("SkipAtOnceBlk is not available.\n");
  }
}

bool pvpCamera::availNumOfStripsPerClr() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get NUM_OF_STRIPS_PER_CLR availability");
  return avail;
}

pvpAccess pvpCamera::accessNumOfStripsPerClr() throw(pvpException) {
  uns16 access;
  if (!availNumOfStripsPerClr())
    throw pvpException("NUM_OF_STRIPS_PER_CLR not available");
  if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get NUM_OF_STRIPS_PER_CLR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countNumOfStripsPerClr() throw(pvpException) {
  uns32 count;
  if (!availNumOfStripsPerClr())
    throw pvpException("NUM_OF_STRIPS_PER_CLR not available");
  if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_COUNT,&count))
    throw pvpException("Cannot get NUM_OF_STRIPS_PER_CLR count");
  return count;
}

short pvpCamera::getNumOfStripsPerClr() throw(pvpException) {
  pvpAccess a = accessNumOfStripsPerClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read NUM_OF_STRIPS_PER_CLR");
    return x;
  } else {
    throw pvpException("NUM_OF_STRIPS_PER_CLR not accessible for reading");
  }
}

short pvpCamera::defaultNumOfStripsPerClr() throw(pvpException) {
  pvpAccess a = accessNumOfStripsPerClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of NUM_OF_STRIPS_PER_CLR");
    return x;
  } else {
    throw pvpException("NUM_OF_STRIPS_PER_CLR not accessible for reading");
  }
}

short pvpCamera::minNumOfStripsPerClr() throw(pvpException) {
  pvpAccess a = accessNumOfStripsPerClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of NUM_OF_STRIPS_PER_CLR");
    return x;
  } else {
    throw pvpException("NUM_OF_STRIPS_PER_CLR not accessible for reading");
  }
}

short pvpCamera::maxNumOfStripsPerClr() throw(pvpException) {
  pvpAccess a = accessNumOfStripsPerClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of NUM_OF_STRIPS_PER_CLR");
    return x;
  } else {
    throw pvpException("NUM_OF_STRIPS_PER_CLR not accessible for reading");
  }
}

void pvpCamera::setNumOfStripsPerClr(short x) throw(pvpException) {
  pvpAccess a = accessNumOfStripsPerClr();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_NUM_OF_STRIPS_PER_CLR,(void*)(&y)))
      throw pvpException("Cannot set NUM_OF_STRIPS_PER_CLR");
  }
}

void pvpCamera::reportNumOfStripsPerClr() throw(pvpException) {
  if (availNumOfStripsPerClr()) {
    pvpAccess a = accessNumOfStripsPerClr();
    printf("NumOfStripsPerClr: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getNumOfStripsPerClr() <<"\n";
        ss << "  min value: " << minNumOfStripsPerClr() <<"\n";
        ss << "  max value: " << maxNumOfStripsPerClr() <<"\n";
        ss << "  default value: " << defaultNumOfStripsPerClr() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countNumOfStripsPerClr());
  } else {
    printf("NumOfStripsPerClr is not available.\n");
  }
}

bool pvpCamera::availContClears() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CONT_CLEARS availability");
  return avail;
}

pvpAccess pvpCamera::accessContClears() throw(pvpException) {
  uns16 access;
  if (!availContClears())
    throw pvpException("CONT_CLEARS not available");
  if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CONT_CLEARS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countContClears() throw(pvpException) {
  uns32 count;
  if (!availContClears())
    throw pvpException("CONT_CLEARS not available");
  if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_COUNT,&count))
    throw pvpException("Cannot get CONT_CLEARS count");
  return count;
}

bool pvpCamera::getContClears() throw(pvpException) {
  pvpAccess a = accessContClears();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CONT_CLEARS");
    return x;
  } else {
    throw pvpException("CONT_CLEARS not accessible for reading");
  }
}

bool pvpCamera::defaultContClears() throw(pvpException) {
  pvpAccess a = accessContClears();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CONT_CLEARS");
    return x;
  } else {
    throw pvpException("CONT_CLEARS not accessible for reading");
  }
}

bool pvpCamera::minContClears() throw(pvpException) {
  pvpAccess a = accessContClears();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CONT_CLEARS");
    return x;
  } else {
    throw pvpException("CONT_CLEARS not accessible for reading");
  }
}

bool pvpCamera::maxContClears() throw(pvpException) {
  pvpAccess a = accessContClears();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONT_CLEARS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CONT_CLEARS");
    return x;
  } else {
    throw pvpException("CONT_CLEARS not accessible for reading");
  }
}

void pvpCamera::setContClears(bool x) throw(pvpException) {
  pvpAccess a = accessContClears();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_CONT_CLEARS,(void*)(&y)))
      throw pvpException("Cannot set CONT_CLEARS");
  }
}

void pvpCamera::reportContClears() throw(pvpException) {
  if (availContClears()) {
    pvpAccess a = accessContClears();
    printf("ContClears: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getContClears() <<"\n";
        ss << "  min value: " << minContClears() <<"\n";
        ss << "  max value: " << maxContClears() <<"\n";
        ss << "  default value: " << defaultContClears() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countContClears());
  } else {
    printf("ContClears is not available.\n");
  }
}

char const *pvpCamera::AntiBlooming::decode() const {
  switch (x) {
    case Notused: return "Notused";
    case Inactive: return "Inactive";
    case Active: return "Active";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availAntiBlooming() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ANTI_BLOOMING availability");
  return avail;
}

pvpAccess pvpCamera::accessAntiBlooming() throw(pvpException) {
  uns16 access;
  if (!availAntiBlooming())
    throw pvpException("ANTI_BLOOMING not available");
  if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ANTI_BLOOMING accessibility");
  return pvpAccess(access);
}

int pvpCamera::countAntiBlooming() throw(pvpException) {
  uns32 count;
  if (!availAntiBlooming())
    throw pvpException("ANTI_BLOOMING not available");
  if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_COUNT,&count))
    throw pvpException("Cannot get ANTI_BLOOMING count");
  return count;
}

pvpCamera::AntiBlooming pvpCamera::getAntiBlooming() throw(pvpException) {
  pvpAccess a = accessAntiBlooming();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ANTI_BLOOMING");
    return x;
  } else {
    throw pvpException("ANTI_BLOOMING not accessible for reading");
  }
}

pvpCamera::AntiBlooming pvpCamera::defaultAntiBlooming() throw(pvpException) {
  pvpAccess a = accessAntiBlooming();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ANTI_BLOOMING");
    return x;
  } else {
    throw pvpException("ANTI_BLOOMING not accessible for reading");
  }
}

pvpCamera::AntiBlooming pvpCamera::minAntiBlooming() throw(pvpException) {
  pvpAccess a = accessAntiBlooming();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ANTI_BLOOMING");
    return x;
  } else {
    throw pvpException("ANTI_BLOOMING not accessible for reading");
  }
}

pvpCamera::AntiBlooming pvpCamera::maxAntiBlooming() throw(pvpException) {
  pvpAccess a = accessAntiBlooming();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_ANTI_BLOOMING,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ANTI_BLOOMING");
    return x;
  } else {
    throw pvpException("ANTI_BLOOMING not accessible for reading");
  }
}

void pvpCamera::setAntiBlooming(pvpCamera::AntiBlooming x) throw(pvpException) {
  pvpAccess a = accessAntiBlooming();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_ANTI_BLOOMING,(void*)(&y)))
      throw pvpException("Cannot set ANTI_BLOOMING");
  }
}

void pvpCamera::reportAntiBlooming() throw(pvpException) {
  if (availAntiBlooming()) {
    pvpAccess a = accessAntiBlooming();
    printf("AntiBlooming: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getAntiBlooming().decode() <<"\n";
        ss << "  min value: " << minAntiBlooming().decode() <<"\n";
        ss << "  max value: " << maxAntiBlooming().decode() <<"\n";
        ss << "  default value: " << defaultAntiBlooming().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countAntiBlooming());
  } else {
    printf("AntiBlooming is not available.\n");
  }
}

char const *pvpCamera::LogicOutput::decode() const {
  switch (x) {
    case NotScan: return "NotScan";
    case Shutter: return "Shutter";
    case NotRdy: return "NotRdy";
    case Logic0: return "Logic0";
    case Clearing: return "Clearing";
    case NotFtImageShift: return "NotFtImageShift";
    case Reserved: return "Reserved";
    case Logic1: return "Logic1";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availLogicOutput() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get LOGIC_OUTPUT availability");
  return avail;
}

pvpAccess pvpCamera::accessLogicOutput() throw(pvpException) {
  uns16 access;
  if (!availLogicOutput())
    throw pvpException("LOGIC_OUTPUT not available");
  if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get LOGIC_OUTPUT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countLogicOutput() throw(pvpException) {
  uns32 count;
  if (!availLogicOutput())
    throw pvpException("LOGIC_OUTPUT not available");
  if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_COUNT,&count))
    throw pvpException("Cannot get LOGIC_OUTPUT count");
  return count;
}

pvpCamera::LogicOutput pvpCamera::getLogicOutput() throw(pvpException) {
  pvpAccess a = accessLogicOutput();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read LOGIC_OUTPUT");
    return x;
  } else {
    throw pvpException("LOGIC_OUTPUT not accessible for reading");
  }
}

pvpCamera::LogicOutput pvpCamera::defaultLogicOutput() throw(pvpException) {
  pvpAccess a = accessLogicOutput();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of LOGIC_OUTPUT");
    return x;
  } else {
    throw pvpException("LOGIC_OUTPUT not accessible for reading");
  }
}

pvpCamera::LogicOutput pvpCamera::minLogicOutput() throw(pvpException) {
  pvpAccess a = accessLogicOutput();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of LOGIC_OUTPUT");
    return x;
  } else {
    throw pvpException("LOGIC_OUTPUT not accessible for reading");
  }
}

pvpCamera::LogicOutput pvpCamera::maxLogicOutput() throw(pvpException) {
  pvpAccess a = accessLogicOutput();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_LOGIC_OUTPUT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of LOGIC_OUTPUT");
    return x;
  } else {
    throw pvpException("LOGIC_OUTPUT not accessible for reading");
  }
}

void pvpCamera::setLogicOutput(pvpCamera::LogicOutput x) throw(pvpException) {
  pvpAccess a = accessLogicOutput();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_LOGIC_OUTPUT,(void*)(&y)))
      throw pvpException("Cannot set LOGIC_OUTPUT");
  }
}

void pvpCamera::reportLogicOutput() throw(pvpException) {
  if (availLogicOutput()) {
    pvpAccess a = accessLogicOutput();
    printf("LogicOutput: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getLogicOutput().decode() <<"\n";
        ss << "  min value: " << minLogicOutput().decode() <<"\n";
        ss << "  max value: " << maxLogicOutput().decode() <<"\n";
        ss << "  default value: " << defaultLogicOutput().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countLogicOutput());
  } else {
    printf("LogicOutput is not available.\n");
  }
}

char const *pvpCamera::EdgeTrigger::decode() const {
  switch (x) {
    case Pos: return "Pos";
    case Neg: return "Neg";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availEdgeTrigger() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EDGE_TRIGGER availability");
  return avail;
}

pvpAccess pvpCamera::accessEdgeTrigger() throw(pvpException) {
  uns16 access;
  if (!availEdgeTrigger())
    throw pvpException("EDGE_TRIGGER not available");
  if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EDGE_TRIGGER accessibility");
  return pvpAccess(access);
}

int pvpCamera::countEdgeTrigger() throw(pvpException) {
  uns32 count;
  if (!availEdgeTrigger())
    throw pvpException("EDGE_TRIGGER not available");
  if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_COUNT,&count))
    throw pvpException("Cannot get EDGE_TRIGGER count");
  return count;
}

pvpCamera::EdgeTrigger pvpCamera::getEdgeTrigger() throw(pvpException) {
  pvpAccess a = accessEdgeTrigger();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EDGE_TRIGGER");
    return x;
  } else {
    throw pvpException("EDGE_TRIGGER not accessible for reading");
  }
}

pvpCamera::EdgeTrigger pvpCamera::defaultEdgeTrigger() throw(pvpException) {
  pvpAccess a = accessEdgeTrigger();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EDGE_TRIGGER");
    return x;
  } else {
    throw pvpException("EDGE_TRIGGER not accessible for reading");
  }
}

pvpCamera::EdgeTrigger pvpCamera::minEdgeTrigger() throw(pvpException) {
  pvpAccess a = accessEdgeTrigger();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EDGE_TRIGGER");
    return x;
  } else {
    throw pvpException("EDGE_TRIGGER not accessible for reading");
  }
}

pvpCamera::EdgeTrigger pvpCamera::maxEdgeTrigger() throw(pvpException) {
  pvpAccess a = accessEdgeTrigger();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EDGE_TRIGGER,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EDGE_TRIGGER");
    return x;
  } else {
    throw pvpException("EDGE_TRIGGER not accessible for reading");
  }
}

void pvpCamera::setEdgeTrigger(pvpCamera::EdgeTrigger x) throw(pvpException) {
  pvpAccess a = accessEdgeTrigger();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_EDGE_TRIGGER,(void*)(&y)))
      throw pvpException("Cannot set EDGE_TRIGGER");
  }
}

void pvpCamera::reportEdgeTrigger() throw(pvpException) {
  if (availEdgeTrigger()) {
    pvpAccess a = accessEdgeTrigger();
    printf("EdgeTrigger: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getEdgeTrigger().decode() <<"\n";
        ss << "  min value: " << minEdgeTrigger().decode() <<"\n";
        ss << "  max value: " << maxEdgeTrigger().decode() <<"\n";
        ss << "  default value: " << defaultEdgeTrigger().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countEdgeTrigger());
  } else {
    printf("EdgeTrigger is not available.\n");
  }
}

bool pvpCamera::availIntensifierGain() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get INTENSIFIER_GAIN availability");
  return avail;
}

pvpAccess pvpCamera::accessIntensifierGain() throw(pvpException) {
  uns16 access;
  if (!availIntensifierGain())
    throw pvpException("INTENSIFIER_GAIN not available");
  if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_ACCESS,&access))
    throw pvpException("Cannot get INTENSIFIER_GAIN accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIntensifierGain() throw(pvpException) {
  uns32 count;
  if (!availIntensifierGain())
    throw pvpException("INTENSIFIER_GAIN not available");
  if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_COUNT,&count))
    throw pvpException("Cannot get INTENSIFIER_GAIN count");
  return count;
}

short pvpCamera::getIntensifierGain() throw(pvpException) {
  pvpAccess a = accessIntensifierGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_CURRENT,&x))
      throw pvpException("Cannot read INTENSIFIER_GAIN");
    return x;
  } else {
    throw pvpException("INTENSIFIER_GAIN not accessible for reading");
  }
}

short pvpCamera::defaultIntensifierGain() throw(pvpException) {
  pvpAccess a = accessIntensifierGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of INTENSIFIER_GAIN");
    return x;
  } else {
    throw pvpException("INTENSIFIER_GAIN not accessible for reading");
  }
}

short pvpCamera::minIntensifierGain() throw(pvpException) {
  pvpAccess a = accessIntensifierGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_MIN,&x))
      throw pvpException("Cannot read min of INTENSIFIER_GAIN");
    return x;
  } else {
    throw pvpException("INTENSIFIER_GAIN not accessible for reading");
  }
}

short pvpCamera::maxIntensifierGain() throw(pvpException) {
  pvpAccess a = accessIntensifierGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_INTENSIFIER_GAIN,ATTR_MAX,&x))
      throw pvpException("Cannot read max of INTENSIFIER_GAIN");
    return x;
  } else {
    throw pvpException("INTENSIFIER_GAIN not accessible for reading");
  }
}

void pvpCamera::setIntensifierGain(short x) throw(pvpException) {
  pvpAccess a = accessIntensifierGain();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_INTENSIFIER_GAIN,(void*)(&y)))
      throw pvpException("Cannot set INTENSIFIER_GAIN");
  }
}

void pvpCamera::reportIntensifierGain() throw(pvpException) {
  if (availIntensifierGain()) {
    pvpAccess a = accessIntensifierGain();
    printf("IntensifierGain: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIntensifierGain() <<"\n";
        ss << "  min value: " << minIntensifierGain() <<"\n";
        ss << "  max value: " << maxIntensifierGain() <<"\n";
        ss << "  default value: " << defaultIntensifierGain() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countIntensifierGain());
  } else {
    printf("IntensifierGain is not available.\n");
  }
}

char const *pvpCamera::ShtrGateMode::decode() const {
  switch (x) {
    case Safe: return "Safe";
    case Gating: return "Gating";
    case Shutter: return "Shutter";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availShtrGateMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_GATE_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrGateMode() throw(pvpException) {
  uns16 access;
  if (!availShtrGateMode())
    throw pvpException("SHTR_GATE_MODE not available");
  if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_GATE_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrGateMode() throw(pvpException) {
  uns32 count;
  if (!availShtrGateMode())
    throw pvpException("SHTR_GATE_MODE not available");
  if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_GATE_MODE count");
  return count;
}

pvpCamera::ShtrGateMode pvpCamera::getShtrGateMode() throw(pvpException) {
  pvpAccess a = accessShtrGateMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_GATE_MODE");
    return x;
  } else {
    throw pvpException("SHTR_GATE_MODE not accessible for reading");
  }
}

pvpCamera::ShtrGateMode pvpCamera::defaultShtrGateMode() throw(pvpException) {
  pvpAccess a = accessShtrGateMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_GATE_MODE");
    return x;
  } else {
    throw pvpException("SHTR_GATE_MODE not accessible for reading");
  }
}

pvpCamera::ShtrGateMode pvpCamera::minShtrGateMode() throw(pvpException) {
  pvpAccess a = accessShtrGateMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_GATE_MODE");
    return x;
  } else {
    throw pvpException("SHTR_GATE_MODE not accessible for reading");
  }
}

pvpCamera::ShtrGateMode pvpCamera::maxShtrGateMode() throw(pvpException) {
  pvpAccess a = accessShtrGateMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_GATE_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_GATE_MODE");
    return x;
  } else {
    throw pvpException("SHTR_GATE_MODE not accessible for reading");
  }
}

void pvpCamera::setShtrGateMode(pvpCamera::ShtrGateMode x) throw(pvpException) {
  pvpAccess a = accessShtrGateMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_GATE_MODE,(void*)(&y)))
      throw pvpException("Cannot set SHTR_GATE_MODE");
  }
}

void pvpCamera::reportShtrGateMode() throw(pvpException) {
  if (availShtrGateMode()) {
    pvpAccess a = accessShtrGateMode();
    printf("ShtrGateMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrGateMode().decode() <<"\n";
        ss << "  min value: " << minShtrGateMode().decode() <<"\n";
        ss << "  max value: " << maxShtrGateMode().decode() <<"\n";
        ss << "  default value: " << defaultShtrGateMode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countShtrGateMode());
  } else {
    printf("ShtrGateMode is not available.\n");
  }
}

bool pvpCamera::availAdcOffset() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ADC_OFFSET availability");
  return avail;
}

pvpAccess pvpCamera::accessAdcOffset() throw(pvpException) {
  uns16 access;
  if (!availAdcOffset())
    throw pvpException("ADC_OFFSET not available");
  if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ADC_OFFSET accessibility");
  return pvpAccess(access);
}

int pvpCamera::countAdcOffset() throw(pvpException) {
  uns32 count;
  if (!availAdcOffset())
    throw pvpException("ADC_OFFSET not available");
  if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_COUNT,&count))
    throw pvpException("Cannot get ADC_OFFSET count");
  return count;
}

short pvpCamera::getAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

short pvpCamera::defaultAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

short pvpCamera::minAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

short pvpCamera::maxAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

void pvpCamera::setAdcOffset(short x) throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_ADC_OFFSET,(void*)(&y)))
      throw pvpException("Cannot set ADC_OFFSET");
  }
}

void pvpCamera::reportAdcOffset() throw(pvpException) {
  if (availAdcOffset()) {
    pvpAccess a = accessAdcOffset();
    printf("AdcOffset: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getAdcOffset() <<"\n";
        ss << "  min value: " << minAdcOffset() <<"\n";
        ss << "  max value: " << maxAdcOffset() <<"\n";
        ss << "  default value: " << defaultAdcOffset() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countAdcOffset());
  } else {
    printf("AdcOffset is not available.\n");
  }
}

bool pvpCamera::availChipName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CHIP_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessChipName() throw(pvpException) {
  uns16 access;
  if (!availChipName())
    throw pvpException("CHIP_NAME not available");
  if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CHIP_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countChipName() throw(pvpException) {
  uns32 count;
  if (!availChipName())
    throw pvpException("CHIP_NAME not available");
  if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get CHIP_NAME count");
  return count;
}

QString pvpCamera::getChipName() throw(pvpException) {
  pvpAccess a = accessChipName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char *x = memalloc<char>(countChipName(), "pvcam");
    if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_CURRENT,x))
      throw pvpException("Cannot read CHIP_NAME");
    QString y = x;
    delete [] x;
    return y;
  } else {
    throw pvpException("CHIP_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultChipName() throw(pvpException) {
  pvpAccess a = accessChipName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countChipName()];
    if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of CHIP_NAME");
    return x;
  } else {
    throw pvpException("CHIP_NAME not accessible for reading");
  }
}

QString pvpCamera::minChipName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxChipName() throw(pvpException) {
    return "";
}

void pvpCamera::setChipName(QString x) throw(pvpException) {
  pvpAccess a = accessChipName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_CHIP_NAME,(void*)(x.toAscii().data())))
      throw pvpException("Cannot set CHIP_NAME");
  }
}

void pvpCamera::reportChipName() throw(pvpException) {
  if (availChipName()) {
    pvpAccess a = accessChipName();
    printf("ChipName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getChipName() <<"\n";
        ss << "  min value: " << minChipName() <<"\n";
        ss << "  max value: " << maxChipName() <<"\n";
        ss << "  default value: " << defaultChipName() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countChipName());
  } else {
    printf("ChipName is not available.\n");
  }
}

char const *pvpCamera::CoolingMode::decode() const {
  switch (x) {
    case NormalCool: return "NormalCool";
    case CryoCool: return "CryoCool";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availCoolingMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get COOLING_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessCoolingMode() throw(pvpException) {
  uns16 access;
  if (!availCoolingMode())
    throw pvpException("COOLING_MODE not available");
  if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get COOLING_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCoolingMode() throw(pvpException) {
  uns32 count;
  if (!availCoolingMode())
    throw pvpException("COOLING_MODE not available");
  if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get COOLING_MODE count");
  return count;
}

pvpCamera::CoolingMode pvpCamera::getCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

pvpCamera::CoolingMode pvpCamera::defaultCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

pvpCamera::CoolingMode pvpCamera::minCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

pvpCamera::CoolingMode pvpCamera::maxCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

void pvpCamera::setCoolingMode(pvpCamera::CoolingMode x) throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_COOLING_MODE,(void*)(&y)))
      throw pvpException("Cannot set COOLING_MODE");
  }
}

void pvpCamera::reportCoolingMode() throw(pvpException) {
  if (availCoolingMode()) {
    pvpAccess a = accessCoolingMode();
    printf("CoolingMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCoolingMode().decode() <<"\n";
        ss << "  min value: " << minCoolingMode().decode() <<"\n";
        ss << "  max value: " << maxCoolingMode().decode() <<"\n";
        ss << "  default value: " << defaultCoolingMode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countCoolingMode());
  } else {
    printf("CoolingMode is not available.\n");
  }
}

bool pvpCamera::availPreampDelay() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREAMP_DELAY availability");
  return avail;
}

pvpAccess pvpCamera::accessPreampDelay() throw(pvpException) {
  uns16 access;
  if (!availPreampDelay())
    throw pvpException("PREAMP_DELAY not available");
  if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREAMP_DELAY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPreampDelay() throw(pvpException) {
  uns32 count;
  if (!availPreampDelay())
    throw pvpException("PREAMP_DELAY not available");
  if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREAMP_DELAY count");
  return count;
}

unsigned short pvpCamera::getPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::minPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::maxPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

void pvpCamera::setPreampDelay(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PREAMP_DELAY,(void*)(&y)))
      throw pvpException("Cannot set PREAMP_DELAY");
  }
}

void pvpCamera::reportPreampDelay() throw(pvpException) {
  if (availPreampDelay()) {
    pvpAccess a = accessPreampDelay();
    printf("PreampDelay: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPreampDelay() <<"\n";
        ss << "  min value: " << minPreampDelay() <<"\n";
        ss << "  max value: " << maxPreampDelay() <<"\n";
        ss << "  default value: " << defaultPreampDelay() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPreampDelay());
  } else {
    printf("PreampDelay is not available.\n");
  }
}

bool pvpCamera::availPreflash() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREFLASH availability");
  return avail;
}

pvpAccess pvpCamera::accessPreflash() throw(pvpException) {
  uns16 access;
  if (!availPreflash())
    throw pvpException("PREFLASH not available");
  if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREFLASH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPreflash() throw(pvpException) {
  uns32 count;
  if (!availPreflash())
    throw pvpException("PREFLASH not available");
  if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREFLASH count");
  return count;
}

unsigned short pvpCamera::getPreflash() throw(pvpException) {
  pvpAccess a = accessPreflash();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREFLASH");
    return x;
  } else {
    throw pvpException("PREFLASH not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPreflash() throw(pvpException) {
  pvpAccess a = accessPreflash();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREFLASH");
    return x;
  } else {
    throw pvpException("PREFLASH not accessible for reading");
  }
}

unsigned short pvpCamera::minPreflash() throw(pvpException) {
  pvpAccess a = accessPreflash();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREFLASH");
    return x;
  } else {
    throw pvpException("PREFLASH not accessible for reading");
  }
}

unsigned short pvpCamera::maxPreflash() throw(pvpException) {
  pvpAccess a = accessPreflash();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREFLASH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREFLASH");
    return x;
  } else {
    throw pvpException("PREFLASH not accessible for reading");
  }
}

void pvpCamera::setPreflash(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPreflash();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PREFLASH,(void*)(&y)))
      throw pvpException("Cannot set PREFLASH");
  }
}

void pvpCamera::reportPreflash() throw(pvpException) {
  if (availPreflash()) {
    pvpAccess a = accessPreflash();
    printf("Preflash: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPreflash() <<"\n";
        ss << "  min value: " << minPreflash() <<"\n";
        ss << "  max value: " << maxPreflash() <<"\n";
        ss << "  default value: " << defaultPreflash() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPreflash());
  } else {
    printf("Preflash is not available.\n");
  }
}

char const *pvpCamera::ColorMode::decode() const {
  switch (x) {
    case None: return "None";
    case Rggb: return "Rggb";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availColorMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get COLOR_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessColorMode() throw(pvpException) {
  uns16 access;
  if (!availColorMode())
    throw pvpException("COLOR_MODE not available");
  if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get COLOR_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countColorMode() throw(pvpException) {
  uns32 count;
  if (!availColorMode())
    throw pvpException("COLOR_MODE not available");
  if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get COLOR_MODE count");
  return count;
}

pvpCamera::ColorMode pvpCamera::getColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

pvpCamera::ColorMode pvpCamera::defaultColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

pvpCamera::ColorMode pvpCamera::minColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

pvpCamera::ColorMode pvpCamera::maxColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

void pvpCamera::setColorMode(pvpCamera::ColorMode x) throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_COLOR_MODE,(void*)(&y)))
      throw pvpException("Cannot set COLOR_MODE");
  }
}

void pvpCamera::reportColorMode() throw(pvpException) {
  if (availColorMode()) {
    pvpAccess a = accessColorMode();
    printf("ColorMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getColorMode().decode() <<"\n";
        ss << "  min value: " << minColorMode().decode() <<"\n";
        ss << "  max value: " << maxColorMode().decode() <<"\n";
        ss << "  default value: " << defaultColorMode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countColorMode());
  } else {
    printf("ColorMode is not available.\n");
  }
}

char const *pvpCamera::MppCapable::decode() const {
  switch (x) {
    case Unknown: return "Unknown";
    case AlwaysOff: return "AlwaysOff";
    case AlwaysOn: return "AlwaysOn";
    case Selectable: return "Selectable";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availMppCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get MPP_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessMppCapable() throw(pvpException) {
  uns16 access;
  if (!availMppCapable())
    throw pvpException("MPP_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get MPP_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countMppCapable() throw(pvpException) {
  uns32 count;
  if (!availMppCapable())
    throw pvpException("MPP_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get MPP_CAPABLE count");
  return count;
}

pvpCamera::MppCapable pvpCamera::getMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

pvpCamera::MppCapable pvpCamera::defaultMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

pvpCamera::MppCapable pvpCamera::minMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

pvpCamera::MppCapable pvpCamera::maxMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setMppCapable(pvpCamera::MppCapable x) throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_MPP_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set MPP_CAPABLE");
  }
}

void pvpCamera::reportMppCapable() throw(pvpException) {
  if (availMppCapable()) {
    pvpAccess a = accessMppCapable();
    printf("MppCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getMppCapable().decode() <<"\n";
        ss << "  min value: " << minMppCapable().decode() <<"\n";
        ss << "  max value: " << maxMppCapable().decode() <<"\n";
        ss << "  default value: " << defaultMppCapable().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countMppCapable());
  } else {
    printf("MppCapable is not available.\n");
  }
}

bool pvpCamera::availPreampOffControl() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREAMP_OFF_CONTROL availability");
  return avail;
}

pvpAccess pvpCamera::accessPreampOffControl() throw(pvpException) {
  uns16 access;
  if (!availPreampOffControl())
    throw pvpException("PREAMP_OFF_CONTROL not available");
  if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREAMP_OFF_CONTROL accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPreampOffControl() throw(pvpException) {
  uns32 count;
  if (!availPreampOffControl())
    throw pvpException("PREAMP_OFF_CONTROL not available");
  if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREAMP_OFF_CONTROL count");
  return count;
}

unsigned long pvpCamera::getPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

unsigned long pvpCamera::defaultPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

unsigned long pvpCamera::minPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

unsigned long pvpCamera::maxPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

void pvpCamera::setPreampOffControl(unsigned long x) throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_PREAMP_OFF_CONTROL,(void*)(&y)))
      throw pvpException("Cannot set PREAMP_OFF_CONTROL");
  }
}

void pvpCamera::reportPreampOffControl() throw(pvpException) {
  if (availPreampOffControl()) {
    pvpAccess a = accessPreampOffControl();
    printf("PreampOffControl: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPreampOffControl() <<"\n";
        ss << "  min value: " << minPreampOffControl() <<"\n";
        ss << "  max value: " << maxPreampOffControl() <<"\n";
        ss << "  default value: " << defaultPreampOffControl() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPreampOffControl());
  } else {
    printf("PreampOffControl is not available.\n");
  }
}

bool pvpCamera::availSerialNum() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SERIAL_NUM availability");
  return avail;
}

pvpAccess pvpCamera::accessSerialNum() throw(pvpException) {
  uns16 access;
  if (!availSerialNum())
    throw pvpException("SERIAL_NUM not available");
  if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SERIAL_NUM accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSerialNum() throw(pvpException) {
  uns32 count;
  if (!availSerialNum())
    throw pvpException("SERIAL_NUM not available");
  if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_COUNT,&count))
    throw pvpException("Cannot get SERIAL_NUM count");
  return count;
}

unsigned short pvpCamera::getSerialNum() throw(pvpException) {
  pvpAccess a = accessSerialNum();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SERIAL_NUM");
    return x;
  } else {
    throw pvpException("SERIAL_NUM not accessible for reading");
  }
}

unsigned short pvpCamera::defaultSerialNum() throw(pvpException) {
  pvpAccess a = accessSerialNum();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SERIAL_NUM");
    return x;
  } else {
    throw pvpException("SERIAL_NUM not accessible for reading");
  }
}

unsigned short pvpCamera::minSerialNum() throw(pvpException) {
  pvpAccess a = accessSerialNum();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SERIAL_NUM");
    return x;
  } else {
    throw pvpException("SERIAL_NUM not accessible for reading");
  }
}

unsigned short pvpCamera::maxSerialNum() throw(pvpException) {
  pvpAccess a = accessSerialNum();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SERIAL_NUM,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SERIAL_NUM");
    return x;
  } else {
    throw pvpException("SERIAL_NUM not accessible for reading");
  }
}

void pvpCamera::setSerialNum(unsigned short x) throw(pvpException) {
  pvpAccess a = accessSerialNum();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_SERIAL_NUM,(void*)(&y)))
      throw pvpException("Cannot set SERIAL_NUM");
  }
}

void pvpCamera::reportSerialNum() throw(pvpException) {
  if (availSerialNum()) {
    pvpAccess a = accessSerialNum();
    printf("SerialNum: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSerialNum() <<"\n";
        ss << "  min value: " << minSerialNum() <<"\n";
        ss << "  max value: " << maxSerialNum() <<"\n";
        ss << "  default value: " << defaultSerialNum() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countSerialNum());
  } else {
    printf("SerialNum is not available.\n");
  }
}

bool pvpCamera::availPremask() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREMASK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREMASK availability");
  return avail;
}

pvpAccess pvpCamera::accessPremask() throw(pvpException) {
  uns16 access;
  if (!availPremask())
    throw pvpException("PREMASK not available");
  if (!pl_get_param(camh,PARAM_PREMASK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREMASK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPremask() throw(pvpException) {
  uns32 count;
  if (!availPremask())
    throw pvpException("PREMASK not available");
  if (!pl_get_param(camh,PARAM_PREMASK,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREMASK count");
  return count;
}

unsigned short pvpCamera::getPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

unsigned short pvpCamera::minPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

unsigned short pvpCamera::maxPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

void pvpCamera::setPremask(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PREMASK,(void*)(&y)))
      throw pvpException("Cannot set PREMASK");
  }
}

void pvpCamera::reportPremask() throw(pvpException) {
  if (availPremask()) {
    pvpAccess a = accessPremask();
    printf("Premask: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPremask() <<"\n";
        ss << "  min value: " << minPremask() <<"\n";
        ss << "  max value: " << maxPremask() <<"\n";
        ss << "  default value: " << defaultPremask() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPremask());
  } else {
    printf("Premask is not available.\n");
  }
}

bool pvpCamera::availPrescan() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PRESCAN availability");
  return avail;
}

pvpAccess pvpCamera::accessPrescan() throw(pvpException) {
  uns16 access;
  if (!availPrescan())
    throw pvpException("PRESCAN not available");
  if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PRESCAN accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPrescan() throw(pvpException) {
  uns32 count;
  if (!availPrescan())
    throw pvpException("PRESCAN not available");
  if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_COUNT,&count))
    throw pvpException("Cannot get PRESCAN count");
  return count;
}

unsigned short pvpCamera::getPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

unsigned short pvpCamera::minPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

unsigned short pvpCamera::maxPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

void pvpCamera::setPrescan(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PRESCAN,(void*)(&y)))
      throw pvpException("Cannot set PRESCAN");
  }
}

void pvpCamera::reportPrescan() throw(pvpException) {
  if (availPrescan()) {
    pvpAccess a = accessPrescan();
    printf("Prescan: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPrescan() <<"\n";
        ss << "  min value: " << minPrescan() <<"\n";
        ss << "  max value: " << maxPrescan() <<"\n";
        ss << "  default value: " << defaultPrescan() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPrescan());
  } else {
    printf("Prescan is not available.\n");
  }
}

bool pvpCamera::availPostmask() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get POSTMASK availability");
  return avail;
}

pvpAccess pvpCamera::accessPostmask() throw(pvpException) {
  uns16 access;
  if (!availPostmask())
    throw pvpException("POSTMASK not available");
  if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get POSTMASK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPostmask() throw(pvpException) {
  uns32 count;
  if (!availPostmask())
    throw pvpException("POSTMASK not available");
  if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_COUNT,&count))
    throw pvpException("Cannot get POSTMASK count");
  return count;
}

unsigned short pvpCamera::getPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

unsigned short pvpCamera::minPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

unsigned short pvpCamera::maxPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

void pvpCamera::setPostmask(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_POSTMASK,(void*)(&y)))
      throw pvpException("Cannot set POSTMASK");
  }
}

void pvpCamera::reportPostmask() throw(pvpException) {
  if (availPostmask()) {
    pvpAccess a = accessPostmask();
    printf("Postmask: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPostmask() <<"\n";
        ss << "  min value: " << minPostmask() <<"\n";
        ss << "  max value: " << maxPostmask() <<"\n";
        ss << "  default value: " << defaultPostmask() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPostmask());
  } else {
    printf("Postmask is not available.\n");
  }
}

bool pvpCamera::availPostscan() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get POSTSCAN availability");
  return avail;
}

pvpAccess pvpCamera::accessPostscan() throw(pvpException) {
  uns16 access;
  if (!availPostscan())
    throw pvpException("POSTSCAN not available");
  if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_ACCESS,&access))
    throw pvpException("Cannot get POSTSCAN accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPostscan() throw(pvpException) {
  uns32 count;
  if (!availPostscan())
    throw pvpException("POSTSCAN not available");
  if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_COUNT,&count))
    throw pvpException("Cannot get POSTSCAN count");
  return count;
}

unsigned short pvpCamera::getPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_CURRENT,&x))
      throw pvpException("Cannot read POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

unsigned short pvpCamera::minPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_MIN,&x))
      throw pvpException("Cannot read min of POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

unsigned short pvpCamera::maxPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_MAX,&x))
      throw pvpException("Cannot read max of POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

void pvpCamera::setPostscan(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_POSTSCAN,(void*)(&y)))
      throw pvpException("Cannot set POSTSCAN");
  }
}

void pvpCamera::reportPostscan() throw(pvpException) {
  if (availPostscan()) {
    pvpAccess a = accessPostscan();
    printf("Postscan: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPostscan() <<"\n";
        ss << "  min value: " << minPostscan() <<"\n";
        ss << "  max value: " << maxPostscan() <<"\n";
        ss << "  default value: " << defaultPostscan() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPostscan());
  } else {
    printf("Postscan is not available.\n");
  }
}

bool pvpCamera::availPixParDist() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_PAR_DIST availability");
  return avail;
}

pvpAccess pvpCamera::accessPixParDist() throw(pvpException) {
  uns16 access;
  if (!availPixParDist())
    throw pvpException("PIX_PAR_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_PAR_DIST accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixParDist() throw(pvpException) {
  uns32 count;
  if (!availPixParDist())
    throw pvpException("PIX_PAR_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_PAR_DIST count");
  return count;
}

unsigned short pvpCamera::getPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

unsigned short pvpCamera::minPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

unsigned short pvpCamera::maxPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

void pvpCamera::setPixParDist(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PIX_PAR_DIST,(void*)(&y)))
      throw pvpException("Cannot set PIX_PAR_DIST");
  }
}

void pvpCamera::reportPixParDist() throw(pvpException) {
  if (availPixParDist()) {
    pvpAccess a = accessPixParDist();
    printf("PixParDist: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixParDist() <<"\n";
        ss << "  min value: " << minPixParDist() <<"\n";
        ss << "  max value: " << maxPixParDist() <<"\n";
        ss << "  default value: " << defaultPixParDist() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPixParDist());
  } else {
    printf("PixParDist is not available.\n");
  }
}

bool pvpCamera::availPixParSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_PAR_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessPixParSize() throw(pvpException) {
  uns16 access;
  if (!availPixParSize())
    throw pvpException("PIX_PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_PAR_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixParSize() throw(pvpException) {
  uns32 count;
  if (!availPixParSize())
    throw pvpException("PIX_PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_PAR_SIZE count");
  return count;
}

unsigned short pvpCamera::getPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::minPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::maxPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

void pvpCamera::setPixParSize(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PIX_PAR_SIZE,(void*)(&y)))
      throw pvpException("Cannot set PIX_PAR_SIZE");
  }
}

void pvpCamera::reportPixParSize() throw(pvpException) {
  if (availPixParSize()) {
    pvpAccess a = accessPixParSize();
    printf("PixParSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixParSize() <<"\n";
        ss << "  min value: " << minPixParSize() <<"\n";
        ss << "  max value: " << maxPixParSize() <<"\n";
        ss << "  default value: " << defaultPixParSize() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPixParSize());
  } else {
    printf("PixParSize is not available.\n");
  }
}

bool pvpCamera::availPixSerDist() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_SER_DIST availability");
  return avail;
}

pvpAccess pvpCamera::accessPixSerDist() throw(pvpException) {
  uns16 access;
  if (!availPixSerDist())
    throw pvpException("PIX_SER_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_SER_DIST accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixSerDist() throw(pvpException) {
  uns32 count;
  if (!availPixSerDist())
    throw pvpException("PIX_SER_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_SER_DIST count");
  return count;
}

unsigned short pvpCamera::getPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

unsigned short pvpCamera::minPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

unsigned short pvpCamera::maxPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

void pvpCamera::setPixSerDist(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PIX_SER_DIST,(void*)(&y)))
      throw pvpException("Cannot set PIX_SER_DIST");
  }
}

void pvpCamera::reportPixSerDist() throw(pvpException) {
  if (availPixSerDist()) {
    pvpAccess a = accessPixSerDist();
    printf("PixSerDist: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixSerDist() <<"\n";
        ss << "  min value: " << minPixSerDist() <<"\n";
        ss << "  max value: " << maxPixSerDist() <<"\n";
        ss << "  default value: " << defaultPixSerDist() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPixSerDist());
  } else {
    printf("PixSerDist is not available.\n");
  }
}

bool pvpCamera::availPixSerSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_SER_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessPixSerSize() throw(pvpException) {
  uns16 access;
  if (!availPixSerSize())
    throw pvpException("PIX_SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_SER_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixSerSize() throw(pvpException) {
  uns32 count;
  if (!availPixSerSize())
    throw pvpException("PIX_SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_SER_SIZE count");
  return count;
}

unsigned short pvpCamera::getPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::minPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::maxPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

void pvpCamera::setPixSerSize(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PIX_SER_SIZE,(void*)(&y)))
      throw pvpException("Cannot set PIX_SER_SIZE");
  }
}

void pvpCamera::reportPixSerSize() throw(pvpException) {
  if (availPixSerSize()) {
    pvpAccess a = accessPixSerSize();
    printf("PixSerSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixSerSize() <<"\n";
        ss << "  min value: " << minPixSerSize() <<"\n";
        ss << "  max value: " << maxPixSerSize() <<"\n";
        ss << "  default value: " << defaultPixSerSize() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPixSerSize());
  } else {
    printf("PixSerSize is not available.\n");
  }
}

bool pvpCamera::availSummingWell() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SUMMING_WELL availability");
  return avail;
}

pvpAccess pvpCamera::accessSummingWell() throw(pvpException) {
  uns16 access;
  if (!availSummingWell())
    throw pvpException("SUMMING_WELL not available");
  if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SUMMING_WELL accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSummingWell() throw(pvpException) {
  uns32 count;
  if (!availSummingWell())
    throw pvpException("SUMMING_WELL not available");
  if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_COUNT,&count))
    throw pvpException("Cannot get SUMMING_WELL count");
  return count;
}

bool pvpCamera::getSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

bool pvpCamera::defaultSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

bool pvpCamera::minSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

bool pvpCamera::maxSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

void pvpCamera::setSummingWell(bool x) throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_SUMMING_WELL,(void*)(&y)))
      throw pvpException("Cannot set SUMMING_WELL");
  }
}

void pvpCamera::reportSummingWell() throw(pvpException) {
  if (availSummingWell()) {
    pvpAccess a = accessSummingWell();
    printf("SummingWell: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSummingWell() <<"\n";
        ss << "  min value: " << minSummingWell() <<"\n";
        ss << "  max value: " << maxSummingWell() <<"\n";
        ss << "  default value: " << defaultSummingWell() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countSummingWell());
  } else {
    printf("SummingWell is not available.\n");
  }
}

bool pvpCamera::availFwellCapacity() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FWELL_CAPACITY availability");
  return avail;
}

pvpAccess pvpCamera::accessFwellCapacity() throw(pvpException) {
  uns16 access;
  if (!availFwellCapacity())
    throw pvpException("FWELL_CAPACITY not available");
  if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FWELL_CAPACITY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFwellCapacity() throw(pvpException) {
  uns32 count;
  if (!availFwellCapacity())
    throw pvpException("FWELL_CAPACITY not available");
  if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_COUNT,&count))
    throw pvpException("Cannot get FWELL_CAPACITY count");
  return count;
}

unsigned long pvpCamera::getFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

unsigned long pvpCamera::defaultFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

unsigned long pvpCamera::minFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

unsigned long pvpCamera::maxFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

void pvpCamera::setFwellCapacity(unsigned long x) throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_FWELL_CAPACITY,(void*)(&y)))
      throw pvpException("Cannot set FWELL_CAPACITY");
  }
}

void pvpCamera::reportFwellCapacity() throw(pvpException) {
  if (availFwellCapacity()) {
    pvpAccess a = accessFwellCapacity();
    printf("FwellCapacity: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFwellCapacity() <<"\n";
        ss << "  min value: " << minFwellCapacity() <<"\n";
        ss << "  max value: " << maxFwellCapacity() <<"\n";
        ss << "  default value: " << defaultFwellCapacity() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countFwellCapacity());
  } else {
    printf("FwellCapacity is not available.\n");
  }
}

bool pvpCamera::availParSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PAR_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessParSize() throw(pvpException) {
  uns16 access;
  if (!availParSize())
    throw pvpException("PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PAR_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countParSize() throw(pvpException) {
  uns32 count;
  if (!availParSize())
    throw pvpException("PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PAR_SIZE count");
  return count;
}

unsigned short pvpCamera::getParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::defaultParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::minParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::maxParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

void pvpCamera::setParSize(unsigned short x) throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PAR_SIZE,(void*)(&y)))
      throw pvpException("Cannot set PAR_SIZE");
  }
}

void pvpCamera::reportParSize() throw(pvpException) {
  if (availParSize()) {
    pvpAccess a = accessParSize();
    printf("ParSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getParSize() <<"\n";
        ss << "  min value: " << minParSize() <<"\n";
        ss << "  max value: " << maxParSize() <<"\n";
        ss << "  default value: " << defaultParSize() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countParSize());
  } else {
    printf("ParSize is not available.\n");
  }
}

bool pvpCamera::availSerSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SER_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessSerSize() throw(pvpException) {
  uns16 access;
  if (!availSerSize())
    throw pvpException("SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SER_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSerSize() throw(pvpException) {
  uns32 count;
  if (!availSerSize())
    throw pvpException("SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get SER_SIZE count");
  return count;
}

unsigned short pvpCamera::getSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::defaultSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::minSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

unsigned short pvpCamera::maxSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

void pvpCamera::setSerSize(unsigned short x) throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_SER_SIZE,(void*)(&y)))
      throw pvpException("Cannot set SER_SIZE");
  }
}

void pvpCamera::reportSerSize() throw(pvpException) {
  if (availSerSize()) {
    pvpAccess a = accessSerSize();
    printf("SerSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSerSize() <<"\n";
        ss << "  min value: " << minSerSize() <<"\n";
        ss << "  max value: " << maxSerSize() <<"\n";
        ss << "  default value: " << defaultSerSize() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countSerSize());
  } else {
    printf("SerSize is not available.\n");
  }
}

bool pvpCamera::availAccumCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ACCUM_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessAccumCapable() throw(pvpException) {
  uns16 access;
  if (!availAccumCapable())
    throw pvpException("ACCUM_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ACCUM_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countAccumCapable() throw(pvpException) {
  uns32 count;
  if (!availAccumCapable())
    throw pvpException("ACCUM_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get ACCUM_CAPABLE count");
  return count;
}

bool pvpCamera::getAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::defaultAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::minAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::maxAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setAccumCapable(bool x) throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_ACCUM_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set ACCUM_CAPABLE");
  }
}

void pvpCamera::reportAccumCapable() throw(pvpException) {
  if (availAccumCapable()) {
    pvpAccess a = accessAccumCapable();
    printf("AccumCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getAccumCapable() <<"\n";
        ss << "  min value: " << minAccumCapable() <<"\n";
        ss << "  max value: " << maxAccumCapable() <<"\n";
        ss << "  default value: " << defaultAccumCapable() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countAccumCapable());
  } else {
    printf("AccumCapable is not available.\n");
  }
}

bool pvpCamera::availFlashDwnldCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FLASH_DWNLD_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessFlashDwnldCapable() throw(pvpException) {
  uns16 access;
  if (!availFlashDwnldCapable())
    throw pvpException("FLASH_DWNLD_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FLASH_DWNLD_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFlashDwnldCapable() throw(pvpException) {
  uns32 count;
  if (!availFlashDwnldCapable())
    throw pvpException("FLASH_DWNLD_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get FLASH_DWNLD_CAPABLE count");
  return count;
}

bool pvpCamera::getFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::defaultFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::minFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::maxFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setFlashDwnldCapable(bool x) throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_FLASH_DWNLD_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set FLASH_DWNLD_CAPABLE");
  }
}

void pvpCamera::reportFlashDwnldCapable() throw(pvpException) {
  if (availFlashDwnldCapable()) {
    pvpAccess a = accessFlashDwnldCapable();
    printf("FlashDwnldCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFlashDwnldCapable() <<"\n";
        ss << "  min value: " << minFlashDwnldCapable() <<"\n";
        ss << "  max value: " << maxFlashDwnldCapable() <<"\n";
        ss << "  default value: " << defaultFlashDwnldCapable() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countFlashDwnldCapable());
  } else {
    printf("FlashDwnldCapable is not available.\n");
  }
}

bool pvpCamera::availControllerAlive() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CONTROLLER_ALIVE availability");
  return avail;
}

pvpAccess pvpCamera::accessControllerAlive() throw(pvpException) {
  uns16 access;
  if (!availControllerAlive())
    throw pvpException("CONTROLLER_ALIVE not available");
  if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CONTROLLER_ALIVE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countControllerAlive() throw(pvpException) {
  uns32 count;
  if (!availControllerAlive())
    throw pvpException("CONTROLLER_ALIVE not available");
  if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_COUNT,&count))
    throw pvpException("Cannot get CONTROLLER_ALIVE count");
  return count;
}

bool pvpCamera::getControllerAlive() throw(pvpException) {
  pvpAccess a = accessControllerAlive();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CONTROLLER_ALIVE");
    return x;
  } else {
    throw pvpException("CONTROLLER_ALIVE not accessible for reading");
  }
}

bool pvpCamera::defaultControllerAlive() throw(pvpException) {
  pvpAccess a = accessControllerAlive();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CONTROLLER_ALIVE");
    return x;
  } else {
    throw pvpException("CONTROLLER_ALIVE not accessible for reading");
  }
}

bool pvpCamera::minControllerAlive() throw(pvpException) {
  pvpAccess a = accessControllerAlive();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CONTROLLER_ALIVE");
    return x;
  } else {
    throw pvpException("CONTROLLER_ALIVE not accessible for reading");
  }
}

bool pvpCamera::maxControllerAlive() throw(pvpException) {
  pvpAccess a = accessControllerAlive();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_CONTROLLER_ALIVE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CONTROLLER_ALIVE");
    return x;
  } else {
    throw pvpException("CONTROLLER_ALIVE not accessible for reading");
  }
}

void pvpCamera::setControllerAlive(bool x) throw(pvpException) {
  pvpAccess a = accessControllerAlive();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_CONTROLLER_ALIVE,(void*)(&y)))
      throw pvpException("Cannot set CONTROLLER_ALIVE");
  }
}

void pvpCamera::reportControllerAlive() throw(pvpException) {
  if (availControllerAlive()) {
    pvpAccess a = accessControllerAlive();
    printf("ControllerAlive: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getControllerAlive() <<"\n";
        ss << "  min value: " << minControllerAlive() <<"\n";
        ss << "  max value: " << maxControllerAlive() <<"\n";
        ss << "  default value: " << defaultControllerAlive() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countControllerAlive());
  } else {
    printf("ControllerAlive is not available.\n");
  }
}

bool pvpCamera::availReadoutTime() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get READOUT_TIME availability");
  return avail;
}

pvpAccess pvpCamera::accessReadoutTime() throw(pvpException) {
  uns16 access;
  if (!availReadoutTime())
    throw pvpException("READOUT_TIME not available");
  if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get READOUT_TIME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countReadoutTime() throw(pvpException) {
  uns32 count;
  if (!availReadoutTime())
    throw pvpException("READOUT_TIME not available");
  if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_COUNT,&count))
    throw pvpException("Cannot get READOUT_TIME count");
  return count;
}

float pvpCamera::getReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_CURRENT,&x))
      throw pvpException("Cannot read READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

float pvpCamera::defaultReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

float pvpCamera::minReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_MIN,&x))
      throw pvpException("Cannot read min of READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

float pvpCamera::maxReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_MAX,&x))
      throw pvpException("Cannot read max of READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

void pvpCamera::setReadoutTime(float x) throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    flt64 y = x;
    if (!pl_set_param(camh,PARAM_READOUT_TIME,(void*)(&y)))
      throw pvpException("Cannot set READOUT_TIME");
  }
}

void pvpCamera::reportReadoutTime() throw(pvpException) {
  if (availReadoutTime()) {
    pvpAccess a = accessReadoutTime();
    printf("ReadoutTime: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getReadoutTime() <<"\n";
        ss << "  min value: " << minReadoutTime() <<"\n";
        ss << "  max value: " << maxReadoutTime() <<"\n";
        ss << "  default value: " << defaultReadoutTime() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countReadoutTime());
  } else {
    printf("ReadoutTime is not available.\n");
  }
}

bool pvpCamera::availClearCycles() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CLEAR_CYCLES availability");
  return avail;
}

pvpAccess pvpCamera::accessClearCycles() throw(pvpException) {
  uns16 access;
  if (!availClearCycles())
    throw pvpException("CLEAR_CYCLES not available");
  if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CLEAR_CYCLES accessibility");
  return pvpAccess(access);
}

int pvpCamera::countClearCycles() throw(pvpException) {
  uns32 count;
  if (!availClearCycles())
    throw pvpException("CLEAR_CYCLES not available");
  if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_COUNT,&count))
    throw pvpException("Cannot get CLEAR_CYCLES count");
  return count;
}

unsigned short pvpCamera::getClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

unsigned short pvpCamera::defaultClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

unsigned short pvpCamera::minClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

unsigned short pvpCamera::maxClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

void pvpCamera::setClearCycles(unsigned short x) throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_CLEAR_CYCLES,(void*)(&y)))
      throw pvpException("Cannot set CLEAR_CYCLES");
  }
}

void pvpCamera::reportClearCycles() throw(pvpException) {
  if (availClearCycles()) {
    pvpAccess a = accessClearCycles();
    printf("ClearCycles: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getClearCycles() <<"\n";
        ss << "  min value: " << minClearCycles() <<"\n";
        ss << "  max value: " << maxClearCycles() <<"\n";
        ss << "  default value: " << defaultClearCycles() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countClearCycles());
  } else {
    printf("ClearCycles is not available.\n");
  }
}

char const *pvpCamera::ClearMode::decode() const {
  switch (x) {
    case Never: return "Never";
    case PreExposure: return "PreExposure";
    case PreSequence: return "PreSequence";
    case PostSequence: return "PostSequence";
    case PrePostSequence: return "PrePostSequence";
    case PreExposurePostSeq: return "PreExposurePostSeq";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availClearMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CLEAR_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessClearMode() throw(pvpException) {
  uns16 access;
  if (!availClearMode())
    throw pvpException("CLEAR_MODE not available");
  if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CLEAR_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countClearMode() throw(pvpException) {
  uns32 count;
  if (!availClearMode())
    throw pvpException("CLEAR_MODE not available");
  if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get CLEAR_MODE count");
  return count;
}

pvpCamera::ClearMode pvpCamera::getClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

pvpCamera::ClearMode pvpCamera::defaultClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

pvpCamera::ClearMode pvpCamera::minClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

pvpCamera::ClearMode pvpCamera::maxClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

void pvpCamera::setClearMode(pvpCamera::ClearMode x) throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_CLEAR_MODE,(void*)(&y)))
      throw pvpException("Cannot set CLEAR_MODE");
  }
}

void pvpCamera::reportClearMode() throw(pvpException) {
  if (availClearMode()) {
    pvpAccess a = accessClearMode();
    printf("ClearMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getClearMode().decode() <<"\n";
        ss << "  min value: " << minClearMode().decode() <<"\n";
        ss << "  max value: " << maxClearMode().decode() <<"\n";
        ss << "  default value: " << defaultClearMode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countClearMode());
  } else {
    printf("ClearMode is not available.\n");
  }
}

bool pvpCamera::availFrameCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FRAME_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessFrameCapable() throw(pvpException) {
  uns16 access;
  if (!availFrameCapable())
    throw pvpException("FRAME_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FRAME_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFrameCapable() throw(pvpException) {
  uns32 count;
  if (!availFrameCapable())
    throw pvpException("FRAME_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get FRAME_CAPABLE count");
  return count;
}

bool pvpCamera::getFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::defaultFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::minFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::maxFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setFrameCapable(bool x) throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_FRAME_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set FRAME_CAPABLE");
  }
}

void pvpCamera::reportFrameCapable() throw(pvpException) {
  if (availFrameCapable()) {
    pvpAccess a = accessFrameCapable();
    printf("FrameCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFrameCapable() <<"\n";
        ss << "  min value: " << minFrameCapable() <<"\n";
        ss << "  max value: " << maxFrameCapable() <<"\n";
        ss << "  default value: " << defaultFrameCapable() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countFrameCapable());
  } else {
    printf("FrameCapable is not available.\n");
  }
}

char const *pvpCamera::Pmode::decode() const {
  switch (x) {
    case Normal: return "Normal";
    case Ft: return "Ft";
    case Mpp: return "Mpp";
    case FtMpp: return "FtMpp";
    case AltNormal: return "AltNormal";
    case AltFt: return "AltFt";
    case AltMpp: return "AltMpp";
    case AltFtMpp: return "AltFtMpp";
    case Interline: return "Interline";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availPmode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PMODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PMODE availability");
  return avail;
}

pvpAccess pvpCamera::accessPmode() throw(pvpException) {
  uns16 access;
  if (!availPmode())
    throw pvpException("PMODE not available");
  if (!pl_get_param(camh,PARAM_PMODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PMODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPmode() throw(pvpException) {
  uns32 count;
  if (!availPmode())
    throw pvpException("PMODE not available");
  if (!pl_get_param(camh,PARAM_PMODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PMODE count");
  return count;
}

pvpCamera::Pmode pvpCamera::getPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

pvpCamera::Pmode pvpCamera::defaultPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

pvpCamera::Pmode pvpCamera::minPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

pvpCamera::Pmode pvpCamera::maxPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

void pvpCamera::setPmode(pvpCamera::Pmode x) throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_PMODE,(void*)(&y)))
      throw pvpException("Cannot set PMODE");
  }
}

void pvpCamera::reportPmode() throw(pvpException) {
  if (availPmode()) {
    pvpAccess a = accessPmode();
    printf("Pmode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPmode().decode() <<"\n";
        ss << "  min value: " << minPmode().decode() <<"\n";
        ss << "  max value: " << maxPmode().decode() <<"\n";
        ss << "  default value: " << defaultPmode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPmode());
  } else {
    printf("Pmode is not available.\n");
  }
}

bool pvpCamera::availCcsStatus() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CCS_STATUS availability");
  return avail;
}

pvpAccess pvpCamera::accessCcsStatus() throw(pvpException) {
  uns16 access;
  if (!availCcsStatus())
    throw pvpException("CCS_STATUS not available");
  if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CCS_STATUS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCcsStatus() throw(pvpException) {
  uns32 count;
  if (!availCcsStatus())
    throw pvpException("CCS_STATUS not available");
  if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_COUNT,&count))
    throw pvpException("Cannot get CCS_STATUS count");
  return count;
}

short pvpCamera::getCcsStatus() throw(pvpException) {
  pvpAccess a = accessCcsStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CCS_STATUS");
    return x;
  } else {
    throw pvpException("CCS_STATUS not accessible for reading");
  }
}

short pvpCamera::defaultCcsStatus() throw(pvpException) {
  pvpAccess a = accessCcsStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CCS_STATUS");
    return x;
  } else {
    throw pvpException("CCS_STATUS not accessible for reading");
  }
}

short pvpCamera::minCcsStatus() throw(pvpException) {
  pvpAccess a = accessCcsStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CCS_STATUS");
    return x;
  } else {
    throw pvpException("CCS_STATUS not accessible for reading");
  }
}

short pvpCamera::maxCcsStatus() throw(pvpException) {
  pvpAccess a = accessCcsStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_CCS_STATUS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CCS_STATUS");
    return x;
  } else {
    throw pvpException("CCS_STATUS not accessible for reading");
  }
}

void pvpCamera::setCcsStatus(short x) throw(pvpException) {
  pvpAccess a = accessCcsStatus();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_CCS_STATUS,(void*)(&y)))
      throw pvpException("Cannot set CCS_STATUS");
  }
}

void pvpCamera::reportCcsStatus() throw(pvpException) {
  if (availCcsStatus()) {
    pvpAccess a = accessCcsStatus();
    printf("CcsStatus: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCcsStatus() <<"\n";
        ss << "  min value: " << minCcsStatus() <<"\n";
        ss << "  max value: " << maxCcsStatus() <<"\n";
        ss << "  default value: " << defaultCcsStatus() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countCcsStatus());
  } else {
    printf("CcsStatus is not available.\n");
  }
}

bool pvpCamera::availTemp() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_TEMP,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get TEMP availability");
  return avail;
}

pvpAccess pvpCamera::accessTemp() throw(pvpException) {
  uns16 access;
  if (!availTemp())
    throw pvpException("TEMP not available");
  if (!pl_get_param(camh,PARAM_TEMP,ATTR_ACCESS,&access))
    throw pvpException("Cannot get TEMP accessibility");
  return pvpAccess(access);
}

int pvpCamera::countTemp() throw(pvpException) {
  uns32 count;
  if (!availTemp())
    throw pvpException("TEMP not available");
  if (!pl_get_param(camh,PARAM_TEMP,ATTR_COUNT,&count))
    throw pvpException("Cannot get TEMP count");
  return count;
}

short pvpCamera::getTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_CURRENT,&x))
      throw pvpException("Cannot read TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

short pvpCamera::defaultTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

short pvpCamera::minTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_MIN,&x))
      throw pvpException("Cannot read min of TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

short pvpCamera::maxTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_MAX,&x))
      throw pvpException("Cannot read max of TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

void pvpCamera::setTemp(short x) throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_TEMP,(void*)(&y)))
      throw pvpException("Cannot set TEMP");
  }
}

void pvpCamera::reportTemp() throw(pvpException) {
  if (availTemp()) {
    pvpAccess a = accessTemp();
    printf("Temp: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getTemp() <<"\n";
        ss << "  min value: " << minTemp() <<"\n";
        ss << "  max value: " << maxTemp() <<"\n";
        ss << "  default value: " << defaultTemp() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countTemp());
  } else {
    printf("Temp is not available.\n");
  }
}

bool pvpCamera::availTempSetpoint() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get TEMP_SETPOINT availability");
  return avail;
}

pvpAccess pvpCamera::accessTempSetpoint() throw(pvpException) {
  uns16 access;
  if (!availTempSetpoint())
    throw pvpException("TEMP_SETPOINT not available");
  if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get TEMP_SETPOINT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countTempSetpoint() throw(pvpException) {
  uns32 count;
  if (!availTempSetpoint())
    throw pvpException("TEMP_SETPOINT not available");
  if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_COUNT,&count))
    throw pvpException("Cannot get TEMP_SETPOINT count");
  return count;
}

short pvpCamera::getTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

short pvpCamera::defaultTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

short pvpCamera::minTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

short pvpCamera::maxTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

void pvpCamera::setTempSetpoint(short x) throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_TEMP_SETPOINT,(void*)(&y)))
      throw pvpException("Cannot set TEMP_SETPOINT");
  }
}

void pvpCamera::reportTempSetpoint() throw(pvpException) {
  if (availTempSetpoint()) {
    pvpAccess a = accessTempSetpoint();
    printf("TempSetpoint: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getTempSetpoint() <<"\n";
        ss << "  min value: " << minTempSetpoint() <<"\n";
        ss << "  max value: " << maxTempSetpoint() <<"\n";
        ss << "  default value: " << defaultTempSetpoint() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countTempSetpoint());
  } else {
    printf("TempSetpoint is not available.\n");
  }
}

bool pvpCamera::availCamFwVersion() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CAM_FW_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessCamFwVersion() throw(pvpException) {
  uns16 access;
  if (!availCamFwVersion())
    throw pvpException("CAM_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CAM_FW_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCamFwVersion() throw(pvpException) {
  uns32 count;
  if (!availCamFwVersion())
    throw pvpException("CAM_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get CAM_FW_VERSION count");
  return count;
}

unsigned short pvpCamera::getCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

unsigned short pvpCamera::defaultCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

unsigned short pvpCamera::minCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

unsigned short pvpCamera::maxCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

void pvpCamera::setCamFwVersion(unsigned short x) throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_CAM_FW_VERSION,(void*)(&y)))
      throw pvpException("Cannot set CAM_FW_VERSION");
  }
}

void pvpCamera::reportCamFwVersion() throw(pvpException) {
  if (availCamFwVersion()) {
    pvpAccess a = accessCamFwVersion();
    printf("CamFwVersion: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCamFwVersion() <<"\n";
        ss << "  min value: " << minCamFwVersion() <<"\n";
        ss << "  max value: " << maxCamFwVersion() <<"\n";
        ss << "  default value: " << defaultCamFwVersion() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countCamFwVersion());
  } else {
    printf("CamFwVersion is not available.\n");
  }
}

bool pvpCamera::availHeadSerNumAlpha() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get HEAD_SER_NUM_ALPHA availability");
  return avail;
}

pvpAccess pvpCamera::accessHeadSerNumAlpha() throw(pvpException) {
  uns16 access;
  if (!availHeadSerNumAlpha())
    throw pvpException("HEAD_SER_NUM_ALPHA not available");
  if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_ACCESS,&access))
    throw pvpException("Cannot get HEAD_SER_NUM_ALPHA accessibility");
  return pvpAccess(access);
}

int pvpCamera::countHeadSerNumAlpha() throw(pvpException) {
  uns32 count;
  if (!availHeadSerNumAlpha())
    throw pvpException("HEAD_SER_NUM_ALPHA not available");
  if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_COUNT,&count))
    throw pvpException("Cannot get HEAD_SER_NUM_ALPHA count");
  return count;
}

QString pvpCamera::getHeadSerNumAlpha() throw(pvpException) {
  pvpAccess a = accessHeadSerNumAlpha();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char *x = memalloc<char>(countHeadSerNumAlpha(), "pvcam");
    if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_CURRENT,x))
      throw pvpException("Cannot read HEAD_SER_NUM_ALPHA");
    QString y = x;
    delete [] x;
    return y;
  } else {
    throw pvpException("HEAD_SER_NUM_ALPHA not accessible for reading");
  }
}

QString pvpCamera::defaultHeadSerNumAlpha() throw(pvpException) {
  pvpAccess a = accessHeadSerNumAlpha();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countHeadSerNumAlpha()];
    if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of HEAD_SER_NUM_ALPHA");
    return x;
  } else {
    throw pvpException("HEAD_SER_NUM_ALPHA not accessible for reading");
  }
}

QString pvpCamera::minHeadSerNumAlpha() throw(pvpException) {
    return "";
}

QString pvpCamera::maxHeadSerNumAlpha() throw(pvpException) {
    return "";
}

void pvpCamera::setHeadSerNumAlpha(QString x) throw(pvpException) {
  pvpAccess a = accessHeadSerNumAlpha();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_HEAD_SER_NUM_ALPHA,(void*)(x.toAscii().data())))
      throw pvpException("Cannot set HEAD_SER_NUM_ALPHA");
  }
}

void pvpCamera::reportHeadSerNumAlpha() throw(pvpException) {
  if (availHeadSerNumAlpha()) {
    pvpAccess a = accessHeadSerNumAlpha();
    printf("HeadSerNumAlpha: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getHeadSerNumAlpha() <<"\n";
        ss << "  min value: " << minHeadSerNumAlpha() <<"\n";
        ss << "  max value: " << maxHeadSerNumAlpha() <<"\n";
        ss << "  default value: " << defaultHeadSerNumAlpha() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countHeadSerNumAlpha());
  } else {
    printf("HeadSerNumAlpha is not available.\n");
  }
}

bool pvpCamera::availPciFwVersion() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PCI_FW_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessPciFwVersion() throw(pvpException) {
  uns16 access;
  if (!availPciFwVersion())
    throw pvpException("PCI_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PCI_FW_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPciFwVersion() throw(pvpException) {
  uns32 count;
  if (!availPciFwVersion())
    throw pvpException("PCI_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get PCI_FW_VERSION count");
  return count;
}

unsigned short pvpCamera::getPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

unsigned short pvpCamera::minPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

unsigned short pvpCamera::maxPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

void pvpCamera::setPciFwVersion(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PCI_FW_VERSION,(void*)(&y)))
      throw pvpException("Cannot set PCI_FW_VERSION");
  }
}

void pvpCamera::reportPciFwVersion() throw(pvpException) {
  if (availPciFwVersion()) {
    pvpAccess a = accessPciFwVersion();
    printf("PciFwVersion: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPciFwVersion() <<"\n";
        ss << "  min value: " << minPciFwVersion() <<"\n";
        ss << "  max value: " << maxPciFwVersion() <<"\n";
        ss << "  default value: " << defaultPciFwVersion() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPciFwVersion());
  } else {
    printf("PciFwVersion is not available.\n");
  }
}

bool pvpCamera::availCamFwFullVersion() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CAM_FW_FULL_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CAM_FW_FULL_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessCamFwFullVersion() throw(pvpException) {
  uns16 access;
  if (!availCamFwFullVersion())
    throw pvpException("CAM_FW_FULL_VERSION not available");
  if (!pl_get_param(camh,PARAM_CAM_FW_FULL_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CAM_FW_FULL_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCamFwFullVersion() throw(pvpException) {
  uns32 count;
  if (!availCamFwFullVersion())
    throw pvpException("CAM_FW_FULL_VERSION not available");
  if (!pl_get_param(camh,PARAM_CAM_FW_FULL_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get CAM_FW_FULL_VERSION count");
  return count;
}

QString pvpCamera::getCamFwFullVersion() throw(pvpException) {
  pvpAccess a = accessCamFwFullVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char *x = memalloc<char>(countCamFwFullVersion(), "pvcam");
    if (!pl_get_param(camh,PARAM_CAM_FW_FULL_VERSION,ATTR_CURRENT,x))
      throw pvpException("Cannot read CAM_FW_FULL_VERSION");
    QString y = x;
    delete [] x;
    return y;
  } else {
    throw pvpException("CAM_FW_FULL_VERSION not accessible for reading");
  }
}

QString pvpCamera::defaultCamFwFullVersion() throw(pvpException) {
  pvpAccess a = accessCamFwFullVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countCamFwFullVersion()];
    if (!pl_get_param(camh,PARAM_CAM_FW_FULL_VERSION,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of CAM_FW_FULL_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_FULL_VERSION not accessible for reading");
  }
}

QString pvpCamera::minCamFwFullVersion() throw(pvpException) {
    return "";
}

QString pvpCamera::maxCamFwFullVersion() throw(pvpException) {
    return "";
}

void pvpCamera::setCamFwFullVersion(QString x) throw(pvpException) {
  pvpAccess a = accessCamFwFullVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_CAM_FW_FULL_VERSION,(void*)(x.toAscii().data())))
      throw pvpException("Cannot set CAM_FW_FULL_VERSION");
  }
}

void pvpCamera::reportCamFwFullVersion() throw(pvpException) {
  if (availCamFwFullVersion()) {
    pvpAccess a = accessCamFwFullVersion();
    printf("CamFwFullVersion: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCamFwFullVersion() <<"\n";
        ss << "  min value: " << minCamFwFullVersion() <<"\n";
        ss << "  max value: " << maxCamFwFullVersion() <<"\n";
        ss << "  default value: " << defaultCamFwFullVersion() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countCamFwFullVersion());
  } else {
    printf("CamFwFullVersion is not available.\n");
  }
}

char const *pvpCamera::ExposureMode::decode() const {
  switch (x) {
    case TimedMode: return "TimedMode";
    case StrobedMode: return "StrobedMode";
    case BulbMode: return "BulbMode";
    case TriggerFirstMode: return "TriggerFirstMode";
    case FlashMode: return "FlashMode";
    case VariableTimedMode: return "VariableTimedMode";
    case IntStrobeMode: return "IntStrobeMode";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availExposureMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXPOSURE_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessExposureMode() throw(pvpException) {
  uns16 access;
  if (!availExposureMode())
    throw pvpException("EXPOSURE_MODE not available");
  if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXPOSURE_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExposureMode() throw(pvpException) {
  uns32 count;
  if (!availExposureMode())
    throw pvpException("EXPOSURE_MODE not available");
  if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXPOSURE_MODE count");
  return count;
}

pvpCamera::ExposureMode pvpCamera::getExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

pvpCamera::ExposureMode pvpCamera::defaultExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

pvpCamera::ExposureMode pvpCamera::minExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

pvpCamera::ExposureMode pvpCamera::maxExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

void pvpCamera::setExposureMode(pvpCamera::ExposureMode x) throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_EXPOSURE_MODE,(void*)(&y)))
      throw pvpException("Cannot set EXPOSURE_MODE");
  }
}

void pvpCamera::reportExposureMode() throw(pvpException) {
  if (availExposureMode()) {
    pvpAccess a = accessExposureMode();
    printf("ExposureMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExposureMode().decode() <<"\n";
        ss << "  min value: " << minExposureMode().decode() <<"\n";
        ss << "  max value: " << maxExposureMode().decode() <<"\n";
        ss << "  default value: " << defaultExposureMode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countExposureMode());
  } else {
    printf("ExposureMode is not available.\n");
  }
}

bool pvpCamera::availBitDepth() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BIT_DEPTH availability");
  return avail;
}

pvpAccess pvpCamera::accessBitDepth() throw(pvpException) {
  uns16 access;
  if (!availBitDepth())
    throw pvpException("BIT_DEPTH not available");
  if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BIT_DEPTH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBitDepth() throw(pvpException) {
  uns32 count;
  if (!availBitDepth())
    throw pvpException("BIT_DEPTH not available");
  if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_COUNT,&count))
    throw pvpException("Cannot get BIT_DEPTH count");
  return count;
}

short pvpCamera::getBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

short pvpCamera::defaultBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

short pvpCamera::minBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

short pvpCamera::maxBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

void pvpCamera::setBitDepth(short x) throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_BIT_DEPTH,(void*)(&y)))
      throw pvpException("Cannot set BIT_DEPTH");
  }
}

void pvpCamera::reportBitDepth() throw(pvpException) {
  if (availBitDepth()) {
    pvpAccess a = accessBitDepth();
    printf("BitDepth: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBitDepth() <<"\n";
        ss << "  min value: " << minBitDepth() <<"\n";
        ss << "  max value: " << maxBitDepth() <<"\n";
        ss << "  default value: " << defaultBitDepth() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countBitDepth());
  } else {
    printf("BitDepth is not available.\n");
  }
}

bool pvpCamera::availGainIndex() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessGainIndex() throw(pvpException) {
  uns16 access;
  if (!availGainIndex())
    throw pvpException("GAIN_INDEX not available");
  if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainIndex() throw(pvpException) {
  uns32 count;
  if (!availGainIndex())
    throw pvpException("GAIN_INDEX not available");
  if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_INDEX count");
  return count;
}

short pvpCamera::getGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

short pvpCamera::defaultGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

short pvpCamera::minGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

short pvpCamera::maxGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

void pvpCamera::setGainIndex(short x) throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_GAIN_INDEX,(void*)(&y)))
      throw pvpException("Cannot set GAIN_INDEX");
  }
}

void pvpCamera::reportGainIndex() throw(pvpException) {
  if (availGainIndex()) {
    pvpAccess a = accessGainIndex();
    printf("GainIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainIndex() <<"\n";
        ss << "  min value: " << minGainIndex() <<"\n";
        ss << "  max value: " << maxGainIndex() <<"\n";
        ss << "  default value: " << defaultGainIndex() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countGainIndex());
  } else {
    printf("GainIndex is not available.\n");
  }
}

bool pvpCamera::availSpdtabIndex() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SPDTAB_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessSpdtabIndex() throw(pvpException) {
  uns16 access;
  if (!availSpdtabIndex())
    throw pvpException("SPDTAB_INDEX not available");
  if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SPDTAB_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSpdtabIndex() throw(pvpException) {
  uns32 count;
  if (!availSpdtabIndex())
    throw pvpException("SPDTAB_INDEX not available");
  if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get SPDTAB_INDEX count");
  return count;
}

short pvpCamera::getSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

short pvpCamera::defaultSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

short pvpCamera::minSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

short pvpCamera::maxSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

void pvpCamera::setSpdtabIndex(short x) throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_SPDTAB_INDEX,(void*)(&y)))
      throw pvpException("Cannot set SPDTAB_INDEX");
  }
}

void pvpCamera::reportSpdtabIndex() throw(pvpException) {
  if (availSpdtabIndex()) {
    pvpAccess a = accessSpdtabIndex();
    printf("SpdtabIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSpdtabIndex() <<"\n";
        ss << "  min value: " << minSpdtabIndex() <<"\n";
        ss << "  max value: " << maxSpdtabIndex() <<"\n";
        ss << "  default value: " << defaultSpdtabIndex() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countSpdtabIndex());
  } else {
    printf("SpdtabIndex is not available.\n");
  }
}

char const *pvpCamera::ReadoutPort::decode() const {
  switch (x) {
    case Port1: return "Port1";
    case Port2: return "Port2";
    case PortLowNoise: return "PortLowNoise";
    case PortHighCap: return "PortHighCap";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availReadoutPort() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get READOUT_PORT availability");
  return avail;
}

pvpAccess pvpCamera::accessReadoutPort() throw(pvpException) {
  uns16 access;
  if (!availReadoutPort())
    throw pvpException("READOUT_PORT not available");
  if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get READOUT_PORT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countReadoutPort() throw(pvpException) {
  uns32 count;
  if (!availReadoutPort())
    throw pvpException("READOUT_PORT not available");
  if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_COUNT,&count))
    throw pvpException("Cannot get READOUT_PORT count");
  return count;
}

pvpCamera::ReadoutPort pvpCamera::getReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

pvpCamera::ReadoutPort pvpCamera::defaultReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

pvpCamera::ReadoutPort pvpCamera::minReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

pvpCamera::ReadoutPort pvpCamera::maxReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

void pvpCamera::setReadoutPort(pvpCamera::ReadoutPort x) throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_READOUT_PORT,(void*)(&y)))
      throw pvpException("Cannot set READOUT_PORT");
  }
}

void pvpCamera::reportReadoutPort() throw(pvpException) {
  if (availReadoutPort()) {
    pvpAccess a = accessReadoutPort();
    printf("ReadoutPort: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getReadoutPort().decode() <<"\n";
        ss << "  min value: " << minReadoutPort().decode() <<"\n";
        ss << "  max value: " << maxReadoutPort().decode() <<"\n";
        ss << "  default value: " << defaultReadoutPort().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countReadoutPort());
  } else {
    printf("ReadoutPort is not available.\n");
  }
}

bool pvpCamera::availPixTime() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_TIME availability");
  return avail;
}

pvpAccess pvpCamera::accessPixTime() throw(pvpException) {
  uns16 access;
  if (!availPixTime())
    throw pvpException("PIX_TIME not available");
  if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_TIME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixTime() throw(pvpException) {
  uns32 count;
  if (!availPixTime())
    throw pvpException("PIX_TIME not available");
  if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_TIME count");
  return count;
}

unsigned short pvpCamera::getPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

unsigned short pvpCamera::defaultPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

unsigned short pvpCamera::minPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

unsigned short pvpCamera::maxPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

void pvpCamera::setPixTime(unsigned short x) throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_PIX_TIME,(void*)(&y)))
      throw pvpException("Cannot set PIX_TIME");
  }
}

void pvpCamera::reportPixTime() throw(pvpException) {
  if (availPixTime()) {
    pvpAccess a = accessPixTime();
    printf("PixTime: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixTime() <<"\n";
        ss << "  min value: " << minPixTime() <<"\n";
        ss << "  max value: " << maxPixTime() <<"\n";
        ss << "  default value: " << defaultPixTime() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countPixTime());
  } else {
    printf("PixTime is not available.\n");
  }
}

bool pvpCamera::availShtrCloseDelay() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrCloseDelay() throw(pvpException) {
  uns16 access;
  if (!availShtrCloseDelay())
    throw pvpException("SHTR_CLOSE_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrCloseDelay() throw(pvpException) {
  uns32 count;
  if (!availShtrCloseDelay())
    throw pvpException("SHTR_CLOSE_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY count");
  return count;
}

unsigned short pvpCamera::getShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::defaultShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::minShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::maxShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

void pvpCamera::setShtrCloseDelay(unsigned short x) throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_CLOSE_DELAY,(void*)(&y)))
      throw pvpException("Cannot set SHTR_CLOSE_DELAY");
  }
}

void pvpCamera::reportShtrCloseDelay() throw(pvpException) {
  if (availShtrCloseDelay()) {
    pvpAccess a = accessShtrCloseDelay();
    printf("ShtrCloseDelay: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrCloseDelay() <<"\n";
        ss << "  min value: " << minShtrCloseDelay() <<"\n";
        ss << "  max value: " << maxShtrCloseDelay() <<"\n";
        ss << "  default value: " << defaultShtrCloseDelay() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countShtrCloseDelay());
  } else {
    printf("ShtrCloseDelay is not available.\n");
  }
}

bool pvpCamera::availShtrOpenDelay() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_OPEN_DELAY availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrOpenDelay() throw(pvpException) {
  uns16 access;
  if (!availShtrOpenDelay())
    throw pvpException("SHTR_OPEN_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_OPEN_DELAY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrOpenDelay() throw(pvpException) {
  uns32 count;
  if (!availShtrOpenDelay())
    throw pvpException("SHTR_OPEN_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_OPEN_DELAY count");
  return count;
}

unsigned short pvpCamera::getShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::defaultShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::minShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

unsigned short pvpCamera::maxShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

void pvpCamera::setShtrOpenDelay(unsigned short x) throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_OPEN_DELAY,(void*)(&y)))
      throw pvpException("Cannot set SHTR_OPEN_DELAY");
  }
}

void pvpCamera::reportShtrOpenDelay() throw(pvpException) {
  if (availShtrOpenDelay()) {
    pvpAccess a = accessShtrOpenDelay();
    printf("ShtrOpenDelay: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrOpenDelay() <<"\n";
        ss << "  min value: " << minShtrOpenDelay() <<"\n";
        ss << "  max value: " << maxShtrOpenDelay() <<"\n";
        ss << "  default value: " << defaultShtrOpenDelay() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countShtrOpenDelay());
  } else {
    printf("ShtrOpenDelay is not available.\n");
  }
}

char const *pvpCamera::ShtrOpenMode::decode() const {
  switch (x) {
    case Never: return "Never";
    case PreExposure: return "PreExposure";
    case PreSequence: return "PreSequence";
    case PreTrigger: return "PreTrigger";
    case NoChange: return "NoChange";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availShtrOpenMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_OPEN_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrOpenMode() throw(pvpException) {
  uns16 access;
  if (!availShtrOpenMode())
    throw pvpException("SHTR_OPEN_MODE not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_OPEN_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrOpenMode() throw(pvpException) {
  uns32 count;
  if (!availShtrOpenMode())
    throw pvpException("SHTR_OPEN_MODE not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_OPEN_MODE count");
  return count;
}

pvpCamera::ShtrOpenMode pvpCamera::getShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

pvpCamera::ShtrOpenMode pvpCamera::defaultShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

pvpCamera::ShtrOpenMode pvpCamera::minShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

pvpCamera::ShtrOpenMode pvpCamera::maxShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

void pvpCamera::setShtrOpenMode(pvpCamera::ShtrOpenMode x) throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_OPEN_MODE,(void*)(&y)))
      throw pvpException("Cannot set SHTR_OPEN_MODE");
  }
}

void pvpCamera::reportShtrOpenMode() throw(pvpException) {
  if (availShtrOpenMode()) {
    pvpAccess a = accessShtrOpenMode();
    printf("ShtrOpenMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrOpenMode().decode() <<"\n";
        ss << "  min value: " << minShtrOpenMode().decode() <<"\n";
        ss << "  max value: " << maxShtrOpenMode().decode() <<"\n";
        ss << "  default value: " << defaultShtrOpenMode().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countShtrOpenMode());
  } else {
    printf("ShtrOpenMode is not available.\n");
  }
}

char const *pvpCamera::ShtrStatus::decode() const {
  switch (x) {
    case Fault: return "Fault";
    case Opening: return "Opening";
    case Open: return "Open";
    case Closing: return "Closing";
    case Closed: return "Closed";
    case Unknown: return "Unknown";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availShtrStatus() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_STATUS availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrStatus() throw(pvpException) {
  uns16 access;
  if (!availShtrStatus())
    throw pvpException("SHTR_STATUS not available");
  if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_STATUS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrStatus() throw(pvpException) {
  uns32 count;
  if (!availShtrStatus())
    throw pvpException("SHTR_STATUS not available");
  if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_STATUS count");
  return count;
}

pvpCamera::ShtrStatus pvpCamera::getShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

pvpCamera::ShtrStatus pvpCamera::defaultShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

pvpCamera::ShtrStatus pvpCamera::minShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

pvpCamera::ShtrStatus pvpCamera::maxShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

void pvpCamera::setShtrStatus(pvpCamera::ShtrStatus x) throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_STATUS,(void*)(&y)))
      throw pvpException("Cannot set SHTR_STATUS");
  }
}

void pvpCamera::reportShtrStatus() throw(pvpException) {
  if (availShtrStatus()) {
    pvpAccess a = accessShtrStatus();
    printf("ShtrStatus: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrStatus().decode() <<"\n";
        ss << "  min value: " << minShtrStatus().decode() <<"\n";
        ss << "  max value: " << maxShtrStatus().decode() <<"\n";
        ss << "  default value: " << defaultShtrStatus().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countShtrStatus());
  } else {
    printf("ShtrStatus is not available.\n");
  }
}

char const *pvpCamera::ShtrCloseDelayUnit::decode() const {
  switch (x) {
    case Usec: return "Usec";
    case Msec: return "Msec";
    case Sec: return "Sec";
    case Minute: return "Minute";
    case Hour: return "Hour";
    case Nsec: return "Nsec";
    case Psec: return "Psec";
    case Fsec: return "Fsec";
    case Day: return "Day";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availShtrCloseDelayUnit() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY_UNIT availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrCloseDelayUnit() throw(pvpException) {
  uns16 access;
  if (!availShtrCloseDelayUnit())
    throw pvpException("SHTR_CLOSE_DELAY_UNIT not available");
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY_UNIT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrCloseDelayUnit() throw(pvpException) {
  uns32 count;
  if (!availShtrCloseDelayUnit())
    throw pvpException("SHTR_CLOSE_DELAY_UNIT not available");
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY_UNIT count");
  return count;
}

pvpCamera::ShtrCloseDelayUnit pvpCamera::getShtrCloseDelayUnit() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelayUnit();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_CLOSE_DELAY_UNIT");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY_UNIT not accessible for reading");
  }
}

pvpCamera::ShtrCloseDelayUnit pvpCamera::defaultShtrCloseDelayUnit() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelayUnit();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_CLOSE_DELAY_UNIT");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY_UNIT not accessible for reading");
  }
}

pvpCamera::ShtrCloseDelayUnit pvpCamera::minShtrCloseDelayUnit() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelayUnit();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_CLOSE_DELAY_UNIT");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY_UNIT not accessible for reading");
  }
}

pvpCamera::ShtrCloseDelayUnit pvpCamera::maxShtrCloseDelayUnit() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelayUnit();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_CLOSE_DELAY_UNIT");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY_UNIT not accessible for reading");
  }
}

void pvpCamera::setShtrCloseDelayUnit(pvpCamera::ShtrCloseDelayUnit x) throw(pvpException) {
  pvpAccess a = accessShtrCloseDelayUnit();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_CLOSE_DELAY_UNIT,(void*)(&y)))
      throw pvpException("Cannot set SHTR_CLOSE_DELAY_UNIT");
  }
}

void pvpCamera::reportShtrCloseDelayUnit() throw(pvpException) {
  if (availShtrCloseDelayUnit()) {
    pvpAccess a = accessShtrCloseDelayUnit();
    printf("ShtrCloseDelayUnit: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrCloseDelayUnit().decode() <<"\n";
        ss << "  min value: " << minShtrCloseDelayUnit().decode() <<"\n";
        ss << "  max value: " << maxShtrCloseDelayUnit().decode() <<"\n";
        ss << "  default value: " << defaultShtrCloseDelayUnit().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countShtrCloseDelayUnit());
  } else {
    printf("ShtrCloseDelayUnit is not available.\n");
  }
}

bool pvpCamera::availIoAddr() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_ADDR availability");
  return avail;
}

pvpAccess pvpCamera::accessIoAddr() throw(pvpException) {
  uns16 access;
  if (!availIoAddr())
    throw pvpException("IO_ADDR not available");
  if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_ADDR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoAddr() throw(pvpException) {
  uns32 count;
  if (!availIoAddr())
    throw pvpException("IO_ADDR not available");
  if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_ADDR count");
  return count;
}

unsigned short pvpCamera::getIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

unsigned short pvpCamera::defaultIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

unsigned short pvpCamera::minIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

unsigned short pvpCamera::maxIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

void pvpCamera::setIoAddr(unsigned short x) throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_IO_ADDR,(void*)(&y)))
      throw pvpException("Cannot set IO_ADDR");
  }
}

void pvpCamera::reportIoAddr() throw(pvpException) {
  if (availIoAddr()) {
    pvpAccess a = accessIoAddr();
    printf("IoAddr: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoAddr() <<"\n";
        ss << "  min value: " << minIoAddr() <<"\n";
        ss << "  max value: " << maxIoAddr() <<"\n";
        ss << "  default value: " << defaultIoAddr() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countIoAddr());
  } else {
    printf("IoAddr is not available.\n");
  }
}

char const *pvpCamera::IoType::decode() const {
  switch (x) {
    case Ttl: return "Ttl";
    case Dac: return "Dac";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availIoType() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_TYPE availability");
  return avail;
}

pvpAccess pvpCamera::accessIoType() throw(pvpException) {
  uns16 access;
  if (!availIoType())
    throw pvpException("IO_TYPE not available");
  if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_TYPE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoType() throw(pvpException) {
  uns32 count;
  if (!availIoType())
    throw pvpException("IO_TYPE not available");
  if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_TYPE count");
  return count;
}

pvpCamera::IoType pvpCamera::getIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

pvpCamera::IoType pvpCamera::defaultIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

pvpCamera::IoType pvpCamera::minIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

pvpCamera::IoType pvpCamera::maxIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

void pvpCamera::setIoType(pvpCamera::IoType x) throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_IO_TYPE,(void*)(&y)))
      throw pvpException("Cannot set IO_TYPE");
  }
}

void pvpCamera::reportIoType() throw(pvpException) {
  if (availIoType()) {
    pvpAccess a = accessIoType();
    printf("IoType: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoType().decode() <<"\n";
        ss << "  min value: " << minIoType().decode() <<"\n";
        ss << "  max value: " << maxIoType().decode() <<"\n";
        ss << "  default value: " << defaultIoType().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countIoType());
  } else {
    printf("IoType is not available.\n");
  }
}

char const *pvpCamera::IoDirection::decode() const {
  switch (x) {
    case Input: return "Input";
    case Output: return "Output";
    case InputOutput: return "InputOutput";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availIoDirection() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_DIRECTION availability");
  return avail;
}

pvpAccess pvpCamera::accessIoDirection() throw(pvpException) {
  uns16 access;
  if (!availIoDirection())
    throw pvpException("IO_DIRECTION not available");
  if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_DIRECTION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoDirection() throw(pvpException) {
  uns32 count;
  if (!availIoDirection())
    throw pvpException("IO_DIRECTION not available");
  if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_DIRECTION count");
  return count;
}

pvpCamera::IoDirection pvpCamera::getIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

pvpCamera::IoDirection pvpCamera::defaultIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

pvpCamera::IoDirection pvpCamera::minIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

pvpCamera::IoDirection pvpCamera::maxIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

void pvpCamera::setIoDirection(pvpCamera::IoDirection x) throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_IO_DIRECTION,(void*)(&y)))
      throw pvpException("Cannot set IO_DIRECTION");
  }
}

void pvpCamera::reportIoDirection() throw(pvpException) {
  if (availIoDirection()) {
    pvpAccess a = accessIoDirection();
    printf("IoDirection: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoDirection().decode() <<"\n";
        ss << "  min value: " << minIoDirection().decode() <<"\n";
        ss << "  max value: " << maxIoDirection().decode() <<"\n";
        ss << "  default value: " << defaultIoDirection().decode() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countIoDirection());
  } else {
    printf("IoDirection is not available.\n");
  }
}

bool pvpCamera::availIoState() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_STATE availability");
  return avail;
}

pvpAccess pvpCamera::accessIoState() throw(pvpException) {
  uns16 access;
  if (!availIoState())
    throw pvpException("IO_STATE not available");
  if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_STATE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoState() throw(pvpException) {
  uns32 count;
  if (!availIoState())
    throw pvpException("IO_STATE not available");
  if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_STATE count");
  return count;
}

float pvpCamera::getIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

float pvpCamera::defaultIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

float pvpCamera::minIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

float pvpCamera::maxIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    flt64 x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

void pvpCamera::setIoState(float x) throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    flt64 y = x;
    if (!pl_set_param(camh,PARAM_IO_STATE,(void*)(&y)))
      throw pvpException("Cannot set IO_STATE");
  }
}

void pvpCamera::reportIoState() throw(pvpException) {
  if (availIoState()) {
    pvpAccess a = accessIoState();
    printf("IoState: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoState() <<"\n";
        ss << "  min value: " << minIoState() <<"\n";
        ss << "  max value: " << maxIoState() <<"\n";
        ss << "  default value: " << defaultIoState() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countIoState());
  } else {
    printf("IoState is not available.\n");
  }
}

bool pvpCamera::availIoBitdepth() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_BITDEPTH availability");
  return avail;
}

pvpAccess pvpCamera::accessIoBitdepth() throw(pvpException) {
  uns16 access;
  if (!availIoBitdepth())
    throw pvpException("IO_BITDEPTH not available");
  if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_BITDEPTH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoBitdepth() throw(pvpException) {
  uns32 count;
  if (!availIoBitdepth())
    throw pvpException("IO_BITDEPTH not available");
  if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_BITDEPTH count");
  return count;
}

unsigned short pvpCamera::getIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

unsigned short pvpCamera::defaultIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

unsigned short pvpCamera::minIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

unsigned short pvpCamera::maxIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

void pvpCamera::setIoBitdepth(unsigned short x) throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_IO_BITDEPTH,(void*)(&y)))
      throw pvpException("Cannot set IO_BITDEPTH");
  }
}

void pvpCamera::reportIoBitdepth() throw(pvpException) {
  if (availIoBitdepth()) {
    pvpAccess a = accessIoBitdepth();
    printf("IoBitdepth: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoBitdepth() <<"\n";
        ss << "  min value: " << minIoBitdepth() <<"\n";
        ss << "  max value: " << maxIoBitdepth() <<"\n";
        ss << "  default value: " << defaultIoBitdepth() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countIoBitdepth());
  } else {
    printf("IoBitdepth is not available.\n");
  }
}

bool pvpCamera::availGainMultFactor() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_MULT_FACTOR availability");
  return avail;
}

pvpAccess pvpCamera::accessGainMultFactor() throw(pvpException) {
  uns16 access;
  if (!availGainMultFactor())
    throw pvpException("GAIN_MULT_FACTOR not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_MULT_FACTOR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainMultFactor() throw(pvpException) {
  uns32 count;
  if (!availGainMultFactor())
    throw pvpException("GAIN_MULT_FACTOR not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_MULT_FACTOR count");
  return count;
}

unsigned short pvpCamera::getGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

unsigned short pvpCamera::defaultGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

unsigned short pvpCamera::minGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

unsigned short pvpCamera::maxGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

void pvpCamera::setGainMultFactor(unsigned short x) throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_GAIN_MULT_FACTOR,(void*)(&y)))
      throw pvpException("Cannot set GAIN_MULT_FACTOR");
  }
}

void pvpCamera::reportGainMultFactor() throw(pvpException) {
  if (availGainMultFactor()) {
    pvpAccess a = accessGainMultFactor();
    printf("GainMultFactor: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainMultFactor() <<"\n";
        ss << "  min value: " << minGainMultFactor() <<"\n";
        ss << "  max value: " << maxGainMultFactor() <<"\n";
        ss << "  default value: " << defaultGainMultFactor() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countGainMultFactor());
  } else {
    printf("GainMultFactor is not available.\n");
  }
}

bool pvpCamera::availGainMultEnable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_MULT_ENABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessGainMultEnable() throw(pvpException) {
  uns16 access;
  if (!availGainMultEnable())
    throw pvpException("GAIN_MULT_ENABLE not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_MULT_ENABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainMultEnable() throw(pvpException) {
  uns32 count;
  if (!availGainMultEnable())
    throw pvpException("GAIN_MULT_ENABLE not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_MULT_ENABLE count");
  return count;
}

bool pvpCamera::getGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

bool pvpCamera::defaultGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

bool pvpCamera::minGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

bool pvpCamera::maxGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    boolean x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

void pvpCamera::setGainMultEnable(bool x) throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    boolean y = x;
    if (!pl_set_param(camh,PARAM_GAIN_MULT_ENABLE,(void*)(&y)))
      throw pvpException("Cannot set GAIN_MULT_ENABLE");
  }
}

void pvpCamera::reportGainMultEnable() throw(pvpException) {
  if (availGainMultEnable()) {
    pvpAccess a = accessGainMultEnable();
    printf("GainMultEnable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainMultEnable() <<"\n";
        ss << "  min value: " << minGainMultEnable() <<"\n";
        ss << "  max value: " << maxGainMultEnable() <<"\n";
        ss << "  default value: " << defaultGainMultEnable() <<"\n";
      }
      printf("%s",s.toAscii().data());
    }
    printf("  count: %i\n",countGainMultEnable());
  } else {
    printf("GainMultEnable is not available.\n");
  }
}

void pvpCamera::reportClass2() throw(pvpException) {
  reportMinBlock();
  reportNumMinBlock();
  reportSkipAtOnceBlk();
  reportNumOfStripsPerClr();
  reportContClears();
  reportAntiBlooming();
  reportLogicOutput();
  reportEdgeTrigger();
  reportIntensifierGain();
  reportShtrGateMode();
  reportAdcOffset();
  reportChipName();
  reportCoolingMode();
  reportPreampDelay();
  reportPreflash();
  reportColorMode();
  reportMppCapable();
  reportPreampOffControl();
  reportSerialNum();
  reportPremask();
  reportPrescan();
  reportPostmask();
  reportPostscan();
  reportPixParDist();
  reportPixParSize();
  reportPixSerDist();
  reportPixSerSize();
  reportSummingWell();
  reportFwellCapacity();
  reportParSize();
  reportSerSize();
  reportAccumCapable();
  reportFlashDwnldCapable();
  reportControllerAlive();
  reportReadoutTime();
  reportClearCycles();
  reportClearMode();
  reportFrameCapable();
  reportPmode();
  reportCcsStatus();
  reportTemp();
  reportTempSetpoint();
  reportCamFwVersion();
  reportHeadSerNumAlpha();
  reportPciFwVersion();
  reportCamFwFullVersion();
  reportExposureMode();
  reportBitDepth();
  reportGainIndex();
  reportSpdtabIndex();
  reportReadoutPort();
  reportPixTime();
  reportShtrCloseDelay();
  reportShtrOpenDelay();
  reportShtrOpenMode();
  reportShtrStatus();
  reportShtrCloseDelayUnit();
  reportIoAddr();
  reportIoType();
  reportIoDirection();
  reportIoState();
  reportIoBitdepth();
  reportGainMultFactor();
  reportGainMultEnable();
}


// pvp_Class2.cpp - generated by pvcam2param.pl. Do not Edit.

#include <pvp/pvpCamera.h>
#include <QTextStream>
#include <pvp/dwpvcam.h>

bool pvpCamera::availAdcOffset() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ADC_OFFSET availability");
  return avail;
}

pvpAccess pvpCamera::accessAdcOffset() throw(pvpException) {
  uns16 access;
  if (!availAdcOffset())
    throw pvpException("ADC_OFFSET not available");
  if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ADC_OFFSET accessibility");
  return pvpAccess(access);
}

int pvpCamera::countAdcOffset() throw(pvpException) {
  uns32 count;
  if (!availAdcOffset())
    throw pvpException("ADC_OFFSET not available");
  if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_COUNT,&count))
    throw pvpException("Cannot get ADC_OFFSET count");
  return count;
}

int16_t pvpCamera::getAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

int16_t pvpCamera::defaultAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

int16_t pvpCamera::minAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

int16_t pvpCamera::maxAdcOffset() throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_ADC_OFFSET,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ADC_OFFSET");
    return x;
  } else {
    throw pvpException("ADC_OFFSET not accessible for reading");
  }
}

void pvpCamera::setAdcOffset(int16_t x) throw(pvpException) {
  pvpAccess a = accessAdcOffset();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_ADC_OFFSET,(void*)(&y)))
      throw pvpException("Cannot set ADC_OFFSET");
  }
}

void pvpCamera::reportAdcOffset() throw(pvpException) {
  if (availAdcOffset()) {
    pvpAccess a = accessAdcOffset();
    printf("AdcOffset: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getAdcOffset() <<"\n";
        ss << "  min value: " << minAdcOffset() <<"\n";
        ss << "  max value: " << maxAdcOffset() <<"\n";
        ss << "  default value: " << defaultAdcOffset() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countAdcOffset());
  } else {
    printf("AdcOffset is not available.\n");
  }
}

bool pvpCamera::availChipName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CHIP_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessChipName() throw(pvpException) {
  uns16 access;
  if (!availChipName())
    throw pvpException("CHIP_NAME not available");
  if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CHIP_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countChipName() throw(pvpException) {
  uns32 count;
  if (!availChipName())
    throw pvpException("CHIP_NAME not available");
  if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get CHIP_NAME count");
  return count;
}

QString pvpCamera::getChipName() throw(pvpException) {
  pvpAccess a = accessChipName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countChipName(), 0);
    if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read CHIP_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("CHIP_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultChipName() throw(pvpException) {
  pvpAccess a = accessChipName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countChipName()];
    if (!pl_get_param(camh,PARAM_CHIP_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of CHIP_NAME");
    return x;
  } else {
    throw pvpException("CHIP_NAME not accessible for reading");
  }
}

QString pvpCamera::minChipName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxChipName() throw(pvpException) {
    return "";
}

void pvpCamera::setChipName(QString x) throw(pvpException) {
  pvpAccess a = accessChipName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_CHIP_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set CHIP_NAME");
  }
}

void pvpCamera::reportChipName() throw(pvpException) {
  if (availChipName()) {
    pvpAccess a = accessChipName();
    printf("ChipName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getChipName() <<"\n";
        ss << "  min value: " << minChipName() <<"\n";
        ss << "  max value: " << maxChipName() <<"\n";
        ss << "  default value: " << defaultChipName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countChipName());
  } else {
    printf("ChipName is not available.\n");
  }
}

bool pvpCamera::availSystemName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SYSTEM_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SYSTEM_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessSystemName() throw(pvpException) {
  uns16 access;
  if (!availSystemName())
    throw pvpException("SYSTEM_NAME not available");
  if (!pl_get_param(camh,PARAM_SYSTEM_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SYSTEM_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSystemName() throw(pvpException) {
  uns32 count;
  if (!availSystemName())
    throw pvpException("SYSTEM_NAME not available");
  if (!pl_get_param(camh,PARAM_SYSTEM_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get SYSTEM_NAME count");
  return count;
}

QString pvpCamera::getSystemName() throw(pvpException) {
  pvpAccess a = accessSystemName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countSystemName(), 0);
    if (!pl_get_param(camh,PARAM_SYSTEM_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read SYSTEM_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("SYSTEM_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultSystemName() throw(pvpException) {
  pvpAccess a = accessSystemName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countSystemName()];
    if (!pl_get_param(camh,PARAM_SYSTEM_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of SYSTEM_NAME");
    return x;
  } else {
    throw pvpException("SYSTEM_NAME not accessible for reading");
  }
}

QString pvpCamera::minSystemName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxSystemName() throw(pvpException) {
    return "";
}

void pvpCamera::setSystemName(QString x) throw(pvpException) {
  pvpAccess a = accessSystemName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_SYSTEM_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set SYSTEM_NAME");
  }
}

void pvpCamera::reportSystemName() throw(pvpException) {
  if (availSystemName()) {
    pvpAccess a = accessSystemName();
    printf("SystemName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSystemName() <<"\n";
        ss << "  min value: " << minSystemName() <<"\n";
        ss << "  max value: " << maxSystemName() <<"\n";
        ss << "  default value: " << defaultSystemName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSystemName());
  } else {
    printf("SystemName is not available.\n");
  }
}

bool pvpCamera::availVendorName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_VENDOR_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get VENDOR_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessVendorName() throw(pvpException) {
  uns16 access;
  if (!availVendorName())
    throw pvpException("VENDOR_NAME not available");
  if (!pl_get_param(camh,PARAM_VENDOR_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get VENDOR_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countVendorName() throw(pvpException) {
  uns32 count;
  if (!availVendorName())
    throw pvpException("VENDOR_NAME not available");
  if (!pl_get_param(camh,PARAM_VENDOR_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get VENDOR_NAME count");
  return count;
}

QString pvpCamera::getVendorName() throw(pvpException) {
  pvpAccess a = accessVendorName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countVendorName(), 0);
    if (!pl_get_param(camh,PARAM_VENDOR_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read VENDOR_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("VENDOR_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultVendorName() throw(pvpException) {
  pvpAccess a = accessVendorName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countVendorName()];
    if (!pl_get_param(camh,PARAM_VENDOR_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of VENDOR_NAME");
    return x;
  } else {
    throw pvpException("VENDOR_NAME not accessible for reading");
  }
}

QString pvpCamera::minVendorName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxVendorName() throw(pvpException) {
    return "";
}

void pvpCamera::setVendorName(QString x) throw(pvpException) {
  pvpAccess a = accessVendorName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_VENDOR_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set VENDOR_NAME");
  }
}

void pvpCamera::reportVendorName() throw(pvpException) {
  if (availVendorName()) {
    pvpAccess a = accessVendorName();
    printf("VendorName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getVendorName() <<"\n";
        ss << "  min value: " << minVendorName() <<"\n";
        ss << "  max value: " << maxVendorName() <<"\n";
        ss << "  default value: " << defaultVendorName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countVendorName());
  } else {
    printf("VendorName is not available.\n");
  }
}

bool pvpCamera::availProductName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PRODUCT_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PRODUCT_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessProductName() throw(pvpException) {
  uns16 access;
  if (!availProductName())
    throw pvpException("PRODUCT_NAME not available");
  if (!pl_get_param(camh,PARAM_PRODUCT_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PRODUCT_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countProductName() throw(pvpException) {
  uns32 count;
  if (!availProductName())
    throw pvpException("PRODUCT_NAME not available");
  if (!pl_get_param(camh,PARAM_PRODUCT_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get PRODUCT_NAME count");
  return count;
}

QString pvpCamera::getProductName() throw(pvpException) {
  pvpAccess a = accessProductName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countProductName(), 0);
    if (!pl_get_param(camh,PARAM_PRODUCT_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read PRODUCT_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("PRODUCT_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultProductName() throw(pvpException) {
  pvpAccess a = accessProductName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countProductName()];
    if (!pl_get_param(camh,PARAM_PRODUCT_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of PRODUCT_NAME");
    return x;
  } else {
    throw pvpException("PRODUCT_NAME not accessible for reading");
  }
}

QString pvpCamera::minProductName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxProductName() throw(pvpException) {
    return "";
}

void pvpCamera::setProductName(QString x) throw(pvpException) {
  pvpAccess a = accessProductName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_PRODUCT_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set PRODUCT_NAME");
  }
}

void pvpCamera::reportProductName() throw(pvpException) {
  if (availProductName()) {
    pvpAccess a = accessProductName();
    printf("ProductName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getProductName() <<"\n";
        ss << "  min value: " << minProductName() <<"\n";
        ss << "  max value: " << maxProductName() <<"\n";
        ss << "  default value: " << defaultProductName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countProductName());
  } else {
    printf("ProductName is not available.\n");
  }
}

bool pvpCamera::availCameraPartNumber() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CAMERA_PART_NUMBER,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CAMERA_PART_NUMBER availability");
  return avail;
}

pvpAccess pvpCamera::accessCameraPartNumber() throw(pvpException) {
  uns16 access;
  if (!availCameraPartNumber())
    throw pvpException("CAMERA_PART_NUMBER not available");
  if (!pl_get_param(camh,PARAM_CAMERA_PART_NUMBER,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CAMERA_PART_NUMBER accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCameraPartNumber() throw(pvpException) {
  uns32 count;
  if (!availCameraPartNumber())
    throw pvpException("CAMERA_PART_NUMBER not available");
  if (!pl_get_param(camh,PARAM_CAMERA_PART_NUMBER,ATTR_COUNT,&count))
    throw pvpException("Cannot get CAMERA_PART_NUMBER count");
  return count;
}

QString pvpCamera::getCameraPartNumber() throw(pvpException) {
  pvpAccess a = accessCameraPartNumber();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countCameraPartNumber(), 0);
    if (!pl_get_param(camh,PARAM_CAMERA_PART_NUMBER,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read CAMERA_PART_NUMBER");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("CAMERA_PART_NUMBER not accessible for reading");
  }
}

QString pvpCamera::defaultCameraPartNumber() throw(pvpException) {
  pvpAccess a = accessCameraPartNumber();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countCameraPartNumber()];
    if (!pl_get_param(camh,PARAM_CAMERA_PART_NUMBER,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of CAMERA_PART_NUMBER");
    return x;
  } else {
    throw pvpException("CAMERA_PART_NUMBER not accessible for reading");
  }
}

QString pvpCamera::minCameraPartNumber() throw(pvpException) {
    return "";
}

QString pvpCamera::maxCameraPartNumber() throw(pvpException) {
    return "";
}

void pvpCamera::setCameraPartNumber(QString x) throw(pvpException) {
  pvpAccess a = accessCameraPartNumber();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_CAMERA_PART_NUMBER,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set CAMERA_PART_NUMBER");
  }
}

void pvpCamera::reportCameraPartNumber() throw(pvpException) {
  if (availCameraPartNumber()) {
    pvpAccess a = accessCameraPartNumber();
    printf("CameraPartNumber: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCameraPartNumber() <<"\n";
        ss << "  min value: " << minCameraPartNumber() <<"\n";
        ss << "  max value: " << maxCameraPartNumber() <<"\n";
        ss << "  default value: " << defaultCameraPartNumber() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCameraPartNumber());
  } else {
    printf("CameraPartNumber is not available.\n");
  }
}

char const *pvpCamera::CoolingMode::decode() const {
  switch (x) {
    case NormalCool: return "NormalCool";
    case CryoCool: return "CryoCool";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availCoolingMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get COOLING_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessCoolingMode() throw(pvpException) {
  uns16 access;
  if (!availCoolingMode())
    throw pvpException("COOLING_MODE not available");
  if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get COOLING_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCoolingMode() throw(pvpException) {
  uns32 count;
  if (!availCoolingMode())
    throw pvpException("COOLING_MODE not available");
  if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get COOLING_MODE count");
  return count;
}

pvpCamera::CoolingMode pvpCamera::getCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

pvpCamera::CoolingMode pvpCamera::defaultCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

pvpCamera::CoolingMode pvpCamera::minCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

pvpCamera::CoolingMode pvpCamera::maxCoolingMode() throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COOLING_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of COOLING_MODE");
    return x;
  } else {
    throw pvpException("COOLING_MODE not accessible for reading");
  }
}

void pvpCamera::setCoolingMode(pvpCamera::CoolingMode x) throw(pvpException) {
  pvpAccess a = accessCoolingMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_COOLING_MODE,(void*)(&y)))
      throw pvpException("Cannot set COOLING_MODE");
  }
}

void pvpCamera::reportCoolingMode() throw(pvpException) {
  if (availCoolingMode()) {
    pvpAccess a = accessCoolingMode();
    printf("CoolingMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCoolingMode().decode() <<"\n";
        ss << "  min value: " << minCoolingMode().decode() <<"\n";
        ss << "  max value: " << maxCoolingMode().decode() <<"\n";
        ss << "  default value: " << defaultCoolingMode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCoolingMode());
  } else {
    printf("CoolingMode is not available.\n");
  }
}

bool pvpCamera::availPreampDelay() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREAMP_DELAY availability");
  return avail;
}

pvpAccess pvpCamera::accessPreampDelay() throw(pvpException) {
  uns16 access;
  if (!availPreampDelay())
    throw pvpException("PREAMP_DELAY not available");
  if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREAMP_DELAY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPreampDelay() throw(pvpException) {
  uns32 count;
  if (!availPreampDelay())
    throw pvpException("PREAMP_DELAY not available");
  if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREAMP_DELAY count");
  return count;
}

uint16_t pvpCamera::getPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::minPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::maxPreampDelay() throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_DELAY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREAMP_DELAY");
    return x;
  } else {
    throw pvpException("PREAMP_DELAY not accessible for reading");
  }
}

void pvpCamera::setPreampDelay(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPreampDelay();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PREAMP_DELAY,(void*)(&y)))
      throw pvpException("Cannot set PREAMP_DELAY");
  }
}

void pvpCamera::reportPreampDelay() throw(pvpException) {
  if (availPreampDelay()) {
    pvpAccess a = accessPreampDelay();
    printf("PreampDelay: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPreampDelay() <<"\n";
        ss << "  min value: " << minPreampDelay() <<"\n";
        ss << "  max value: " << maxPreampDelay() <<"\n";
        ss << "  default value: " << defaultPreampDelay() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPreampDelay());
  } else {
    printf("PreampDelay is not available.\n");
  }
}

char const *pvpCamera::ColorMode::decode() const {
  switch (x) {
    case None: return "None";
    case Reserved: return "Reserved";
    case Rggb: return "Rggb";
    case Grbg: return "Grbg";
    case Gbrg: return "Gbrg";
    case Bggr: return "Bggr";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availColorMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get COLOR_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessColorMode() throw(pvpException) {
  uns16 access;
  if (!availColorMode())
    throw pvpException("COLOR_MODE not available");
  if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get COLOR_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countColorMode() throw(pvpException) {
  uns32 count;
  if (!availColorMode())
    throw pvpException("COLOR_MODE not available");
  if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get COLOR_MODE count");
  return count;
}

pvpCamera::ColorMode pvpCamera::getColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

pvpCamera::ColorMode pvpCamera::defaultColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

pvpCamera::ColorMode pvpCamera::minColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

pvpCamera::ColorMode pvpCamera::maxColorMode() throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_COLOR_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of COLOR_MODE");
    return x;
  } else {
    throw pvpException("COLOR_MODE not accessible for reading");
  }
}

void pvpCamera::setColorMode(pvpCamera::ColorMode x) throw(pvpException) {
  pvpAccess a = accessColorMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_COLOR_MODE,(void*)(&y)))
      throw pvpException("Cannot set COLOR_MODE");
  }
}

void pvpCamera::reportColorMode() throw(pvpException) {
  if (availColorMode()) {
    pvpAccess a = accessColorMode();
    printf("ColorMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getColorMode().decode() <<"\n";
        ss << "  min value: " << minColorMode().decode() <<"\n";
        ss << "  max value: " << maxColorMode().decode() <<"\n";
        ss << "  default value: " << defaultColorMode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countColorMode());
  } else {
    printf("ColorMode is not available.\n");
  }
}

char const *pvpCamera::MppCapable::decode() const {
  switch (x) {
    case Unknown: return "Unknown";
    case AlwaysOff: return "AlwaysOff";
    case AlwaysOn: return "AlwaysOn";
    case Selectable: return "Selectable";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availMppCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get MPP_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessMppCapable() throw(pvpException) {
  uns16 access;
  if (!availMppCapable())
    throw pvpException("MPP_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get MPP_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countMppCapable() throw(pvpException) {
  uns32 count;
  if (!availMppCapable())
    throw pvpException("MPP_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get MPP_CAPABLE count");
  return count;
}

pvpCamera::MppCapable pvpCamera::getMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

pvpCamera::MppCapable pvpCamera::defaultMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

pvpCamera::MppCapable pvpCamera::minMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

pvpCamera::MppCapable pvpCamera::maxMppCapable() throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_MPP_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of MPP_CAPABLE");
    return x;
  } else {
    throw pvpException("MPP_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setMppCapable(pvpCamera::MppCapable x) throw(pvpException) {
  pvpAccess a = accessMppCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_MPP_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set MPP_CAPABLE");
  }
}

void pvpCamera::reportMppCapable() throw(pvpException) {
  if (availMppCapable()) {
    pvpAccess a = accessMppCapable();
    printf("MppCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getMppCapable().decode() <<"\n";
        ss << "  min value: " << minMppCapable().decode() <<"\n";
        ss << "  max value: " << maxMppCapable().decode() <<"\n";
        ss << "  default value: " << defaultMppCapable().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countMppCapable());
  } else {
    printf("MppCapable is not available.\n");
  }
}

bool pvpCamera::availPreampOffControl() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREAMP_OFF_CONTROL availability");
  return avail;
}

pvpAccess pvpCamera::accessPreampOffControl() throw(pvpException) {
  uns16 access;
  if (!availPreampOffControl())
    throw pvpException("PREAMP_OFF_CONTROL not available");
  if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREAMP_OFF_CONTROL accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPreampOffControl() throw(pvpException) {
  uns32 count;
  if (!availPreampOffControl())
    throw pvpException("PREAMP_OFF_CONTROL not available");
  if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREAMP_OFF_CONTROL count");
  return count;
}

uint32_t pvpCamera::getPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

uint32_t pvpCamera::defaultPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

uint32_t pvpCamera::minPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

uint32_t pvpCamera::maxPreampOffControl() throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PREAMP_OFF_CONTROL,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREAMP_OFF_CONTROL");
    return x;
  } else {
    throw pvpException("PREAMP_OFF_CONTROL not accessible for reading");
  }
}

void pvpCamera::setPreampOffControl(uint32_t x) throw(pvpException) {
  pvpAccess a = accessPreampOffControl();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint32_t y = x;
    if (!pl_set_param(camh,PARAM_PREAMP_OFF_CONTROL,(void*)(&y)))
      throw pvpException("Cannot set PREAMP_OFF_CONTROL");
  }
}

void pvpCamera::reportPreampOffControl() throw(pvpException) {
  if (availPreampOffControl()) {
    pvpAccess a = accessPreampOffControl();
    printf("PreampOffControl: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPreampOffControl() <<"\n";
        ss << "  min value: " << minPreampOffControl() <<"\n";
        ss << "  max value: " << maxPreampOffControl() <<"\n";
        ss << "  default value: " << defaultPreampOffControl() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPreampOffControl());
  } else {
    printf("PreampOffControl is not available.\n");
  }
}

bool pvpCamera::availPremask() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PREMASK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PREMASK availability");
  return avail;
}

pvpAccess pvpCamera::accessPremask() throw(pvpException) {
  uns16 access;
  if (!availPremask())
    throw pvpException("PREMASK not available");
  if (!pl_get_param(camh,PARAM_PREMASK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PREMASK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPremask() throw(pvpException) {
  uns32 count;
  if (!availPremask())
    throw pvpException("PREMASK not available");
  if (!pl_get_param(camh,PARAM_PREMASK,ATTR_COUNT,&count))
    throw pvpException("Cannot get PREMASK count");
  return count;
}

uint16_t pvpCamera::getPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

uint16_t pvpCamera::minPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

uint16_t pvpCamera::maxPremask() throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PREMASK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PREMASK");
    return x;
  } else {
    throw pvpException("PREMASK not accessible for reading");
  }
}

void pvpCamera::setPremask(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPremask();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PREMASK,(void*)(&y)))
      throw pvpException("Cannot set PREMASK");
  }
}

void pvpCamera::reportPremask() throw(pvpException) {
  if (availPremask()) {
    pvpAccess a = accessPremask();
    printf("Premask: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPremask() <<"\n";
        ss << "  min value: " << minPremask() <<"\n";
        ss << "  max value: " << maxPremask() <<"\n";
        ss << "  default value: " << defaultPremask() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPremask());
  } else {
    printf("Premask is not available.\n");
  }
}

bool pvpCamera::availPrescan() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PRESCAN availability");
  return avail;
}

pvpAccess pvpCamera::accessPrescan() throw(pvpException) {
  uns16 access;
  if (!availPrescan())
    throw pvpException("PRESCAN not available");
  if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PRESCAN accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPrescan() throw(pvpException) {
  uns32 count;
  if (!availPrescan())
    throw pvpException("PRESCAN not available");
  if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_COUNT,&count))
    throw pvpException("Cannot get PRESCAN count");
  return count;
}

uint16_t pvpCamera::getPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

uint16_t pvpCamera::minPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

uint16_t pvpCamera::maxPrescan() throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PRESCAN,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PRESCAN");
    return x;
  } else {
    throw pvpException("PRESCAN not accessible for reading");
  }
}

void pvpCamera::setPrescan(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPrescan();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PRESCAN,(void*)(&y)))
      throw pvpException("Cannot set PRESCAN");
  }
}

void pvpCamera::reportPrescan() throw(pvpException) {
  if (availPrescan()) {
    pvpAccess a = accessPrescan();
    printf("Prescan: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPrescan() <<"\n";
        ss << "  min value: " << minPrescan() <<"\n";
        ss << "  max value: " << maxPrescan() <<"\n";
        ss << "  default value: " << defaultPrescan() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPrescan());
  } else {
    printf("Prescan is not available.\n");
  }
}

bool pvpCamera::availPostmask() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get POSTMASK availability");
  return avail;
}

pvpAccess pvpCamera::accessPostmask() throw(pvpException) {
  uns16 access;
  if (!availPostmask())
    throw pvpException("POSTMASK not available");
  if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_ACCESS,&access))
    throw pvpException("Cannot get POSTMASK accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPostmask() throw(pvpException) {
  uns32 count;
  if (!availPostmask())
    throw pvpException("POSTMASK not available");
  if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_COUNT,&count))
    throw pvpException("Cannot get POSTMASK count");
  return count;
}

uint16_t pvpCamera::getPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_CURRENT,&x))
      throw pvpException("Cannot read POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

uint16_t pvpCamera::minPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_MIN,&x))
      throw pvpException("Cannot read min of POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

uint16_t pvpCamera::maxPostmask() throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTMASK,ATTR_MAX,&x))
      throw pvpException("Cannot read max of POSTMASK");
    return x;
  } else {
    throw pvpException("POSTMASK not accessible for reading");
  }
}

void pvpCamera::setPostmask(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPostmask();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_POSTMASK,(void*)(&y)))
      throw pvpException("Cannot set POSTMASK");
  }
}

void pvpCamera::reportPostmask() throw(pvpException) {
  if (availPostmask()) {
    pvpAccess a = accessPostmask();
    printf("Postmask: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPostmask() <<"\n";
        ss << "  min value: " << minPostmask() <<"\n";
        ss << "  max value: " << maxPostmask() <<"\n";
        ss << "  default value: " << defaultPostmask() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPostmask());
  } else {
    printf("Postmask is not available.\n");
  }
}

bool pvpCamera::availPostscan() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get POSTSCAN availability");
  return avail;
}

pvpAccess pvpCamera::accessPostscan() throw(pvpException) {
  uns16 access;
  if (!availPostscan())
    throw pvpException("POSTSCAN not available");
  if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_ACCESS,&access))
    throw pvpException("Cannot get POSTSCAN accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPostscan() throw(pvpException) {
  uns32 count;
  if (!availPostscan())
    throw pvpException("POSTSCAN not available");
  if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_COUNT,&count))
    throw pvpException("Cannot get POSTSCAN count");
  return count;
}

uint16_t pvpCamera::getPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_CURRENT,&x))
      throw pvpException("Cannot read POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

uint16_t pvpCamera::minPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_MIN,&x))
      throw pvpException("Cannot read min of POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

uint16_t pvpCamera::maxPostscan() throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_POSTSCAN,ATTR_MAX,&x))
      throw pvpException("Cannot read max of POSTSCAN");
    return x;
  } else {
    throw pvpException("POSTSCAN not accessible for reading");
  }
}

void pvpCamera::setPostscan(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPostscan();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_POSTSCAN,(void*)(&y)))
      throw pvpException("Cannot set POSTSCAN");
  }
}

void pvpCamera::reportPostscan() throw(pvpException) {
  if (availPostscan()) {
    pvpAccess a = accessPostscan();
    printf("Postscan: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPostscan() <<"\n";
        ss << "  min value: " << minPostscan() <<"\n";
        ss << "  max value: " << maxPostscan() <<"\n";
        ss << "  default value: " << defaultPostscan() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPostscan());
  } else {
    printf("Postscan is not available.\n");
  }
}

bool pvpCamera::availPixParDist() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_PAR_DIST availability");
  return avail;
}

pvpAccess pvpCamera::accessPixParDist() throw(pvpException) {
  uns16 access;
  if (!availPixParDist())
    throw pvpException("PIX_PAR_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_PAR_DIST accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixParDist() throw(pvpException) {
  uns32 count;
  if (!availPixParDist())
    throw pvpException("PIX_PAR_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_PAR_DIST count");
  return count;
}

uint16_t pvpCamera::getPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

uint16_t pvpCamera::minPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

uint16_t pvpCamera::maxPixParDist() throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_DIST,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_PAR_DIST");
    return x;
  } else {
    throw pvpException("PIX_PAR_DIST not accessible for reading");
  }
}

void pvpCamera::setPixParDist(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPixParDist();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PIX_PAR_DIST,(void*)(&y)))
      throw pvpException("Cannot set PIX_PAR_DIST");
  }
}

void pvpCamera::reportPixParDist() throw(pvpException) {
  if (availPixParDist()) {
    pvpAccess a = accessPixParDist();
    printf("PixParDist: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixParDist() <<"\n";
        ss << "  min value: " << minPixParDist() <<"\n";
        ss << "  max value: " << maxPixParDist() <<"\n";
        ss << "  default value: " << defaultPixParDist() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPixParDist());
  } else {
    printf("PixParDist is not available.\n");
  }
}

bool pvpCamera::availPixParSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_PAR_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessPixParSize() throw(pvpException) {
  uns16 access;
  if (!availPixParSize())
    throw pvpException("PIX_PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_PAR_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixParSize() throw(pvpException) {
  uns32 count;
  if (!availPixParSize())
    throw pvpException("PIX_PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_PAR_SIZE count");
  return count;
}

uint16_t pvpCamera::getPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::minPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::maxPixParSize() throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_PAR_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_PAR_SIZE");
    return x;
  } else {
    throw pvpException("PIX_PAR_SIZE not accessible for reading");
  }
}

void pvpCamera::setPixParSize(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPixParSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PIX_PAR_SIZE,(void*)(&y)))
      throw pvpException("Cannot set PIX_PAR_SIZE");
  }
}

void pvpCamera::reportPixParSize() throw(pvpException) {
  if (availPixParSize()) {
    pvpAccess a = accessPixParSize();
    printf("PixParSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixParSize() <<"\n";
        ss << "  min value: " << minPixParSize() <<"\n";
        ss << "  max value: " << maxPixParSize() <<"\n";
        ss << "  default value: " << defaultPixParSize() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPixParSize());
  } else {
    printf("PixParSize is not available.\n");
  }
}

bool pvpCamera::availPixSerDist() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_SER_DIST availability");
  return avail;
}

pvpAccess pvpCamera::accessPixSerDist() throw(pvpException) {
  uns16 access;
  if (!availPixSerDist())
    throw pvpException("PIX_SER_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_SER_DIST accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixSerDist() throw(pvpException) {
  uns32 count;
  if (!availPixSerDist())
    throw pvpException("PIX_SER_DIST not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_SER_DIST count");
  return count;
}

uint16_t pvpCamera::getPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

uint16_t pvpCamera::minPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

uint16_t pvpCamera::maxPixSerDist() throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_DIST,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_SER_DIST");
    return x;
  } else {
    throw pvpException("PIX_SER_DIST not accessible for reading");
  }
}

void pvpCamera::setPixSerDist(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPixSerDist();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PIX_SER_DIST,(void*)(&y)))
      throw pvpException("Cannot set PIX_SER_DIST");
  }
}

void pvpCamera::reportPixSerDist() throw(pvpException) {
  if (availPixSerDist()) {
    pvpAccess a = accessPixSerDist();
    printf("PixSerDist: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixSerDist() <<"\n";
        ss << "  min value: " << minPixSerDist() <<"\n";
        ss << "  max value: " << maxPixSerDist() <<"\n";
        ss << "  default value: " << defaultPixSerDist() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPixSerDist());
  } else {
    printf("PixSerDist is not available.\n");
  }
}

bool pvpCamera::availPixSerSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_SER_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessPixSerSize() throw(pvpException) {
  uns16 access;
  if (!availPixSerSize())
    throw pvpException("PIX_SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_SER_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixSerSize() throw(pvpException) {
  uns32 count;
  if (!availPixSerSize())
    throw pvpException("PIX_SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_SER_SIZE count");
  return count;
}

uint16_t pvpCamera::getPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::minPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::maxPixSerSize() throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_SER_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_SER_SIZE");
    return x;
  } else {
    throw pvpException("PIX_SER_SIZE not accessible for reading");
  }
}

void pvpCamera::setPixSerSize(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPixSerSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PIX_SER_SIZE,(void*)(&y)))
      throw pvpException("Cannot set PIX_SER_SIZE");
  }
}

void pvpCamera::reportPixSerSize() throw(pvpException) {
  if (availPixSerSize()) {
    pvpAccess a = accessPixSerSize();
    printf("PixSerSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixSerSize() <<"\n";
        ss << "  min value: " << minPixSerSize() <<"\n";
        ss << "  max value: " << maxPixSerSize() <<"\n";
        ss << "  default value: " << defaultPixSerSize() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPixSerSize());
  } else {
    printf("PixSerSize is not available.\n");
  }
}

bool pvpCamera::availSummingWell() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SUMMING_WELL availability");
  return avail;
}

pvpAccess pvpCamera::accessSummingWell() throw(pvpException) {
  uns16 access;
  if (!availSummingWell())
    throw pvpException("SUMMING_WELL not available");
  if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SUMMING_WELL accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSummingWell() throw(pvpException) {
  uns32 count;
  if (!availSummingWell())
    throw pvpException("SUMMING_WELL not available");
  if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_COUNT,&count))
    throw pvpException("Cannot get SUMMING_WELL count");
  return count;
}

bool pvpCamera::getSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

bool pvpCamera::defaultSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

bool pvpCamera::minSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

bool pvpCamera::maxSummingWell() throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SUMMING_WELL,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SUMMING_WELL");
    return x;
  } else {
    throw pvpException("SUMMING_WELL not accessible for reading");
  }
}

void pvpCamera::setSummingWell(bool x) throw(pvpException) {
  pvpAccess a = accessSummingWell();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    bool y = x;
    if (!pl_set_param(camh,PARAM_SUMMING_WELL,(void*)(&y)))
      throw pvpException("Cannot set SUMMING_WELL");
  }
}

void pvpCamera::reportSummingWell() throw(pvpException) {
  if (availSummingWell()) {
    pvpAccess a = accessSummingWell();
    printf("SummingWell: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSummingWell() <<"\n";
        ss << "  min value: " << minSummingWell() <<"\n";
        ss << "  max value: " << maxSummingWell() <<"\n";
        ss << "  default value: " << defaultSummingWell() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSummingWell());
  } else {
    printf("SummingWell is not available.\n");
  }
}

bool pvpCamera::availFwellCapacity() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FWELL_CAPACITY availability");
  return avail;
}

pvpAccess pvpCamera::accessFwellCapacity() throw(pvpException) {
  uns16 access;
  if (!availFwellCapacity())
    throw pvpException("FWELL_CAPACITY not available");
  if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FWELL_CAPACITY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFwellCapacity() throw(pvpException) {
  uns32 count;
  if (!availFwellCapacity())
    throw pvpException("FWELL_CAPACITY not available");
  if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_COUNT,&count))
    throw pvpException("Cannot get FWELL_CAPACITY count");
  return count;
}

uint32_t pvpCamera::getFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

uint32_t pvpCamera::defaultFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

uint32_t pvpCamera::minFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

uint32_t pvpCamera::maxFwellCapacity() throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_FWELL_CAPACITY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FWELL_CAPACITY");
    return x;
  } else {
    throw pvpException("FWELL_CAPACITY not accessible for reading");
  }
}

void pvpCamera::setFwellCapacity(uint32_t x) throw(pvpException) {
  pvpAccess a = accessFwellCapacity();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint32_t y = x;
    if (!pl_set_param(camh,PARAM_FWELL_CAPACITY,(void*)(&y)))
      throw pvpException("Cannot set FWELL_CAPACITY");
  }
}

void pvpCamera::reportFwellCapacity() throw(pvpException) {
  if (availFwellCapacity()) {
    pvpAccess a = accessFwellCapacity();
    printf("FwellCapacity: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFwellCapacity() <<"\n";
        ss << "  min value: " << minFwellCapacity() <<"\n";
        ss << "  max value: " << maxFwellCapacity() <<"\n";
        ss << "  default value: " << defaultFwellCapacity() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countFwellCapacity());
  } else {
    printf("FwellCapacity is not available.\n");
  }
}

bool pvpCamera::availParSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PAR_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessParSize() throw(pvpException) {
  uns16 access;
  if (!availParSize())
    throw pvpException("PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PAR_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countParSize() throw(pvpException) {
  uns32 count;
  if (!availParSize())
    throw pvpException("PAR_SIZE not available");
  if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PAR_SIZE count");
  return count;
}

uint16_t pvpCamera::getParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::defaultParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::minParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::maxParSize() throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PAR_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PAR_SIZE");
    return x;
  } else {
    throw pvpException("PAR_SIZE not accessible for reading");
  }
}

void pvpCamera::setParSize(uint16_t x) throw(pvpException) {
  pvpAccess a = accessParSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PAR_SIZE,(void*)(&y)))
      throw pvpException("Cannot set PAR_SIZE");
  }
}

void pvpCamera::reportParSize() throw(pvpException) {
  if (availParSize()) {
    pvpAccess a = accessParSize();
    printf("ParSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getParSize() <<"\n";
        ss << "  min value: " << minParSize() <<"\n";
        ss << "  max value: " << maxParSize() <<"\n";
        ss << "  default value: " << defaultParSize() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countParSize());
  } else {
    printf("ParSize is not available.\n");
  }
}

bool pvpCamera::availSerSize() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SER_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessSerSize() throw(pvpException) {
  uns16 access;
  if (!availSerSize())
    throw pvpException("SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SER_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSerSize() throw(pvpException) {
  uns32 count;
  if (!availSerSize())
    throw pvpException("SER_SIZE not available");
  if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get SER_SIZE count");
  return count;
}

uint16_t pvpCamera::getSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::defaultSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::minSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

uint16_t pvpCamera::maxSerSize() throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SER_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SER_SIZE");
    return x;
  } else {
    throw pvpException("SER_SIZE not accessible for reading");
  }
}

void pvpCamera::setSerSize(uint16_t x) throw(pvpException) {
  pvpAccess a = accessSerSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_SER_SIZE,(void*)(&y)))
      throw pvpException("Cannot set SER_SIZE");
  }
}

void pvpCamera::reportSerSize() throw(pvpException) {
  if (availSerSize()) {
    pvpAccess a = accessSerSize();
    printf("SerSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSerSize() <<"\n";
        ss << "  min value: " << minSerSize() <<"\n";
        ss << "  max value: " << maxSerSize() <<"\n";
        ss << "  default value: " << defaultSerSize() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSerSize());
  } else {
    printf("SerSize is not available.\n");
  }
}

bool pvpCamera::availAccumCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ACCUM_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessAccumCapable() throw(pvpException) {
  uns16 access;
  if (!availAccumCapable())
    throw pvpException("ACCUM_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ACCUM_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countAccumCapable() throw(pvpException) {
  uns32 count;
  if (!availAccumCapable())
    throw pvpException("ACCUM_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get ACCUM_CAPABLE count");
  return count;
}

bool pvpCamera::getAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::defaultAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::minAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::maxAccumCapable() throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_ACCUM_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ACCUM_CAPABLE");
    return x;
  } else {
    throw pvpException("ACCUM_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setAccumCapable(bool x) throw(pvpException) {
  pvpAccess a = accessAccumCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    bool y = x;
    if (!pl_set_param(camh,PARAM_ACCUM_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set ACCUM_CAPABLE");
  }
}

void pvpCamera::reportAccumCapable() throw(pvpException) {
  if (availAccumCapable()) {
    pvpAccess a = accessAccumCapable();
    printf("AccumCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getAccumCapable() <<"\n";
        ss << "  min value: " << minAccumCapable() <<"\n";
        ss << "  max value: " << maxAccumCapable() <<"\n";
        ss << "  default value: " << defaultAccumCapable() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countAccumCapable());
  } else {
    printf("AccumCapable is not available.\n");
  }
}

bool pvpCamera::availFlashDwnldCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FLASH_DWNLD_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessFlashDwnldCapable() throw(pvpException) {
  uns16 access;
  if (!availFlashDwnldCapable())
    throw pvpException("FLASH_DWNLD_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FLASH_DWNLD_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFlashDwnldCapable() throw(pvpException) {
  uns32 count;
  if (!availFlashDwnldCapable())
    throw pvpException("FLASH_DWNLD_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get FLASH_DWNLD_CAPABLE count");
  return count;
}

bool pvpCamera::getFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::defaultFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::minFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::maxFlashDwnldCapable() throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FLASH_DWNLD_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FLASH_DWNLD_CAPABLE");
    return x;
  } else {
    throw pvpException("FLASH_DWNLD_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setFlashDwnldCapable(bool x) throw(pvpException) {
  pvpAccess a = accessFlashDwnldCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    bool y = x;
    if (!pl_set_param(camh,PARAM_FLASH_DWNLD_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set FLASH_DWNLD_CAPABLE");
  }
}

void pvpCamera::reportFlashDwnldCapable() throw(pvpException) {
  if (availFlashDwnldCapable()) {
    pvpAccess a = accessFlashDwnldCapable();
    printf("FlashDwnldCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFlashDwnldCapable() <<"\n";
        ss << "  min value: " << minFlashDwnldCapable() <<"\n";
        ss << "  max value: " << maxFlashDwnldCapable() <<"\n";
        ss << "  default value: " << defaultFlashDwnldCapable() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countFlashDwnldCapable());
  } else {
    printf("FlashDwnldCapable is not available.\n");
  }
}

bool pvpCamera::availReadoutTime() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get READOUT_TIME availability");
  return avail;
}

pvpAccess pvpCamera::accessReadoutTime() throw(pvpException) {
  uns16 access;
  if (!availReadoutTime())
    throw pvpException("READOUT_TIME not available");
  if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get READOUT_TIME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countReadoutTime() throw(pvpException) {
  uns32 count;
  if (!availReadoutTime())
    throw pvpException("READOUT_TIME not available");
  if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_COUNT,&count))
    throw pvpException("Cannot get READOUT_TIME count");
  return count;
}

double pvpCamera::getReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_CURRENT,&x))
      throw pvpException("Cannot read READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

double pvpCamera::defaultReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

double pvpCamera::minReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_MIN,&x))
      throw pvpException("Cannot read min of READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

double pvpCamera::maxReadoutTime() throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_READOUT_TIME,ATTR_MAX,&x))
      throw pvpException("Cannot read max of READOUT_TIME");
    return x;
  } else {
    throw pvpException("READOUT_TIME not accessible for reading");
  }
}

void pvpCamera::setReadoutTime(double x) throw(pvpException) {
  pvpAccess a = accessReadoutTime();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    double y = x;
    if (!pl_set_param(camh,PARAM_READOUT_TIME,(void*)(&y)))
      throw pvpException("Cannot set READOUT_TIME");
  }
}

void pvpCamera::reportReadoutTime() throw(pvpException) {
  if (availReadoutTime()) {
    pvpAccess a = accessReadoutTime();
    printf("ReadoutTime: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getReadoutTime() <<"\n";
        ss << "  min value: " << minReadoutTime() <<"\n";
        ss << "  max value: " << maxReadoutTime() <<"\n";
        ss << "  default value: " << defaultReadoutTime() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countReadoutTime());
  } else {
    printf("ReadoutTime is not available.\n");
  }
}

bool pvpCamera::availClearCycles() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CLEAR_CYCLES availability");
  return avail;
}

pvpAccess pvpCamera::accessClearCycles() throw(pvpException) {
  uns16 access;
  if (!availClearCycles())
    throw pvpException("CLEAR_CYCLES not available");
  if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CLEAR_CYCLES accessibility");
  return pvpAccess(access);
}

int pvpCamera::countClearCycles() throw(pvpException) {
  uns32 count;
  if (!availClearCycles())
    throw pvpException("CLEAR_CYCLES not available");
  if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_COUNT,&count))
    throw pvpException("Cannot get CLEAR_CYCLES count");
  return count;
}

uint16_t pvpCamera::getClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

uint16_t pvpCamera::defaultClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

uint16_t pvpCamera::minClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

uint16_t pvpCamera::maxClearCycles() throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CLEAR_CYCLES,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CLEAR_CYCLES");
    return x;
  } else {
    throw pvpException("CLEAR_CYCLES not accessible for reading");
  }
}

void pvpCamera::setClearCycles(uint16_t x) throw(pvpException) {
  pvpAccess a = accessClearCycles();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_CLEAR_CYCLES,(void*)(&y)))
      throw pvpException("Cannot set CLEAR_CYCLES");
  }
}

void pvpCamera::reportClearCycles() throw(pvpException) {
  if (availClearCycles()) {
    pvpAccess a = accessClearCycles();
    printf("ClearCycles: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getClearCycles() <<"\n";
        ss << "  min value: " << minClearCycles() <<"\n";
        ss << "  max value: " << maxClearCycles() <<"\n";
        ss << "  default value: " << defaultClearCycles() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countClearCycles());
  } else {
    printf("ClearCycles is not available.\n");
  }
}

char const *pvpCamera::ClearMode::decode() const {
  switch (x) {
    case ClearNever: return "ClearNever";
    case ClearPreExposure: return "ClearPreExposure";
    case ClearPreSequence: return "ClearPreSequence";
    case ClearPostSequence: return "ClearPostSequence";
    case ClearPrePostSequence: return "ClearPrePostSequence";
    case ClearPreExposurePostSeq: return "ClearPreExposurePostSeq";
    case MaxClearMode: return "MaxClearMode";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availClearMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CLEAR_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessClearMode() throw(pvpException) {
  uns16 access;
  if (!availClearMode())
    throw pvpException("CLEAR_MODE not available");
  if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CLEAR_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countClearMode() throw(pvpException) {
  uns32 count;
  if (!availClearMode())
    throw pvpException("CLEAR_MODE not available");
  if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get CLEAR_MODE count");
  return count;
}

pvpCamera::ClearMode pvpCamera::getClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

pvpCamera::ClearMode pvpCamera::defaultClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

pvpCamera::ClearMode pvpCamera::minClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

pvpCamera::ClearMode pvpCamera::maxClearMode() throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_CLEAR_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CLEAR_MODE");
    return x;
  } else {
    throw pvpException("CLEAR_MODE not accessible for reading");
  }
}

void pvpCamera::setClearMode(pvpCamera::ClearMode x) throw(pvpException) {
  pvpAccess a = accessClearMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_CLEAR_MODE,(void*)(&y)))
      throw pvpException("Cannot set CLEAR_MODE");
  }
}

void pvpCamera::reportClearMode() throw(pvpException) {
  if (availClearMode()) {
    pvpAccess a = accessClearMode();
    printf("ClearMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getClearMode().decode() <<"\n";
        ss << "  min value: " << minClearMode().decode() <<"\n";
        ss << "  max value: " << maxClearMode().decode() <<"\n";
        ss << "  default value: " << defaultClearMode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countClearMode());
  } else {
    printf("ClearMode is not available.\n");
  }
}

bool pvpCamera::availFrameCapable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FRAME_CAPABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessFrameCapable() throw(pvpException) {
  uns16 access;
  if (!availFrameCapable())
    throw pvpException("FRAME_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FRAME_CAPABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFrameCapable() throw(pvpException) {
  uns32 count;
  if (!availFrameCapable())
    throw pvpException("FRAME_CAPABLE not available");
  if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get FRAME_CAPABLE count");
  return count;
}

bool pvpCamera::getFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::defaultFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::minFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

bool pvpCamera::maxFrameCapable() throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_FRAME_CAPABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FRAME_CAPABLE");
    return x;
  } else {
    throw pvpException("FRAME_CAPABLE not accessible for reading");
  }
}

void pvpCamera::setFrameCapable(bool x) throw(pvpException) {
  pvpAccess a = accessFrameCapable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    bool y = x;
    if (!pl_set_param(camh,PARAM_FRAME_CAPABLE,(void*)(&y)))
      throw pvpException("Cannot set FRAME_CAPABLE");
  }
}

void pvpCamera::reportFrameCapable() throw(pvpException) {
  if (availFrameCapable()) {
    pvpAccess a = accessFrameCapable();
    printf("FrameCapable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFrameCapable() <<"\n";
        ss << "  min value: " << minFrameCapable() <<"\n";
        ss << "  max value: " << maxFrameCapable() <<"\n";
        ss << "  default value: " << defaultFrameCapable() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countFrameCapable());
  } else {
    printf("FrameCapable is not available.\n");
  }
}

char const *pvpCamera::Pmode::decode() const {
  switch (x) {
    case Normal: return "Normal";
    case Ft: return "Ft";
    case Mpp: return "Mpp";
    case FtMpp: return "FtMpp";
    case AltNormal: return "AltNormal";
    case AltFt: return "AltFt";
    case AltMpp: return "AltMpp";
    case AltFtMpp: return "AltFtMpp";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availPmode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PMODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PMODE availability");
  return avail;
}

pvpAccess pvpCamera::accessPmode() throw(pvpException) {
  uns16 access;
  if (!availPmode())
    throw pvpException("PMODE not available");
  if (!pl_get_param(camh,PARAM_PMODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PMODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPmode() throw(pvpException) {
  uns32 count;
  if (!availPmode())
    throw pvpException("PMODE not available");
  if (!pl_get_param(camh,PARAM_PMODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get PMODE count");
  return count;
}

pvpCamera::Pmode pvpCamera::getPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

pvpCamera::Pmode pvpCamera::defaultPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

pvpCamera::Pmode pvpCamera::minPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

pvpCamera::Pmode pvpCamera::maxPmode() throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_PMODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PMODE");
    return x;
  } else {
    throw pvpException("PMODE not accessible for reading");
  }
}

void pvpCamera::setPmode(pvpCamera::Pmode x) throw(pvpException) {
  pvpAccess a = accessPmode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_PMODE,(void*)(&y)))
      throw pvpException("Cannot set PMODE");
  }
}

void pvpCamera::reportPmode() throw(pvpException) {
  if (availPmode()) {
    pvpAccess a = accessPmode();
    printf("Pmode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPmode().decode() <<"\n";
        ss << "  min value: " << minPmode().decode() <<"\n";
        ss << "  max value: " << maxPmode().decode() <<"\n";
        ss << "  default value: " << defaultPmode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPmode());
  } else {
    printf("Pmode is not available.\n");
  }
}

bool pvpCamera::availTemp() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_TEMP,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get TEMP availability");
  return avail;
}

pvpAccess pvpCamera::accessTemp() throw(pvpException) {
  uns16 access;
  if (!availTemp())
    throw pvpException("TEMP not available");
  if (!pl_get_param(camh,PARAM_TEMP,ATTR_ACCESS,&access))
    throw pvpException("Cannot get TEMP accessibility");
  return pvpAccess(access);
}

int pvpCamera::countTemp() throw(pvpException) {
  uns32 count;
  if (!availTemp())
    throw pvpException("TEMP not available");
  if (!pl_get_param(camh,PARAM_TEMP,ATTR_COUNT,&count))
    throw pvpException("Cannot get TEMP count");
  return count;
}

int16_t pvpCamera::getTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_CURRENT,&x))
      throw pvpException("Cannot read TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

int16_t pvpCamera::defaultTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

int16_t pvpCamera::minTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_MIN,&x))
      throw pvpException("Cannot read min of TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

int16_t pvpCamera::maxTemp() throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP,ATTR_MAX,&x))
      throw pvpException("Cannot read max of TEMP");
    return x;
  } else {
    throw pvpException("TEMP not accessible for reading");
  }
}

void pvpCamera::setTemp(int16_t x) throw(pvpException) {
  pvpAccess a = accessTemp();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_TEMP,(void*)(&y)))
      throw pvpException("Cannot set TEMP");
  }
}

void pvpCamera::reportTemp() throw(pvpException) {
  if (availTemp()) {
    pvpAccess a = accessTemp();
    printf("Temp: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getTemp() <<"\n";
        ss << "  min value: " << minTemp() <<"\n";
        ss << "  max value: " << maxTemp() <<"\n";
        ss << "  default value: " << defaultTemp() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countTemp());
  } else {
    printf("Temp is not available.\n");
  }
}

bool pvpCamera::availTempSetpoint() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get TEMP_SETPOINT availability");
  return avail;
}

pvpAccess pvpCamera::accessTempSetpoint() throw(pvpException) {
  uns16 access;
  if (!availTempSetpoint())
    throw pvpException("TEMP_SETPOINT not available");
  if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get TEMP_SETPOINT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countTempSetpoint() throw(pvpException) {
  uns32 count;
  if (!availTempSetpoint())
    throw pvpException("TEMP_SETPOINT not available");
  if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_COUNT,&count))
    throw pvpException("Cannot get TEMP_SETPOINT count");
  return count;
}

int16_t pvpCamera::getTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

int16_t pvpCamera::defaultTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

int16_t pvpCamera::minTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

int16_t pvpCamera::maxTempSetpoint() throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_TEMP_SETPOINT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of TEMP_SETPOINT");
    return x;
  } else {
    throw pvpException("TEMP_SETPOINT not accessible for reading");
  }
}

void pvpCamera::setTempSetpoint(int16_t x) throw(pvpException) {
  pvpAccess a = accessTempSetpoint();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_TEMP_SETPOINT,(void*)(&y)))
      throw pvpException("Cannot set TEMP_SETPOINT");
  }
}

void pvpCamera::reportTempSetpoint() throw(pvpException) {
  if (availTempSetpoint()) {
    pvpAccess a = accessTempSetpoint();
    printf("TempSetpoint: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getTempSetpoint() <<"\n";
        ss << "  min value: " << minTempSetpoint() <<"\n";
        ss << "  max value: " << maxTempSetpoint() <<"\n";
        ss << "  default value: " << defaultTempSetpoint() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countTempSetpoint());
  } else {
    printf("TempSetpoint is not available.\n");
  }
}

bool pvpCamera::availCamFwVersion() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CAM_FW_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessCamFwVersion() throw(pvpException) {
  uns16 access;
  if (!availCamFwVersion())
    throw pvpException("CAM_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CAM_FW_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCamFwVersion() throw(pvpException) {
  uns32 count;
  if (!availCamFwVersion())
    throw pvpException("CAM_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get CAM_FW_VERSION count");
  return count;
}

uint16_t pvpCamera::getCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::defaultCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::minCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::maxCamFwVersion() throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CAM_FW_VERSION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CAM_FW_VERSION");
    return x;
  } else {
    throw pvpException("CAM_FW_VERSION not accessible for reading");
  }
}

void pvpCamera::setCamFwVersion(uint16_t x) throw(pvpException) {
  pvpAccess a = accessCamFwVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_CAM_FW_VERSION,(void*)(&y)))
      throw pvpException("Cannot set CAM_FW_VERSION");
  }
}

void pvpCamera::reportCamFwVersion() throw(pvpException) {
  if (availCamFwVersion()) {
    pvpAccess a = accessCamFwVersion();
    printf("CamFwVersion: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCamFwVersion() <<"\n";
        ss << "  min value: " << minCamFwVersion() <<"\n";
        ss << "  max value: " << maxCamFwVersion() <<"\n";
        ss << "  default value: " << defaultCamFwVersion() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCamFwVersion());
  } else {
    printf("CamFwVersion is not available.\n");
  }
}

bool pvpCamera::availHeadSerNumAlpha() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get HEAD_SER_NUM_ALPHA availability");
  return avail;
}

pvpAccess pvpCamera::accessHeadSerNumAlpha() throw(pvpException) {
  uns16 access;
  if (!availHeadSerNumAlpha())
    throw pvpException("HEAD_SER_NUM_ALPHA not available");
  if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_ACCESS,&access))
    throw pvpException("Cannot get HEAD_SER_NUM_ALPHA accessibility");
  return pvpAccess(access);
}

int pvpCamera::countHeadSerNumAlpha() throw(pvpException) {
  uns32 count;
  if (!availHeadSerNumAlpha())
    throw pvpException("HEAD_SER_NUM_ALPHA not available");
  if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_COUNT,&count))
    throw pvpException("Cannot get HEAD_SER_NUM_ALPHA count");
  return count;
}

QString pvpCamera::getHeadSerNumAlpha() throw(pvpException) {
  pvpAccess a = accessHeadSerNumAlpha();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countHeadSerNumAlpha(), 0);
    if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read HEAD_SER_NUM_ALPHA");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("HEAD_SER_NUM_ALPHA not accessible for reading");
  }
}

QString pvpCamera::defaultHeadSerNumAlpha() throw(pvpException) {
  pvpAccess a = accessHeadSerNumAlpha();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countHeadSerNumAlpha()];
    if (!pl_get_param(camh,PARAM_HEAD_SER_NUM_ALPHA,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of HEAD_SER_NUM_ALPHA");
    return x;
  } else {
    throw pvpException("HEAD_SER_NUM_ALPHA not accessible for reading");
  }
}

QString pvpCamera::minHeadSerNumAlpha() throw(pvpException) {
    return "";
}

QString pvpCamera::maxHeadSerNumAlpha() throw(pvpException) {
    return "";
}

void pvpCamera::setHeadSerNumAlpha(QString x) throw(pvpException) {
  pvpAccess a = accessHeadSerNumAlpha();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_HEAD_SER_NUM_ALPHA,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set HEAD_SER_NUM_ALPHA");
  }
}

void pvpCamera::reportHeadSerNumAlpha() throw(pvpException) {
  if (availHeadSerNumAlpha()) {
    pvpAccess a = accessHeadSerNumAlpha();
    printf("HeadSerNumAlpha: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getHeadSerNumAlpha() <<"\n";
        ss << "  min value: " << minHeadSerNumAlpha() <<"\n";
        ss << "  max value: " << maxHeadSerNumAlpha() <<"\n";
        ss << "  default value: " << defaultHeadSerNumAlpha() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countHeadSerNumAlpha());
  } else {
    printf("HeadSerNumAlpha is not available.\n");
  }
}

bool pvpCamera::availPciFwVersion() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PCI_FW_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessPciFwVersion() throw(pvpException) {
  uns16 access;
  if (!availPciFwVersion())
    throw pvpException("PCI_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PCI_FW_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPciFwVersion() throw(pvpException) {
  uns32 count;
  if (!availPciFwVersion())
    throw pvpException("PCI_FW_VERSION not available");
  if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get PCI_FW_VERSION count");
  return count;
}

uint16_t pvpCamera::getPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::minPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::maxPciFwVersion() throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PCI_FW_VERSION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PCI_FW_VERSION");
    return x;
  } else {
    throw pvpException("PCI_FW_VERSION not accessible for reading");
  }
}

void pvpCamera::setPciFwVersion(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPciFwVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PCI_FW_VERSION,(void*)(&y)))
      throw pvpException("Cannot set PCI_FW_VERSION");
  }
}

void pvpCamera::reportPciFwVersion() throw(pvpException) {
  if (availPciFwVersion()) {
    pvpAccess a = accessPciFwVersion();
    printf("PciFwVersion: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPciFwVersion() <<"\n";
        ss << "  min value: " << minPciFwVersion() <<"\n";
        ss << "  max value: " << maxPciFwVersion() <<"\n";
        ss << "  default value: " << defaultPciFwVersion() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPciFwVersion());
  } else {
    printf("PciFwVersion is not available.\n");
  }
}

char const *pvpCamera::FanSpeedSetpoint::decode() const {
  switch (x) {
    case High: return "High";
    case Medium: return "Medium";
    case Low: return "Low";
    case Off: return "Off";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availFanSpeedSetpoint() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FAN_SPEED_SETPOINT availability");
  return avail;
}

pvpAccess pvpCamera::accessFanSpeedSetpoint() throw(pvpException) {
  uns16 access;
  if (!availFanSpeedSetpoint())
    throw pvpException("FAN_SPEED_SETPOINT not available");
  if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FAN_SPEED_SETPOINT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFanSpeedSetpoint() throw(pvpException) {
  uns32 count;
  if (!availFanSpeedSetpoint())
    throw pvpException("FAN_SPEED_SETPOINT not available");
  if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_COUNT,&count))
    throw pvpException("Cannot get FAN_SPEED_SETPOINT count");
  return count;
}

pvpCamera::FanSpeedSetpoint pvpCamera::getFanSpeedSetpoint() throw(pvpException) {
  pvpAccess a = accessFanSpeedSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FAN_SPEED_SETPOINT");
    return x;
  } else {
    throw pvpException("FAN_SPEED_SETPOINT not accessible for reading");
  }
}

pvpCamera::FanSpeedSetpoint pvpCamera::defaultFanSpeedSetpoint() throw(pvpException) {
  pvpAccess a = accessFanSpeedSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FAN_SPEED_SETPOINT");
    return x;
  } else {
    throw pvpException("FAN_SPEED_SETPOINT not accessible for reading");
  }
}

pvpCamera::FanSpeedSetpoint pvpCamera::minFanSpeedSetpoint() throw(pvpException) {
  pvpAccess a = accessFanSpeedSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FAN_SPEED_SETPOINT");
    return x;
  } else {
    throw pvpException("FAN_SPEED_SETPOINT not accessible for reading");
  }
}

pvpCamera::FanSpeedSetpoint pvpCamera::maxFanSpeedSetpoint() throw(pvpException) {
  pvpAccess a = accessFanSpeedSetpoint();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_FAN_SPEED_SETPOINT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FAN_SPEED_SETPOINT");
    return x;
  } else {
    throw pvpException("FAN_SPEED_SETPOINT not accessible for reading");
  }
}

void pvpCamera::setFanSpeedSetpoint(pvpCamera::FanSpeedSetpoint x) throw(pvpException) {
  pvpAccess a = accessFanSpeedSetpoint();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_FAN_SPEED_SETPOINT,(void*)(&y)))
      throw pvpException("Cannot set FAN_SPEED_SETPOINT");
  }
}

void pvpCamera::reportFanSpeedSetpoint() throw(pvpException) {
  if (availFanSpeedSetpoint()) {
    pvpAccess a = accessFanSpeedSetpoint();
    printf("FanSpeedSetpoint: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFanSpeedSetpoint().decode() <<"\n";
        ss << "  min value: " << minFanSpeedSetpoint().decode() <<"\n";
        ss << "  max value: " << maxFanSpeedSetpoint().decode() <<"\n";
        ss << "  default value: " << defaultFanSpeedSetpoint().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countFanSpeedSetpoint());
  } else {
    printf("FanSpeedSetpoint is not available.\n");
  }
}

char const *pvpCamera::ExposureMode::decode() const {
  switch (x) {
    case TimedMode: return "TimedMode";
    case StrobedMode: return "StrobedMode";
    case BulbMode: return "BulbMode";
    case TriggerFirstMode: return "TriggerFirstMode";
    case FlashMode: return "FlashMode";
    case VariableTimedMode: return "VariableTimedMode";
    case IntStrobeMode: return "IntStrobeMode";
    case MaxExposeMode: return "MaxExposeMode";
    case ExtTrigInternal: return "ExtTrigInternal";
    case ExtTrigTrigFirst: return "ExtTrigTrigFirst";
    case ExtTrigEdgeRising: return "ExtTrigEdgeRising";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availExposureMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXPOSURE_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessExposureMode() throw(pvpException) {
  uns16 access;
  if (!availExposureMode())
    throw pvpException("EXPOSURE_MODE not available");
  if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXPOSURE_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExposureMode() throw(pvpException) {
  uns32 count;
  if (!availExposureMode())
    throw pvpException("EXPOSURE_MODE not available");
  if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXPOSURE_MODE count");
  return count;
}

pvpCamera::ExposureMode pvpCamera::getExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

pvpCamera::ExposureMode pvpCamera::defaultExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

pvpCamera::ExposureMode pvpCamera::minExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

pvpCamera::ExposureMode pvpCamera::maxExposureMode() throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXPOSURE_MODE");
    return x;
  } else {
    throw pvpException("EXPOSURE_MODE not accessible for reading");
  }
}

void pvpCamera::setExposureMode(pvpCamera::ExposureMode x) throw(pvpException) {
  pvpAccess a = accessExposureMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_EXPOSURE_MODE,(void*)(&y)))
      throw pvpException("Cannot set EXPOSURE_MODE");
  }
}

void pvpCamera::reportExposureMode() throw(pvpException) {
  if (availExposureMode()) {
    pvpAccess a = accessExposureMode();
    printf("ExposureMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExposureMode().decode() <<"\n";
        ss << "  min value: " << minExposureMode().decode() <<"\n";
        ss << "  max value: " << maxExposureMode().decode() <<"\n";
        ss << "  default value: " << defaultExposureMode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countExposureMode());
  } else {
    printf("ExposureMode is not available.\n");
  }
}

char const *pvpCamera::ExposeOutMode::decode() const {
  switch (x) {
    case ExposeOutFirstRow: return "ExposeOutFirstRow";
    case ExposeOutAllRows: return "ExposeOutAllRows";
    case ExposeOutAnyRow: return "ExposeOutAnyRow";
    case MaxExposeOutMode: return "MaxExposeOutMode";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availExposeOutMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXPOSE_OUT_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessExposeOutMode() throw(pvpException) {
  uns16 access;
  if (!availExposeOutMode())
    throw pvpException("EXPOSE_OUT_MODE not available");
  if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXPOSE_OUT_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExposeOutMode() throw(pvpException) {
  uns32 count;
  if (!availExposeOutMode())
    throw pvpException("EXPOSE_OUT_MODE not available");
  if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXPOSE_OUT_MODE count");
  return count;
}

pvpCamera::ExposeOutMode pvpCamera::getExposeOutMode() throw(pvpException) {
  pvpAccess a = accessExposeOutMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXPOSE_OUT_MODE");
    return x;
  } else {
    throw pvpException("EXPOSE_OUT_MODE not accessible for reading");
  }
}

pvpCamera::ExposeOutMode pvpCamera::defaultExposeOutMode() throw(pvpException) {
  pvpAccess a = accessExposeOutMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXPOSE_OUT_MODE");
    return x;
  } else {
    throw pvpException("EXPOSE_OUT_MODE not accessible for reading");
  }
}

pvpCamera::ExposeOutMode pvpCamera::minExposeOutMode() throw(pvpException) {
  pvpAccess a = accessExposeOutMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXPOSE_OUT_MODE");
    return x;
  } else {
    throw pvpException("EXPOSE_OUT_MODE not accessible for reading");
  }
}

pvpCamera::ExposeOutMode pvpCamera::maxExposeOutMode() throw(pvpException) {
  pvpAccess a = accessExposeOutMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXPOSE_OUT_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXPOSE_OUT_MODE");
    return x;
  } else {
    throw pvpException("EXPOSE_OUT_MODE not accessible for reading");
  }
}

void pvpCamera::setExposeOutMode(pvpCamera::ExposeOutMode x) throw(pvpException) {
  pvpAccess a = accessExposeOutMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_EXPOSE_OUT_MODE,(void*)(&y)))
      throw pvpException("Cannot set EXPOSE_OUT_MODE");
  }
}

void pvpCamera::reportExposeOutMode() throw(pvpException) {
  if (availExposeOutMode()) {
    pvpAccess a = accessExposeOutMode();
    printf("ExposeOutMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExposeOutMode().decode() <<"\n";
        ss << "  min value: " << minExposeOutMode().decode() <<"\n";
        ss << "  max value: " << maxExposeOutMode().decode() <<"\n";
        ss << "  default value: " << defaultExposeOutMode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countExposeOutMode());
  } else {
    printf("ExposeOutMode is not available.\n");
  }
}

bool pvpCamera::availBitDepth() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BIT_DEPTH availability");
  return avail;
}

pvpAccess pvpCamera::accessBitDepth() throw(pvpException) {
  uns16 access;
  if (!availBitDepth())
    throw pvpException("BIT_DEPTH not available");
  if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BIT_DEPTH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBitDepth() throw(pvpException) {
  uns32 count;
  if (!availBitDepth())
    throw pvpException("BIT_DEPTH not available");
  if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_COUNT,&count))
    throw pvpException("Cannot get BIT_DEPTH count");
  return count;
}

int16_t pvpCamera::getBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

int16_t pvpCamera::defaultBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

int16_t pvpCamera::minBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

int16_t pvpCamera::maxBitDepth() throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_BIT_DEPTH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BIT_DEPTH");
    return x;
  } else {
    throw pvpException("BIT_DEPTH not accessible for reading");
  }
}

void pvpCamera::setBitDepth(int16_t x) throw(pvpException) {
  pvpAccess a = accessBitDepth();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_BIT_DEPTH,(void*)(&y)))
      throw pvpException("Cannot set BIT_DEPTH");
  }
}

void pvpCamera::reportBitDepth() throw(pvpException) {
  if (availBitDepth()) {
    pvpAccess a = accessBitDepth();
    printf("BitDepth: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBitDepth() <<"\n";
        ss << "  min value: " << minBitDepth() <<"\n";
        ss << "  max value: " << maxBitDepth() <<"\n";
        ss << "  default value: " << defaultBitDepth() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countBitDepth());
  } else {
    printf("BitDepth is not available.\n");
  }
}

bool pvpCamera::availGainIndex() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessGainIndex() throw(pvpException) {
  uns16 access;
  if (!availGainIndex())
    throw pvpException("GAIN_INDEX not available");
  if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainIndex() throw(pvpException) {
  uns32 count;
  if (!availGainIndex())
    throw pvpException("GAIN_INDEX not available");
  if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_INDEX count");
  return count;
}

int16_t pvpCamera::getGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::defaultGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::minGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::maxGainIndex() throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of GAIN_INDEX");
    return x;
  } else {
    throw pvpException("GAIN_INDEX not accessible for reading");
  }
}

void pvpCamera::setGainIndex(int16_t x) throw(pvpException) {
  pvpAccess a = accessGainIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_GAIN_INDEX,(void*)(&y)))
      throw pvpException("Cannot set GAIN_INDEX");
  }
}

void pvpCamera::reportGainIndex() throw(pvpException) {
  if (availGainIndex()) {
    pvpAccess a = accessGainIndex();
    printf("GainIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainIndex() <<"\n";
        ss << "  min value: " << minGainIndex() <<"\n";
        ss << "  max value: " << maxGainIndex() <<"\n";
        ss << "  default value: " << defaultGainIndex() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countGainIndex());
  } else {
    printf("GainIndex is not available.\n");
  }
}

bool pvpCamera::availSpdtabIndex() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SPDTAB_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessSpdtabIndex() throw(pvpException) {
  uns16 access;
  if (!availSpdtabIndex())
    throw pvpException("SPDTAB_INDEX not available");
  if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SPDTAB_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSpdtabIndex() throw(pvpException) {
  uns32 count;
  if (!availSpdtabIndex())
    throw pvpException("SPDTAB_INDEX not available");
  if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get SPDTAB_INDEX count");
  return count;
}

int16_t pvpCamera::getSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::defaultSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::minSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::maxSpdtabIndex() throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_SPDTAB_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SPDTAB_INDEX");
    return x;
  } else {
    throw pvpException("SPDTAB_INDEX not accessible for reading");
  }
}

void pvpCamera::setSpdtabIndex(int16_t x) throw(pvpException) {
  pvpAccess a = accessSpdtabIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_SPDTAB_INDEX,(void*)(&y)))
      throw pvpException("Cannot set SPDTAB_INDEX");
  }
}

void pvpCamera::reportSpdtabIndex() throw(pvpException) {
  if (availSpdtabIndex()) {
    pvpAccess a = accessSpdtabIndex();
    printf("SpdtabIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSpdtabIndex() <<"\n";
        ss << "  min value: " << minSpdtabIndex() <<"\n";
        ss << "  max value: " << maxSpdtabIndex() <<"\n";
        ss << "  default value: " << defaultSpdtabIndex() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSpdtabIndex());
  } else {
    printf("SpdtabIndex is not available.\n");
  }
}

bool pvpCamera::availGainName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessGainName() throw(pvpException) {
  uns16 access;
  if (!availGainName())
    throw pvpException("GAIN_NAME not available");
  if (!pl_get_param(camh,PARAM_GAIN_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainName() throw(pvpException) {
  uns32 count;
  if (!availGainName())
    throw pvpException("GAIN_NAME not available");
  if (!pl_get_param(camh,PARAM_GAIN_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_NAME count");
  return count;
}

QString pvpCamera::getGainName() throw(pvpException) {
  pvpAccess a = accessGainName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countGainName(), 0);
    if (!pl_get_param(camh,PARAM_GAIN_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read GAIN_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("GAIN_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultGainName() throw(pvpException) {
  pvpAccess a = accessGainName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countGainName()];
    if (!pl_get_param(camh,PARAM_GAIN_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of GAIN_NAME");
    return x;
  } else {
    throw pvpException("GAIN_NAME not accessible for reading");
  }
}

QString pvpCamera::minGainName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxGainName() throw(pvpException) {
    return "";
}

void pvpCamera::setGainName(QString x) throw(pvpException) {
  pvpAccess a = accessGainName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_GAIN_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set GAIN_NAME");
  }
}

void pvpCamera::reportGainName() throw(pvpException) {
  if (availGainName()) {
    pvpAccess a = accessGainName();
    printf("GainName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainName() <<"\n";
        ss << "  min value: " << minGainName() <<"\n";
        ss << "  max value: " << maxGainName() <<"\n";
        ss << "  default value: " << defaultGainName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countGainName());
  } else {
    printf("GainName is not available.\n");
  }
}

char const *pvpCamera::ReadoutPort::decode() const {
  switch (x) {
    case X0: return "X0";
    case X1: return "X1";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availReadoutPort() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get READOUT_PORT availability");
  return avail;
}

pvpAccess pvpCamera::accessReadoutPort() throw(pvpException) {
  uns16 access;
  if (!availReadoutPort())
    throw pvpException("READOUT_PORT not available");
  if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get READOUT_PORT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countReadoutPort() throw(pvpException) {
  uns32 count;
  if (!availReadoutPort())
    throw pvpException("READOUT_PORT not available");
  if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_COUNT,&count))
    throw pvpException("Cannot get READOUT_PORT count");
  return count;
}

pvpCamera::ReadoutPort pvpCamera::getReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

pvpCamera::ReadoutPort pvpCamera::defaultReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

pvpCamera::ReadoutPort pvpCamera::minReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

pvpCamera::ReadoutPort pvpCamera::maxReadoutPort() throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_READOUT_PORT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of READOUT_PORT");
    return x;
  } else {
    throw pvpException("READOUT_PORT not accessible for reading");
  }
}

void pvpCamera::setReadoutPort(pvpCamera::ReadoutPort x) throw(pvpException) {
  pvpAccess a = accessReadoutPort();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_READOUT_PORT,(void*)(&y)))
      throw pvpException("Cannot set READOUT_PORT");
  }
}

void pvpCamera::reportReadoutPort() throw(pvpException) {
  if (availReadoutPort()) {
    pvpAccess a = accessReadoutPort();
    printf("ReadoutPort: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getReadoutPort().decode() <<"\n";
        ss << "  min value: " << minReadoutPort().decode() <<"\n";
        ss << "  max value: " << maxReadoutPort().decode() <<"\n";
        ss << "  default value: " << defaultReadoutPort().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countReadoutPort());
  } else {
    printf("ReadoutPort is not available.\n");
  }
}

bool pvpCamera::availPixTime() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PIX_TIME availability");
  return avail;
}

pvpAccess pvpCamera::accessPixTime() throw(pvpException) {
  uns16 access;
  if (!availPixTime())
    throw pvpException("PIX_TIME not available");
  if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PIX_TIME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPixTime() throw(pvpException) {
  uns32 count;
  if (!availPixTime())
    throw pvpException("PIX_TIME not available");
  if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_COUNT,&count))
    throw pvpException("Cannot get PIX_TIME count");
  return count;
}

uint16_t pvpCamera::getPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

uint16_t pvpCamera::minPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

uint16_t pvpCamera::maxPixTime() throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PIX_TIME,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PIX_TIME");
    return x;
  } else {
    throw pvpException("PIX_TIME not accessible for reading");
  }
}

void pvpCamera::setPixTime(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPixTime();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PIX_TIME,(void*)(&y)))
      throw pvpException("Cannot set PIX_TIME");
  }
}

void pvpCamera::reportPixTime() throw(pvpException) {
  if (availPixTime()) {
    pvpAccess a = accessPixTime();
    printf("PixTime: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPixTime() <<"\n";
        ss << "  min value: " << minPixTime() <<"\n";
        ss << "  max value: " << maxPixTime() <<"\n";
        ss << "  default value: " << defaultPixTime() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPixTime());
  } else {
    printf("PixTime is not available.\n");
  }
}

bool pvpCamera::availShtrCloseDelay() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrCloseDelay() throw(pvpException) {
  uns16 access;
  if (!availShtrCloseDelay())
    throw pvpException("SHTR_CLOSE_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrCloseDelay() throw(pvpException) {
  uns32 count;
  if (!availShtrCloseDelay())
    throw pvpException("SHTR_CLOSE_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_CLOSE_DELAY count");
  return count;
}

uint16_t pvpCamera::getShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::defaultShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::minShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::maxShtrCloseDelay() throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_CLOSE_DELAY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_CLOSE_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_CLOSE_DELAY not accessible for reading");
  }
}

void pvpCamera::setShtrCloseDelay(uint16_t x) throw(pvpException) {
  pvpAccess a = accessShtrCloseDelay();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_SHTR_CLOSE_DELAY,(void*)(&y)))
      throw pvpException("Cannot set SHTR_CLOSE_DELAY");
  }
}

void pvpCamera::reportShtrCloseDelay() throw(pvpException) {
  if (availShtrCloseDelay()) {
    pvpAccess a = accessShtrCloseDelay();
    printf("ShtrCloseDelay: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrCloseDelay() <<"\n";
        ss << "  min value: " << minShtrCloseDelay() <<"\n";
        ss << "  max value: " << maxShtrCloseDelay() <<"\n";
        ss << "  default value: " << defaultShtrCloseDelay() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countShtrCloseDelay());
  } else {
    printf("ShtrCloseDelay is not available.\n");
  }
}

bool pvpCamera::availShtrOpenDelay() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_OPEN_DELAY availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrOpenDelay() throw(pvpException) {
  uns16 access;
  if (!availShtrOpenDelay())
    throw pvpException("SHTR_OPEN_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_OPEN_DELAY accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrOpenDelay() throw(pvpException) {
  uns32 count;
  if (!availShtrOpenDelay())
    throw pvpException("SHTR_OPEN_DELAY not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_OPEN_DELAY count");
  return count;
}

uint16_t pvpCamera::getShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::defaultShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::minShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

uint16_t pvpCamera::maxShtrOpenDelay() throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_DELAY,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_OPEN_DELAY");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_DELAY not accessible for reading");
  }
}

void pvpCamera::setShtrOpenDelay(uint16_t x) throw(pvpException) {
  pvpAccess a = accessShtrOpenDelay();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_SHTR_OPEN_DELAY,(void*)(&y)))
      throw pvpException("Cannot set SHTR_OPEN_DELAY");
  }
}

void pvpCamera::reportShtrOpenDelay() throw(pvpException) {
  if (availShtrOpenDelay()) {
    pvpAccess a = accessShtrOpenDelay();
    printf("ShtrOpenDelay: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrOpenDelay() <<"\n";
        ss << "  min value: " << minShtrOpenDelay() <<"\n";
        ss << "  max value: " << maxShtrOpenDelay() <<"\n";
        ss << "  default value: " << defaultShtrOpenDelay() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countShtrOpenDelay());
  } else {
    printf("ShtrOpenDelay is not available.\n");
  }
}

char const *pvpCamera::ShtrOpenMode::decode() const {
  switch (x) {
    case Never: return "Never";
    case PreExposure: return "PreExposure";
    case PreSequence: return "PreSequence";
    case PreTrigger: return "PreTrigger";
    case NoChange: return "NoChange";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availShtrOpenMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_OPEN_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrOpenMode() throw(pvpException) {
  uns16 access;
  if (!availShtrOpenMode())
    throw pvpException("SHTR_OPEN_MODE not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_OPEN_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrOpenMode() throw(pvpException) {
  uns32 count;
  if (!availShtrOpenMode())
    throw pvpException("SHTR_OPEN_MODE not available");
  if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_OPEN_MODE count");
  return count;
}

pvpCamera::ShtrOpenMode pvpCamera::getShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

pvpCamera::ShtrOpenMode pvpCamera::defaultShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

pvpCamera::ShtrOpenMode pvpCamera::minShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

pvpCamera::ShtrOpenMode pvpCamera::maxShtrOpenMode() throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_OPEN_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_OPEN_MODE");
    return x;
  } else {
    throw pvpException("SHTR_OPEN_MODE not accessible for reading");
  }
}

void pvpCamera::setShtrOpenMode(pvpCamera::ShtrOpenMode x) throw(pvpException) {
  pvpAccess a = accessShtrOpenMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_OPEN_MODE,(void*)(&y)))
      throw pvpException("Cannot set SHTR_OPEN_MODE");
  }
}

void pvpCamera::reportShtrOpenMode() throw(pvpException) {
  if (availShtrOpenMode()) {
    pvpAccess a = accessShtrOpenMode();
    printf("ShtrOpenMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrOpenMode().decode() <<"\n";
        ss << "  min value: " << minShtrOpenMode().decode() <<"\n";
        ss << "  max value: " << maxShtrOpenMode().decode() <<"\n";
        ss << "  default value: " << defaultShtrOpenMode().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countShtrOpenMode());
  } else {
    printf("ShtrOpenMode is not available.\n");
  }
}

char const *pvpCamera::ShtrStatus::decode() const {
  switch (x) {
    case Fault: return "Fault";
    case Opening: return "Opening";
    case Open: return "Open";
    case Closing: return "Closing";
    case Closed: return "Closed";
    case Unknown: return "Unknown";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availShtrStatus() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SHTR_STATUS availability");
  return avail;
}

pvpAccess pvpCamera::accessShtrStatus() throw(pvpException) {
  uns16 access;
  if (!availShtrStatus())
    throw pvpException("SHTR_STATUS not available");
  if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SHTR_STATUS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countShtrStatus() throw(pvpException) {
  uns32 count;
  if (!availShtrStatus())
    throw pvpException("SHTR_STATUS not available");
  if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_COUNT,&count))
    throw pvpException("Cannot get SHTR_STATUS count");
  return count;
}

pvpCamera::ShtrStatus pvpCamera::getShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

pvpCamera::ShtrStatus pvpCamera::defaultShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

pvpCamera::ShtrStatus pvpCamera::minShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

pvpCamera::ShtrStatus pvpCamera::maxShtrStatus() throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_SHTR_STATUS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SHTR_STATUS");
    return x;
  } else {
    throw pvpException("SHTR_STATUS not accessible for reading");
  }
}

void pvpCamera::setShtrStatus(pvpCamera::ShtrStatus x) throw(pvpException) {
  pvpAccess a = accessShtrStatus();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_SHTR_STATUS,(void*)(&y)))
      throw pvpException("Cannot set SHTR_STATUS");
  }
}

void pvpCamera::reportShtrStatus() throw(pvpException) {
  if (availShtrStatus()) {
    pvpAccess a = accessShtrStatus();
    printf("ShtrStatus: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getShtrStatus().decode() <<"\n";
        ss << "  min value: " << minShtrStatus().decode() <<"\n";
        ss << "  max value: " << maxShtrStatus().decode() <<"\n";
        ss << "  default value: " << defaultShtrStatus().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countShtrStatus());
  } else {
    printf("ShtrStatus is not available.\n");
  }
}

bool pvpCamera::availIoAddr() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_ADDR availability");
  return avail;
}

pvpAccess pvpCamera::accessIoAddr() throw(pvpException) {
  uns16 access;
  if (!availIoAddr())
    throw pvpException("IO_ADDR not available");
  if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_ADDR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoAddr() throw(pvpException) {
  uns32 count;
  if (!availIoAddr())
    throw pvpException("IO_ADDR not available");
  if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_ADDR count");
  return count;
}

uint16_t pvpCamera::getIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

uint16_t pvpCamera::defaultIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

uint16_t pvpCamera::minIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

uint16_t pvpCamera::maxIoAddr() throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_ADDR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_ADDR");
    return x;
  } else {
    throw pvpException("IO_ADDR not accessible for reading");
  }
}

void pvpCamera::setIoAddr(uint16_t x) throw(pvpException) {
  pvpAccess a = accessIoAddr();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_IO_ADDR,(void*)(&y)))
      throw pvpException("Cannot set IO_ADDR");
  }
}

void pvpCamera::reportIoAddr() throw(pvpException) {
  if (availIoAddr()) {
    pvpAccess a = accessIoAddr();
    printf("IoAddr: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoAddr() <<"\n";
        ss << "  min value: " << minIoAddr() <<"\n";
        ss << "  max value: " << maxIoAddr() <<"\n";
        ss << "  default value: " << defaultIoAddr() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countIoAddr());
  } else {
    printf("IoAddr is not available.\n");
  }
}

char const *pvpCamera::IoType::decode() const {
  switch (x) {
    case Ttl: return "Ttl";
    case Dac: return "Dac";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availIoType() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_TYPE availability");
  return avail;
}

pvpAccess pvpCamera::accessIoType() throw(pvpException) {
  uns16 access;
  if (!availIoType())
    throw pvpException("IO_TYPE not available");
  if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_TYPE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoType() throw(pvpException) {
  uns32 count;
  if (!availIoType())
    throw pvpException("IO_TYPE not available");
  if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_TYPE count");
  return count;
}

pvpCamera::IoType pvpCamera::getIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

pvpCamera::IoType pvpCamera::defaultIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

pvpCamera::IoType pvpCamera::minIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

pvpCamera::IoType pvpCamera::maxIoType() throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_TYPE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_TYPE");
    return x;
  } else {
    throw pvpException("IO_TYPE not accessible for reading");
  }
}

void pvpCamera::setIoType(pvpCamera::IoType x) throw(pvpException) {
  pvpAccess a = accessIoType();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_IO_TYPE,(void*)(&y)))
      throw pvpException("Cannot set IO_TYPE");
  }
}

void pvpCamera::reportIoType() throw(pvpException) {
  if (availIoType()) {
    pvpAccess a = accessIoType();
    printf("IoType: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoType().decode() <<"\n";
        ss << "  min value: " << minIoType().decode() <<"\n";
        ss << "  max value: " << maxIoType().decode() <<"\n";
        ss << "  default value: " << defaultIoType().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countIoType());
  } else {
    printf("IoType is not available.\n");
  }
}

char const *pvpCamera::IoDirection::decode() const {
  switch (x) {
    case Input: return "Input";
    case Output: return "Output";
    case InputOutput: return "InputOutput";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availIoDirection() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_DIRECTION availability");
  return avail;
}

pvpAccess pvpCamera::accessIoDirection() throw(pvpException) {
  uns16 access;
  if (!availIoDirection())
    throw pvpException("IO_DIRECTION not available");
  if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_DIRECTION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoDirection() throw(pvpException) {
  uns32 count;
  if (!availIoDirection())
    throw pvpException("IO_DIRECTION not available");
  if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_DIRECTION count");
  return count;
}

pvpCamera::IoDirection pvpCamera::getIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

pvpCamera::IoDirection pvpCamera::defaultIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

pvpCamera::IoDirection pvpCamera::minIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

pvpCamera::IoDirection pvpCamera::maxIoDirection() throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_IO_DIRECTION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_DIRECTION");
    return x;
  } else {
    throw pvpException("IO_DIRECTION not accessible for reading");
  }
}

void pvpCamera::setIoDirection(pvpCamera::IoDirection x) throw(pvpException) {
  pvpAccess a = accessIoDirection();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_IO_DIRECTION,(void*)(&y)))
      throw pvpException("Cannot set IO_DIRECTION");
  }
}

void pvpCamera::reportIoDirection() throw(pvpException) {
  if (availIoDirection()) {
    pvpAccess a = accessIoDirection();
    printf("IoDirection: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoDirection().decode() <<"\n";
        ss << "  min value: " << minIoDirection().decode() <<"\n";
        ss << "  max value: " << maxIoDirection().decode() <<"\n";
        ss << "  default value: " << defaultIoDirection().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countIoDirection());
  } else {
    printf("IoDirection is not available.\n");
  }
}

bool pvpCamera::availIoState() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_STATE availability");
  return avail;
}

pvpAccess pvpCamera::accessIoState() throw(pvpException) {
  uns16 access;
  if (!availIoState())
    throw pvpException("IO_STATE not available");
  if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_STATE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoState() throw(pvpException) {
  uns32 count;
  if (!availIoState())
    throw pvpException("IO_STATE not available");
  if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_STATE count");
  return count;
}

double pvpCamera::getIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

double pvpCamera::defaultIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

double pvpCamera::minIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

double pvpCamera::maxIoState() throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    double x;
    if (!pl_get_param(camh,PARAM_IO_STATE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_STATE");
    return x;
  } else {
    throw pvpException("IO_STATE not accessible for reading");
  }
}

void pvpCamera::setIoState(double x) throw(pvpException) {
  pvpAccess a = accessIoState();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    double y = x;
    if (!pl_set_param(camh,PARAM_IO_STATE,(void*)(&y)))
      throw pvpException("Cannot set IO_STATE");
  }
}

void pvpCamera::reportIoState() throw(pvpException) {
  if (availIoState()) {
    pvpAccess a = accessIoState();
    printf("IoState: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoState() <<"\n";
        ss << "  min value: " << minIoState() <<"\n";
        ss << "  max value: " << maxIoState() <<"\n";
        ss << "  default value: " << defaultIoState() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countIoState());
  } else {
    printf("IoState is not available.\n");
  }
}

bool pvpCamera::availIoBitdepth() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get IO_BITDEPTH availability");
  return avail;
}

pvpAccess pvpCamera::accessIoBitdepth() throw(pvpException) {
  uns16 access;
  if (!availIoBitdepth())
    throw pvpException("IO_BITDEPTH not available");
  if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get IO_BITDEPTH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countIoBitdepth() throw(pvpException) {
  uns32 count;
  if (!availIoBitdepth())
    throw pvpException("IO_BITDEPTH not available");
  if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_COUNT,&count))
    throw pvpException("Cannot get IO_BITDEPTH count");
  return count;
}

uint16_t pvpCamera::getIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

uint16_t pvpCamera::defaultIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

uint16_t pvpCamera::minIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

uint16_t pvpCamera::maxIoBitdepth() throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_IO_BITDEPTH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of IO_BITDEPTH");
    return x;
  } else {
    throw pvpException("IO_BITDEPTH not accessible for reading");
  }
}

void pvpCamera::setIoBitdepth(uint16_t x) throw(pvpException) {
  pvpAccess a = accessIoBitdepth();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_IO_BITDEPTH,(void*)(&y)))
      throw pvpException("Cannot set IO_BITDEPTH");
  }
}

void pvpCamera::reportIoBitdepth() throw(pvpException) {
  if (availIoBitdepth()) {
    pvpAccess a = accessIoBitdepth();
    printf("IoBitdepth: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getIoBitdepth() <<"\n";
        ss << "  min value: " << minIoBitdepth() <<"\n";
        ss << "  max value: " << maxIoBitdepth() <<"\n";
        ss << "  default value: " << defaultIoBitdepth() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countIoBitdepth());
  } else {
    printf("IoBitdepth is not available.\n");
  }
}

bool pvpCamera::availGainMultFactor() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_MULT_FACTOR availability");
  return avail;
}

pvpAccess pvpCamera::accessGainMultFactor() throw(pvpException) {
  uns16 access;
  if (!availGainMultFactor())
    throw pvpException("GAIN_MULT_FACTOR not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_MULT_FACTOR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainMultFactor() throw(pvpException) {
  uns32 count;
  if (!availGainMultFactor())
    throw pvpException("GAIN_MULT_FACTOR not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_MULT_FACTOR count");
  return count;
}

uint16_t pvpCamera::getGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

uint16_t pvpCamera::defaultGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

uint16_t pvpCamera::minGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

uint16_t pvpCamera::maxGainMultFactor() throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_FACTOR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of GAIN_MULT_FACTOR");
    return x;
  } else {
    throw pvpException("GAIN_MULT_FACTOR not accessible for reading");
  }
}

void pvpCamera::setGainMultFactor(uint16_t x) throw(pvpException) {
  pvpAccess a = accessGainMultFactor();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_GAIN_MULT_FACTOR,(void*)(&y)))
      throw pvpException("Cannot set GAIN_MULT_FACTOR");
  }
}

void pvpCamera::reportGainMultFactor() throw(pvpException) {
  if (availGainMultFactor()) {
    pvpAccess a = accessGainMultFactor();
    printf("GainMultFactor: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainMultFactor() <<"\n";
        ss << "  min value: " << minGainMultFactor() <<"\n";
        ss << "  max value: " << maxGainMultFactor() <<"\n";
        ss << "  default value: " << defaultGainMultFactor() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countGainMultFactor());
  } else {
    printf("GainMultFactor is not available.\n");
  }
}

bool pvpCamera::availGainMultEnable() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get GAIN_MULT_ENABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessGainMultEnable() throw(pvpException) {
  uns16 access;
  if (!availGainMultEnable())
    throw pvpException("GAIN_MULT_ENABLE not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get GAIN_MULT_ENABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countGainMultEnable() throw(pvpException) {
  uns32 count;
  if (!availGainMultEnable())
    throw pvpException("GAIN_MULT_ENABLE not available");
  if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get GAIN_MULT_ENABLE count");
  return count;
}

bool pvpCamera::getGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

bool pvpCamera::defaultGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

bool pvpCamera::minGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

bool pvpCamera::maxGainMultEnable() throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_GAIN_MULT_ENABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of GAIN_MULT_ENABLE");
    return x;
  } else {
    throw pvpException("GAIN_MULT_ENABLE not accessible for reading");
  }
}

void pvpCamera::setGainMultEnable(bool x) throw(pvpException) {
  pvpAccess a = accessGainMultEnable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    bool y = x;
    if (!pl_set_param(camh,PARAM_GAIN_MULT_ENABLE,(void*)(&y)))
      throw pvpException("Cannot set GAIN_MULT_ENABLE");
  }
}

void pvpCamera::reportGainMultEnable() throw(pvpException) {
  if (availGainMultEnable()) {
    pvpAccess a = accessGainMultEnable();
    printf("GainMultEnable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getGainMultEnable() <<"\n";
        ss << "  min value: " << minGainMultEnable() <<"\n";
        ss << "  max value: " << maxGainMultEnable() <<"\n";
        ss << "  default value: " << defaultGainMultEnable() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countGainMultEnable());
  } else {
    printf("GainMultEnable is not available.\n");
  }
}

bool pvpCamera::availPpFeatName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_FEAT_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_FEAT_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessPpFeatName() throw(pvpException) {
  uns16 access;
  if (!availPpFeatName())
    throw pvpException("PP_FEAT_NAME not available");
  if (!pl_get_param(camh,PARAM_PP_FEAT_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_FEAT_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpFeatName() throw(pvpException) {
  uns32 count;
  if (!availPpFeatName())
    throw pvpException("PP_FEAT_NAME not available");
  if (!pl_get_param(camh,PARAM_PP_FEAT_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_FEAT_NAME count");
  return count;
}

QString pvpCamera::getPpFeatName() throw(pvpException) {
  pvpAccess a = accessPpFeatName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countPpFeatName(), 0);
    if (!pl_get_param(camh,PARAM_PP_FEAT_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read PP_FEAT_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("PP_FEAT_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultPpFeatName() throw(pvpException) {
  pvpAccess a = accessPpFeatName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countPpFeatName()];
    if (!pl_get_param(camh,PARAM_PP_FEAT_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of PP_FEAT_NAME");
    return x;
  } else {
    throw pvpException("PP_FEAT_NAME not accessible for reading");
  }
}

QString pvpCamera::minPpFeatName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxPpFeatName() throw(pvpException) {
    return "";
}

void pvpCamera::setPpFeatName(QString x) throw(pvpException) {
  pvpAccess a = accessPpFeatName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_PP_FEAT_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set PP_FEAT_NAME");
  }
}

void pvpCamera::reportPpFeatName() throw(pvpException) {
  if (availPpFeatName()) {
    pvpAccess a = accessPpFeatName();
    printf("PpFeatName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpFeatName() <<"\n";
        ss << "  min value: " << minPpFeatName() <<"\n";
        ss << "  max value: " << maxPpFeatName() <<"\n";
        ss << "  default value: " << defaultPpFeatName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpFeatName());
  } else {
    printf("PpFeatName is not available.\n");
  }
}

bool pvpCamera::availPpIndex() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessPpIndex() throw(pvpException) {
  uns16 access;
  if (!availPpIndex())
    throw pvpException("PP_INDEX not available");
  if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpIndex() throw(pvpException) {
  uns32 count;
  if (!availPpIndex())
    throw pvpException("PP_INDEX not available");
  if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_INDEX count");
  return count;
}

int16_t pvpCamera::getPpIndex() throw(pvpException) {
  pvpAccess a = accessPpIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PP_INDEX");
    return x;
  } else {
    throw pvpException("PP_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::defaultPpIndex() throw(pvpException) {
  pvpAccess a = accessPpIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PP_INDEX");
    return x;
  } else {
    throw pvpException("PP_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::minPpIndex() throw(pvpException) {
  pvpAccess a = accessPpIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PP_INDEX");
    return x;
  } else {
    throw pvpException("PP_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::maxPpIndex() throw(pvpException) {
  pvpAccess a = accessPpIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PP_INDEX");
    return x;
  } else {
    throw pvpException("PP_INDEX not accessible for reading");
  }
}

void pvpCamera::setPpIndex(int16_t x) throw(pvpException) {
  pvpAccess a = accessPpIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_PP_INDEX,(void*)(&y)))
      throw pvpException("Cannot set PP_INDEX");
  }
}

void pvpCamera::reportPpIndex() throw(pvpException) {
  if (availPpIndex()) {
    pvpAccess a = accessPpIndex();
    printf("PpIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpIndex() <<"\n";
        ss << "  min value: " << minPpIndex() <<"\n";
        ss << "  max value: " << maxPpIndex() <<"\n";
        ss << "  default value: " << defaultPpIndex() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpIndex());
  } else {
    printf("PpIndex is not available.\n");
  }
}

bool pvpCamera::availActualGain() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ACTUAL_GAIN availability");
  return avail;
}

pvpAccess pvpCamera::accessActualGain() throw(pvpException) {
  uns16 access;
  if (!availActualGain())
    throw pvpException("ACTUAL_GAIN not available");
  if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ACTUAL_GAIN accessibility");
  return pvpAccess(access);
}

int pvpCamera::countActualGain() throw(pvpException) {
  uns32 count;
  if (!availActualGain())
    throw pvpException("ACTUAL_GAIN not available");
  if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_COUNT,&count))
    throw pvpException("Cannot get ACTUAL_GAIN count");
  return count;
}

uint16_t pvpCamera::getActualGain() throw(pvpException) {
  pvpAccess a = accessActualGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ACTUAL_GAIN");
    return x;
  } else {
    throw pvpException("ACTUAL_GAIN not accessible for reading");
  }
}

uint16_t pvpCamera::defaultActualGain() throw(pvpException) {
  pvpAccess a = accessActualGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ACTUAL_GAIN");
    return x;
  } else {
    throw pvpException("ACTUAL_GAIN not accessible for reading");
  }
}

uint16_t pvpCamera::minActualGain() throw(pvpException) {
  pvpAccess a = accessActualGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ACTUAL_GAIN");
    return x;
  } else {
    throw pvpException("ACTUAL_GAIN not accessible for reading");
  }
}

uint16_t pvpCamera::maxActualGain() throw(pvpException) {
  pvpAccess a = accessActualGain();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ACTUAL_GAIN,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ACTUAL_GAIN");
    return x;
  } else {
    throw pvpException("ACTUAL_GAIN not accessible for reading");
  }
}

void pvpCamera::setActualGain(uint16_t x) throw(pvpException) {
  pvpAccess a = accessActualGain();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_ACTUAL_GAIN,(void*)(&y)))
      throw pvpException("Cannot set ACTUAL_GAIN");
  }
}

void pvpCamera::reportActualGain() throw(pvpException) {
  if (availActualGain()) {
    pvpAccess a = accessActualGain();
    printf("ActualGain: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getActualGain() <<"\n";
        ss << "  min value: " << minActualGain() <<"\n";
        ss << "  max value: " << maxActualGain() <<"\n";
        ss << "  default value: " << defaultActualGain() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countActualGain());
  } else {
    printf("ActualGain is not available.\n");
  }
}

bool pvpCamera::availPpParamIndex() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_PARAM_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessPpParamIndex() throw(pvpException) {
  uns16 access;
  if (!availPpParamIndex())
    throw pvpException("PP_PARAM_INDEX not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_PARAM_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpParamIndex() throw(pvpException) {
  uns32 count;
  if (!availPpParamIndex())
    throw pvpException("PP_PARAM_INDEX not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_PARAM_INDEX count");
  return count;
}

int16_t pvpCamera::getPpParamIndex() throw(pvpException) {
  pvpAccess a = accessPpParamIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PP_PARAM_INDEX");
    return x;
  } else {
    throw pvpException("PP_PARAM_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::defaultPpParamIndex() throw(pvpException) {
  pvpAccess a = accessPpParamIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PP_PARAM_INDEX");
    return x;
  } else {
    throw pvpException("PP_PARAM_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::minPpParamIndex() throw(pvpException) {
  pvpAccess a = accessPpParamIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PP_PARAM_INDEX");
    return x;
  } else {
    throw pvpException("PP_PARAM_INDEX not accessible for reading");
  }
}

int16_t pvpCamera::maxPpParamIndex() throw(pvpException) {
  pvpAccess a = accessPpParamIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PP_PARAM_INDEX");
    return x;
  } else {
    throw pvpException("PP_PARAM_INDEX not accessible for reading");
  }
}

void pvpCamera::setPpParamIndex(int16_t x) throw(pvpException) {
  pvpAccess a = accessPpParamIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_PP_PARAM_INDEX,(void*)(&y)))
      throw pvpException("Cannot set PP_PARAM_INDEX");
  }
}

void pvpCamera::reportPpParamIndex() throw(pvpException) {
  if (availPpParamIndex()) {
    pvpAccess a = accessPpParamIndex();
    printf("PpParamIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpParamIndex() <<"\n";
        ss << "  min value: " << minPpParamIndex() <<"\n";
        ss << "  max value: " << maxPpParamIndex() <<"\n";
        ss << "  default value: " << defaultPpParamIndex() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpParamIndex());
  } else {
    printf("PpParamIndex is not available.\n");
  }
}

bool pvpCamera::availPpParamName() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_PARAM_NAME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_PARAM_NAME availability");
  return avail;
}

pvpAccess pvpCamera::accessPpParamName() throw(pvpException) {
  uns16 access;
  if (!availPpParamName())
    throw pvpException("PP_PARAM_NAME not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM_NAME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_PARAM_NAME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpParamName() throw(pvpException) {
  uns32 count;
  if (!availPpParamName())
    throw pvpException("PP_PARAM_NAME not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM_NAME,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_PARAM_NAME count");
  return count;
}

QString pvpCamera::getPpParamName() throw(pvpException) {
  pvpAccess a = accessPpParamName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(countPpParamName(), 0);
    if (!pl_get_param(camh,PARAM_PP_PARAM_NAME,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read PP_PARAM_NAME");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("PP_PARAM_NAME not accessible for reading");
  }
}

QString pvpCamera::defaultPpParamName() throw(pvpException) {
  pvpAccess a = accessPpParamName();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char x[countPpParamName()];
    if (!pl_get_param(camh,PARAM_PP_PARAM_NAME,ATTR_DEFAULT,x))
      throw pvpException("Cannot read default of PP_PARAM_NAME");
    return x;
  } else {
    throw pvpException("PP_PARAM_NAME not accessible for reading");
  }
}

QString pvpCamera::minPpParamName() throw(pvpException) {
    return "";
}

QString pvpCamera::maxPpParamName() throw(pvpException) {
    return "";
}

void pvpCamera::setPpParamName(QString x) throw(pvpException) {
  pvpAccess a = accessPpParamName();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_PP_PARAM_NAME,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set PP_PARAM_NAME");
  }
}

void pvpCamera::reportPpParamName() throw(pvpException) {
  if (availPpParamName()) {
    pvpAccess a = accessPpParamName();
    printf("PpParamName: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpParamName() <<"\n";
        ss << "  min value: " << minPpParamName() <<"\n";
        ss << "  max value: " << maxPpParamName() <<"\n";
        ss << "  default value: " << defaultPpParamName() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpParamName());
  } else {
    printf("PpParamName is not available.\n");
  }
}

bool pvpCamera::availPpParam() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_PARAM availability");
  return avail;
}

pvpAccess pvpCamera::accessPpParam() throw(pvpException) {
  uns16 access;
  if (!availPpParam())
    throw pvpException("PP_PARAM not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_PARAM accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpParam() throw(pvpException) {
  uns32 count;
  if (!availPpParam())
    throw pvpException("PP_PARAM not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_PARAM count");
  return count;
}

uint32_t pvpCamera::getPpParam() throw(pvpException) {
  pvpAccess a = accessPpParam();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PP_PARAM");
    return x;
  } else {
    throw pvpException("PP_PARAM not accessible for reading");
  }
}

uint32_t pvpCamera::defaultPpParam() throw(pvpException) {
  pvpAccess a = accessPpParam();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PP_PARAM");
    return x;
  } else {
    throw pvpException("PP_PARAM not accessible for reading");
  }
}

uint32_t pvpCamera::minPpParam() throw(pvpException) {
  pvpAccess a = accessPpParam();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PP_PARAM");
    return x;
  } else {
    throw pvpException("PP_PARAM not accessible for reading");
  }
}

uint32_t pvpCamera::maxPpParam() throw(pvpException) {
  pvpAccess a = accessPpParam();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PP_PARAM");
    return x;
  } else {
    throw pvpException("PP_PARAM not accessible for reading");
  }
}

void pvpCamera::setPpParam(uint32_t x) throw(pvpException) {
  pvpAccess a = accessPpParam();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint32_t y = x;
    if (!pl_set_param(camh,PARAM_PP_PARAM,(void*)(&y)))
      throw pvpException("Cannot set PP_PARAM");
  }
}

void pvpCamera::reportPpParam() throw(pvpException) {
  if (availPpParam()) {
    pvpAccess a = accessPpParam();
    printf("PpParam: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpParam() <<"\n";
        ss << "  min value: " << minPpParam() <<"\n";
        ss << "  max value: " << maxPpParam() <<"\n";
        ss << "  default value: " << defaultPpParam() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpParam());
  } else {
    printf("PpParam is not available.\n");
  }
}

bool pvpCamera::availReadNoise() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get READ_NOISE availability");
  return avail;
}

pvpAccess pvpCamera::accessReadNoise() throw(pvpException) {
  uns16 access;
  if (!availReadNoise())
    throw pvpException("READ_NOISE not available");
  if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get READ_NOISE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countReadNoise() throw(pvpException) {
  uns32 count;
  if (!availReadNoise())
    throw pvpException("READ_NOISE not available");
  if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_COUNT,&count))
    throw pvpException("Cannot get READ_NOISE count");
  return count;
}

uint16_t pvpCamera::getReadNoise() throw(pvpException) {
  pvpAccess a = accessReadNoise();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read READ_NOISE");
    return x;
  } else {
    throw pvpException("READ_NOISE not accessible for reading");
  }
}

uint16_t pvpCamera::defaultReadNoise() throw(pvpException) {
  pvpAccess a = accessReadNoise();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of READ_NOISE");
    return x;
  } else {
    throw pvpException("READ_NOISE not accessible for reading");
  }
}

uint16_t pvpCamera::minReadNoise() throw(pvpException) {
  pvpAccess a = accessReadNoise();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of READ_NOISE");
    return x;
  } else {
    throw pvpException("READ_NOISE not accessible for reading");
  }
}

uint16_t pvpCamera::maxReadNoise() throw(pvpException) {
  pvpAccess a = accessReadNoise();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_READ_NOISE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of READ_NOISE");
    return x;
  } else {
    throw pvpException("READ_NOISE not accessible for reading");
  }
}

void pvpCamera::setReadNoise(uint16_t x) throw(pvpException) {
  pvpAccess a = accessReadNoise();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_READ_NOISE,(void*)(&y)))
      throw pvpException("Cannot set READ_NOISE");
  }
}

void pvpCamera::reportReadNoise() throw(pvpException) {
  if (availReadNoise()) {
    pvpAccess a = accessReadNoise();
    printf("ReadNoise: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getReadNoise() <<"\n";
        ss << "  min value: " << minReadNoise() <<"\n";
        ss << "  max value: " << maxReadNoise() <<"\n";
        ss << "  default value: " << defaultReadNoise() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countReadNoise());
  } else {
    printf("ReadNoise is not available.\n");
  }
}

bool pvpCamera::availPpFeatId() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_FEAT_ID availability");
  return avail;
}

pvpAccess pvpCamera::accessPpFeatId() throw(pvpException) {
  uns16 access;
  if (!availPpFeatId())
    throw pvpException("PP_FEAT_ID not available");
  if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_FEAT_ID accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpFeatId() throw(pvpException) {
  uns32 count;
  if (!availPpFeatId())
    throw pvpException("PP_FEAT_ID not available");
  if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_FEAT_ID count");
  return count;
}

uint16_t pvpCamera::getPpFeatId() throw(pvpException) {
  pvpAccess a = accessPpFeatId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PP_FEAT_ID");
    return x;
  } else {
    throw pvpException("PP_FEAT_ID not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPpFeatId() throw(pvpException) {
  pvpAccess a = accessPpFeatId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PP_FEAT_ID");
    return x;
  } else {
    throw pvpException("PP_FEAT_ID not accessible for reading");
  }
}

uint16_t pvpCamera::minPpFeatId() throw(pvpException) {
  pvpAccess a = accessPpFeatId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PP_FEAT_ID");
    return x;
  } else {
    throw pvpException("PP_FEAT_ID not accessible for reading");
  }
}

uint16_t pvpCamera::maxPpFeatId() throw(pvpException) {
  pvpAccess a = accessPpFeatId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_FEAT_ID,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PP_FEAT_ID");
    return x;
  } else {
    throw pvpException("PP_FEAT_ID not accessible for reading");
  }
}

void pvpCamera::setPpFeatId(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPpFeatId();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PP_FEAT_ID,(void*)(&y)))
      throw pvpException("Cannot set PP_FEAT_ID");
  }
}

void pvpCamera::reportPpFeatId() throw(pvpException) {
  if (availPpFeatId()) {
    pvpAccess a = accessPpFeatId();
    printf("PpFeatId: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpFeatId() <<"\n";
        ss << "  min value: " << minPpFeatId() <<"\n";
        ss << "  max value: " << maxPpFeatId() <<"\n";
        ss << "  default value: " << defaultPpFeatId() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpFeatId());
  } else {
    printf("PpFeatId is not available.\n");
  }
}

bool pvpCamera::availPpParamId() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get PP_PARAM_ID availability");
  return avail;
}

pvpAccess pvpCamera::accessPpParamId() throw(pvpException) {
  uns16 access;
  if (!availPpParamId())
    throw pvpException("PP_PARAM_ID not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_ACCESS,&access))
    throw pvpException("Cannot get PP_PARAM_ID accessibility");
  return pvpAccess(access);
}

int pvpCamera::countPpParamId() throw(pvpException) {
  uns32 count;
  if (!availPpParamId())
    throw pvpException("PP_PARAM_ID not available");
  if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_COUNT,&count))
    throw pvpException("Cannot get PP_PARAM_ID count");
  return count;
}

uint16_t pvpCamera::getPpParamId() throw(pvpException) {
  pvpAccess a = accessPpParamId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_CURRENT,&x))
      throw pvpException("Cannot read PP_PARAM_ID");
    return x;
  } else {
    throw pvpException("PP_PARAM_ID not accessible for reading");
  }
}

uint16_t pvpCamera::defaultPpParamId() throw(pvpException) {
  pvpAccess a = accessPpParamId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of PP_PARAM_ID");
    return x;
  } else {
    throw pvpException("PP_PARAM_ID not accessible for reading");
  }
}

uint16_t pvpCamera::minPpParamId() throw(pvpException) {
  pvpAccess a = accessPpParamId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_MIN,&x))
      throw pvpException("Cannot read min of PP_PARAM_ID");
    return x;
  } else {
    throw pvpException("PP_PARAM_ID not accessible for reading");
  }
}

uint16_t pvpCamera::maxPpParamId() throw(pvpException) {
  pvpAccess a = accessPpParamId();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_PP_PARAM_ID,ATTR_MAX,&x))
      throw pvpException("Cannot read max of PP_PARAM_ID");
    return x;
  } else {
    throw pvpException("PP_PARAM_ID not accessible for reading");
  }
}

void pvpCamera::setPpParamId(uint16_t x) throw(pvpException) {
  pvpAccess a = accessPpParamId();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_PP_PARAM_ID,(void*)(&y)))
      throw pvpException("Cannot set PP_PARAM_ID");
  }
}

void pvpCamera::reportPpParamId() throw(pvpException) {
  if (availPpParamId()) {
    pvpAccess a = accessPpParamId();
    printf("PpParamId: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getPpParamId() <<"\n";
        ss << "  min value: " << minPpParamId() <<"\n";
        ss << "  max value: " << maxPpParamId() <<"\n";
        ss << "  default value: " << defaultPpParamId() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countPpParamId());
  } else {
    printf("PpParamId is not available.\n");
  }
}

bool pvpCamera::availSmartStreamModeEnabled() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SMART_STREAM_MODE_ENABLED availability");
  return avail;
}

pvpAccess pvpCamera::accessSmartStreamModeEnabled() throw(pvpException) {
  uns16 access;
  if (!availSmartStreamModeEnabled())
    throw pvpException("SMART_STREAM_MODE_ENABLED not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SMART_STREAM_MODE_ENABLED accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSmartStreamModeEnabled() throw(pvpException) {
  uns32 count;
  if (!availSmartStreamModeEnabled())
    throw pvpException("SMART_STREAM_MODE_ENABLED not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_COUNT,&count))
    throw pvpException("Cannot get SMART_STREAM_MODE_ENABLED count");
  return count;
}

bool pvpCamera::getSmartStreamModeEnabled() throw(pvpException) {
  pvpAccess a = accessSmartStreamModeEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SMART_STREAM_MODE_ENABLED");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE_ENABLED not accessible for reading");
  }
}

bool pvpCamera::defaultSmartStreamModeEnabled() throw(pvpException) {
  pvpAccess a = accessSmartStreamModeEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SMART_STREAM_MODE_ENABLED");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE_ENABLED not accessible for reading");
  }
}

bool pvpCamera::minSmartStreamModeEnabled() throw(pvpException) {
  pvpAccess a = accessSmartStreamModeEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SMART_STREAM_MODE_ENABLED");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE_ENABLED not accessible for reading");
  }
}

bool pvpCamera::maxSmartStreamModeEnabled() throw(pvpException) {
  pvpAccess a = accessSmartStreamModeEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    bool x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SMART_STREAM_MODE_ENABLED");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE_ENABLED not accessible for reading");
  }
}

void pvpCamera::setSmartStreamModeEnabled(bool x) throw(pvpException) {
  pvpAccess a = accessSmartStreamModeEnabled();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    bool y = x;
    if (!pl_set_param(camh,PARAM_SMART_STREAM_MODE_ENABLED,(void*)(&y)))
      throw pvpException("Cannot set SMART_STREAM_MODE_ENABLED");
  }
}

void pvpCamera::reportSmartStreamModeEnabled() throw(pvpException) {
  if (availSmartStreamModeEnabled()) {
    pvpAccess a = accessSmartStreamModeEnabled();
    printf("SmartStreamModeEnabled: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSmartStreamModeEnabled() <<"\n";
        ss << "  min value: " << minSmartStreamModeEnabled() <<"\n";
        ss << "  max value: " << maxSmartStreamModeEnabled() <<"\n";
        ss << "  default value: " << defaultSmartStreamModeEnabled() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSmartStreamModeEnabled());
  } else {
    printf("SmartStreamModeEnabled is not available.\n");
  }
}

bool pvpCamera::availSmartStreamMode() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SMART_STREAM_MODE availability");
  return avail;
}

pvpAccess pvpCamera::accessSmartStreamMode() throw(pvpException) {
  uns16 access;
  if (!availSmartStreamMode())
    throw pvpException("SMART_STREAM_MODE not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SMART_STREAM_MODE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSmartStreamMode() throw(pvpException) {
  uns32 count;
  if (!availSmartStreamMode())
    throw pvpException("SMART_STREAM_MODE not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_COUNT,&count))
    throw pvpException("Cannot get SMART_STREAM_MODE count");
  return count;
}

uint16_t pvpCamera::getSmartStreamMode() throw(pvpException) {
  pvpAccess a = accessSmartStreamMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SMART_STREAM_MODE");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE not accessible for reading");
  }
}

uint16_t pvpCamera::defaultSmartStreamMode() throw(pvpException) {
  pvpAccess a = accessSmartStreamMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SMART_STREAM_MODE");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE not accessible for reading");
  }
}

uint16_t pvpCamera::minSmartStreamMode() throw(pvpException) {
  pvpAccess a = accessSmartStreamMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SMART_STREAM_MODE");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE not accessible for reading");
  }
}

uint16_t pvpCamera::maxSmartStreamMode() throw(pvpException) {
  pvpAccess a = accessSmartStreamMode();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_MODE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SMART_STREAM_MODE");
    return x;
  } else {
    throw pvpException("SMART_STREAM_MODE not accessible for reading");
  }
}

void pvpCamera::setSmartStreamMode(uint16_t x) throw(pvpException) {
  pvpAccess a = accessSmartStreamMode();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_SMART_STREAM_MODE,(void*)(&y)))
      throw pvpException("Cannot set SMART_STREAM_MODE");
  }
}

void pvpCamera::reportSmartStreamMode() throw(pvpException) {
  if (availSmartStreamMode()) {
    pvpAccess a = accessSmartStreamMode();
    printf("SmartStreamMode: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSmartStreamMode() <<"\n";
        ss << "  min value: " << minSmartStreamMode() <<"\n";
        ss << "  max value: " << maxSmartStreamMode() <<"\n";
        ss << "  default value: " << defaultSmartStreamMode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSmartStreamMode());
  } else {
    printf("SmartStreamMode is not available.\n");
  }
}

bool pvpCamera::availSmartStreamExpParams() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SMART_STREAM_EXP_PARAMS availability");
  return avail;
}

pvpAccess pvpCamera::accessSmartStreamExpParams() throw(pvpException) {
  uns16 access;
  if (!availSmartStreamExpParams())
    throw pvpException("SMART_STREAM_EXP_PARAMS not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SMART_STREAM_EXP_PARAMS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSmartStreamExpParams() throw(pvpException) {
  uns32 count;
  if (!availSmartStreamExpParams())
    throw pvpException("SMART_STREAM_EXP_PARAMS not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_COUNT,&count))
    throw pvpException("Cannot get SMART_STREAM_EXP_PARAMS count");
  return count;
}

void * pvpCamera::getSmartStreamExpParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamExpParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SMART_STREAM_EXP_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_EXP_PARAMS not accessible for reading");
  }
}

void * pvpCamera::defaultSmartStreamExpParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamExpParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SMART_STREAM_EXP_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_EXP_PARAMS not accessible for reading");
  }
}

void * pvpCamera::minSmartStreamExpParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamExpParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SMART_STREAM_EXP_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_EXP_PARAMS not accessible for reading");
  }
}

void * pvpCamera::maxSmartStreamExpParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamExpParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SMART_STREAM_EXP_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_EXP_PARAMS not accessible for reading");
  }
}

void pvpCamera::setSmartStreamExpParams(void * x) throw(pvpException) {
  pvpAccess a = accessSmartStreamExpParams();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    void * y = x;
    if (!pl_set_param(camh,PARAM_SMART_STREAM_EXP_PARAMS,(void*)(&y)))
      throw pvpException("Cannot set SMART_STREAM_EXP_PARAMS");
  }
}

void pvpCamera::reportSmartStreamExpParams() throw(pvpException) {
  if (availSmartStreamExpParams()) {
    pvpAccess a = accessSmartStreamExpParams();
    printf("SmartStreamExpParams: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSmartStreamExpParams() <<"\n";
        ss << "  min value: " << minSmartStreamExpParams() <<"\n";
        ss << "  max value: " << maxSmartStreamExpParams() <<"\n";
        ss << "  default value: " << defaultSmartStreamExpParams() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSmartStreamExpParams());
  } else {
    printf("SmartStreamExpParams is not available.\n");
  }
}

bool pvpCamera::availSmartStreamDlyParams() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get SMART_STREAM_DLY_PARAMS availability");
  return avail;
}

pvpAccess pvpCamera::accessSmartStreamDlyParams() throw(pvpException) {
  uns16 access;
  if (!availSmartStreamDlyParams())
    throw pvpException("SMART_STREAM_DLY_PARAMS not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get SMART_STREAM_DLY_PARAMS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countSmartStreamDlyParams() throw(pvpException) {
  uns32 count;
  if (!availSmartStreamDlyParams())
    throw pvpException("SMART_STREAM_DLY_PARAMS not available");
  if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_COUNT,&count))
    throw pvpException("Cannot get SMART_STREAM_DLY_PARAMS count");
  return count;
}

void * pvpCamera::getSmartStreamDlyParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamDlyParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read SMART_STREAM_DLY_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_DLY_PARAMS not accessible for reading");
  }
}

void * pvpCamera::defaultSmartStreamDlyParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamDlyParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of SMART_STREAM_DLY_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_DLY_PARAMS not accessible for reading");
  }
}

void * pvpCamera::minSmartStreamDlyParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamDlyParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of SMART_STREAM_DLY_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_DLY_PARAMS not accessible for reading");
  }
}

void * pvpCamera::maxSmartStreamDlyParams() throw(pvpException) {
  pvpAccess a = accessSmartStreamDlyParams();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    void * x;
    if (!pl_get_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of SMART_STREAM_DLY_PARAMS");
    return x;
  } else {
    throw pvpException("SMART_STREAM_DLY_PARAMS not accessible for reading");
  }
}

void pvpCamera::setSmartStreamDlyParams(void * x) throw(pvpException) {
  pvpAccess a = accessSmartStreamDlyParams();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    void * y = x;
    if (!pl_set_param(camh,PARAM_SMART_STREAM_DLY_PARAMS,(void*)(&y)))
      throw pvpException("Cannot set SMART_STREAM_DLY_PARAMS");
  }
}

void pvpCamera::reportSmartStreamDlyParams() throw(pvpException) {
  if (availSmartStreamDlyParams()) {
    pvpAccess a = accessSmartStreamDlyParams();
    printf("SmartStreamDlyParams: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getSmartStreamDlyParams() <<"\n";
        ss << "  min value: " << minSmartStreamDlyParams() <<"\n";
        ss << "  max value: " << maxSmartStreamDlyParams() <<"\n";
        ss << "  default value: " << defaultSmartStreamDlyParams() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countSmartStreamDlyParams());
  } else {
    printf("SmartStreamDlyParams is not available.\n");
  }
}

void pvpCamera::reportClass2() throw(pvpException) {
  reportAdcOffset();
  reportChipName();
  reportSystemName();
  reportVendorName();
  reportProductName();
  reportCameraPartNumber();
  reportCoolingMode();
  reportPreampDelay();
  reportColorMode();
  reportMppCapable();
  reportPreampOffControl();
  reportPremask();
  reportPrescan();
  reportPostmask();
  reportPostscan();
  reportPixParDist();
  reportPixParSize();
  reportPixSerDist();
  reportPixSerSize();
  reportSummingWell();
  reportFwellCapacity();
  reportParSize();
  reportSerSize();
  reportAccumCapable();
  reportFlashDwnldCapable();
  reportReadoutTime();
  reportClearCycles();
  reportClearMode();
  reportFrameCapable();
  reportPmode();
  reportTemp();
  reportTempSetpoint();
  reportCamFwVersion();
  reportHeadSerNumAlpha();
  reportPciFwVersion();
  reportFanSpeedSetpoint();
  reportExposureMode();
  reportExposeOutMode();
  reportBitDepth();
  reportGainIndex();
  reportSpdtabIndex();
  reportGainName();
  reportReadoutPort();
  reportPixTime();
  reportShtrCloseDelay();
  reportShtrOpenDelay();
  reportShtrOpenMode();
  reportShtrStatus();
  reportIoAddr();
  reportIoType();
  reportIoDirection();
  reportIoState();
  reportIoBitdepth();
  reportGainMultFactor();
  reportGainMultEnable();
  reportPpFeatName();
  reportPpIndex();
  reportActualGain();
  reportPpParamIndex();
  reportPpParamName();
  reportPpParam();
  reportReadNoise();
  reportPpFeatId();
  reportPpParamId();
  reportSmartStreamModeEnabled();
  reportSmartStreamMode();
  reportSmartStreamExpParams();
  reportSmartStreamDlyParams();
}


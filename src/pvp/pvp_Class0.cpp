// pvp_Class0.cpp - generated by pvcam2param.pl. Do not Edit.

#include <pvp/pvpCamera.h>
#include <QTextStream>
#include <pvp/dwpvcam.h>

bool pvpCamera::availDdInfoLength() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_INFO_LENGTH availability");
  return avail;
}

pvpAccess pvpCamera::accessDdInfoLength() throw(pvpException) {
  uns16 access;
  if (!availDdInfoLength())
    throw pvpException("DD_INFO_LENGTH not available");
  if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_INFO_LENGTH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdInfoLength() throw(pvpException) {
  uns32 count;
  if (!availDdInfoLength())
    throw pvpException("DD_INFO_LENGTH not available");
  if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_INFO_LENGTH count");
  return count;
}

int16_t pvpCamera::getDdInfoLength() throw(pvpException) {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

int16_t pvpCamera::defaultDdInfoLength() throw(pvpException) {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

int16_t pvpCamera::minDdInfoLength() throw(pvpException) {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

int16_t pvpCamera::maxDdInfoLength() throw(pvpException) {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16 x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

void pvpCamera::setDdInfoLength(int16_t x) throw(pvpException) {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16 y = x;
    if (!pl_set_param(camh,PARAM_DD_INFO_LENGTH,(void*)(&y)))
      throw pvpException("Cannot set DD_INFO_LENGTH");
  }
}

void pvpCamera::reportDdInfoLength() throw(pvpException) {
  if (availDdInfoLength()) {
    pvpAccess a = accessDdInfoLength();
    printf("DdInfoLength: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getDdInfoLength() <<"\n";
        ss << "  min value: " << minDdInfoLength() <<"\n";
        ss << "  max value: " << maxDdInfoLength() <<"\n";
        ss << "  default value: " << defaultDdInfoLength() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countDdInfoLength());
  } else {
    printf("DdInfoLength is not available.\n");
  }
}

bool pvpCamera::availDdVersion() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessDdVersion() throw(pvpException) {
  uns16 access;
  if (!availDdVersion())
    throw pvpException("DD_VERSION not available");
  if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdVersion() throw(pvpException) {
  uns32 count;
  if (!availDdVersion())
    throw pvpException("DD_VERSION not available");
  if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_VERSION count");
  return count;
}

uint16_t pvpCamera::getDdVersion() throw(pvpException) {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::defaultDdVersion() throw(pvpException) {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::minDdVersion() throw(pvpException) {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::maxDdVersion() throw(pvpException) {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

void pvpCamera::setDdVersion(uint16_t x) throw(pvpException) {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_DD_VERSION,(void*)(&y)))
      throw pvpException("Cannot set DD_VERSION");
  }
}

void pvpCamera::reportDdVersion() throw(pvpException) {
  if (availDdVersion()) {
    pvpAccess a = accessDdVersion();
    printf("DdVersion: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getDdVersion() <<"\n";
        ss << "  min value: " << minDdVersion() <<"\n";
        ss << "  max value: " << maxDdVersion() <<"\n";
        ss << "  default value: " << defaultDdVersion() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countDdVersion());
  } else {
    printf("DdVersion is not available.\n");
  }
}

bool pvpCamera::availDdRetries() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_RETRIES availability");
  return avail;
}

pvpAccess pvpCamera::accessDdRetries() throw(pvpException) {
  uns16 access;
  if (!availDdRetries())
    throw pvpException("DD_RETRIES not available");
  if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_RETRIES accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdRetries() throw(pvpException) {
  uns32 count;
  if (!availDdRetries())
    throw pvpException("DD_RETRIES not available");
  if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_RETRIES count");
  return count;
}

uint16_t pvpCamera::getDdRetries() throw(pvpException) {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

uint16_t pvpCamera::defaultDdRetries() throw(pvpException) {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

uint16_t pvpCamera::minDdRetries() throw(pvpException) {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

uint16_t pvpCamera::maxDdRetries() throw(pvpException) {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

void pvpCamera::setDdRetries(uint16_t x) throw(pvpException) {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_DD_RETRIES,(void*)(&y)))
      throw pvpException("Cannot set DD_RETRIES");
  }
}

void pvpCamera::reportDdRetries() throw(pvpException) {
  if (availDdRetries()) {
    pvpAccess a = accessDdRetries();
    printf("DdRetries: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getDdRetries() <<"\n";
        ss << "  min value: " << minDdRetries() <<"\n";
        ss << "  max value: " << maxDdRetries() <<"\n";
        ss << "  default value: " << defaultDdRetries() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countDdRetries());
  } else {
    printf("DdRetries is not available.\n");
  }
}

bool pvpCamera::availDdTimeout() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_TIMEOUT availability");
  return avail;
}

pvpAccess pvpCamera::accessDdTimeout() throw(pvpException) {
  uns16 access;
  if (!availDdTimeout())
    throw pvpException("DD_TIMEOUT not available");
  if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_TIMEOUT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdTimeout() throw(pvpException) {
  uns32 count;
  if (!availDdTimeout())
    throw pvpException("DD_TIMEOUT not available");
  if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_TIMEOUT count");
  return count;
}

uint16_t pvpCamera::getDdTimeout() throw(pvpException) {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

uint16_t pvpCamera::defaultDdTimeout() throw(pvpException) {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

uint16_t pvpCamera::minDdTimeout() throw(pvpException) {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

uint16_t pvpCamera::maxDdTimeout() throw(pvpException) {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns16 x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

void pvpCamera::setDdTimeout(uint16_t x) throw(pvpException) {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns16 y = x;
    if (!pl_set_param(camh,PARAM_DD_TIMEOUT,(void*)(&y)))
      throw pvpException("Cannot set DD_TIMEOUT");
  }
}

void pvpCamera::reportDdTimeout() throw(pvpException) {
  if (availDdTimeout()) {
    pvpAccess a = accessDdTimeout();
    printf("DdTimeout: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getDdTimeout() <<"\n";
        ss << "  min value: " << minDdTimeout() <<"\n";
        ss << "  max value: " << maxDdTimeout() <<"\n";
        ss << "  default value: " << defaultDdTimeout() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countDdTimeout());
  } else {
    printf("DdTimeout is not available.\n");
  }
}

bool pvpCamera::availDdInfo() throw(pvpException) {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_INFO availability");
  return avail;
}

pvpAccess pvpCamera::accessDdInfo() throw(pvpException) {
  uns16 access;
  if (!availDdInfo())
    throw pvpException("DD_INFO not available");
  if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_INFO accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdInfo() throw(pvpException) {
  uns32 count;
  if (!availDdInfo())
    throw pvpException("DD_INFO not available");
  if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_INFO count");
  return count;
}

char * pvpCamera::getDdInfo() throw(pvpException) {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char_ptr x;
    if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_INFO");
    return x;
  } else {
    throw pvpException("DD_INFO not accessible for reading");
  }
}

char * pvpCamera::defaultDdInfo() throw(pvpException) {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char_ptr x;
    if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_INFO");
    return x;
  } else {
    throw pvpException("DD_INFO not accessible for reading");
  }
}

char * pvpCamera::minDdInfo() throw(pvpException) {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char_ptr x;
    if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_INFO");
    return x;
  } else {
    throw pvpException("DD_INFO not accessible for reading");
  }
}

char * pvpCamera::maxDdInfo() throw(pvpException) {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    char_ptr x;
    if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_INFO");
    return x;
  } else {
    throw pvpException("DD_INFO not accessible for reading");
  }
}

void pvpCamera::setDdInfo(char * x) throw(pvpException) {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    char_ptr y = x;
    if (!pl_set_param(camh,PARAM_DD_INFO,(void*)(&y)))
      throw pvpException("Cannot set DD_INFO");
  }
}

void pvpCamera::reportDdInfo() throw(pvpException) {
  if (availDdInfo()) {
    pvpAccess a = accessDdInfo();
    printf("DdInfo: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getDdInfo() <<"\n";
        ss << "  min value: " << minDdInfo() <<"\n";
        ss << "  max value: " << maxDdInfo() <<"\n";
        ss << "  default value: " << defaultDdInfo() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countDdInfo());
  } else {
    printf("DdInfo is not available.\n");
  }
}

void pvpCamera::reportClass0() throw(pvpException) {
  reportDdInfoLength();
  reportDdVersion();
  reportDdRetries();
  reportDdTimeout();
  reportDdInfo();
}


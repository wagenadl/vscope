// pvp/pvp_Class0.cpp - This file is part of VScope.
// (C) Daniel Wagenaar 2008-1017.
/* VScope is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   VScope is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with VScope.  If not, see <http://www.gnu.org/licenses/>.
*/

// pvp_Class0.cpp - generated by pvcam2param.pl. Do not Edit.

#include <pvp/pvpCamera.h>
#include <QTextStream>
#include <pvp/dwpvcam.h>

bool pvpCamera::availDdInfoLength() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_INFO_LENGTH availability");
  return avail;
}

pvpAccess pvpCamera::accessDdInfoLength() /*throw(pvpException)*/ {
  uns16 access;
  if (!availDdInfoLength())
    throw pvpException("DD_INFO_LENGTH not available");
  if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_INFO_LENGTH accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdInfoLength() /*throw(pvpException)*/ {
  uns32 count;
  if (!availDdInfoLength())
    throw pvpException("DD_INFO_LENGTH not available");
  if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_INFO_LENGTH count");
  return count;
}

int16_t pvpCamera::getDdInfoLength() /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

int16_t pvpCamera::defaultDdInfoLength() /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

int16_t pvpCamera::minDdInfoLength() /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

int16_t pvpCamera::maxDdInfoLength() /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    int16_t x;
    if (!pl_get_param(camh,PARAM_DD_INFO_LENGTH,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_INFO_LENGTH");
    return x;
  } else {
    throw pvpException("DD_INFO_LENGTH not accessible for reading");
  }
}

void pvpCamera::setDdInfoLength(int16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfoLength();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    int16_t y = x;
    if (!pl_set_param(camh,PARAM_DD_INFO_LENGTH,(void*)(&y)))
      throw pvpException("Cannot set DD_INFO_LENGTH");
  }
}

void pvpCamera::reportDdInfoLength() /*throw(pvpException)*/ {
  if (availDdInfoLength()) {
    try {
      pvpAccess a = accessDdInfoLength();
      printf("DdInfoLength: %s\n",a.decode());
      if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
        QString s;
        { QTextStream ss(&s);
          ss << "  current value: " << getDdInfoLength() <<"\n";
          ss << "  min value: " << minDdInfoLength() <<"\n";
          ss << "  max value: " << maxDdInfoLength() <<"\n";
          ss << "  default value: " << defaultDdInfoLength() <<"\n";
        }
        printf("%s",s.toUtf8().data());
      }
    } catch (pvpException) {
       printf("DdInfoLength: Could not read\n");
    }
    try {
      printf("  count: %i\n",countDdInfoLength());
    } catch (pvpException) {
      printf("DdInfoLength: Could not count\n");
    }
  } else {
    printf("DdInfoLength is not available.\n");
  }
}

bool pvpCamera::availDdVersion() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_VERSION availability");
  return avail;
}

pvpAccess pvpCamera::accessDdVersion() /*throw(pvpException)*/ {
  uns16 access;
  if (!availDdVersion())
    throw pvpException("DD_VERSION not available");
  if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_VERSION accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdVersion() /*throw(pvpException)*/ {
  uns32 count;
  if (!availDdVersion())
    throw pvpException("DD_VERSION not available");
  if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_VERSION count");
  return count;
}

uint16_t pvpCamera::getDdVersion() /*throw(pvpException)*/ {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::defaultDdVersion() /*throw(pvpException)*/ {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::minDdVersion() /*throw(pvpException)*/ {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

uint16_t pvpCamera::maxDdVersion() /*throw(pvpException)*/ {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_VERSION,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_VERSION");
    return x;
  } else {
    throw pvpException("DD_VERSION not accessible for reading");
  }
}

void pvpCamera::setDdVersion(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessDdVersion();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_DD_VERSION,(void*)(&y)))
      throw pvpException("Cannot set DD_VERSION");
  }
}

void pvpCamera::reportDdVersion() /*throw(pvpException)*/ {
  if (availDdVersion()) {
    try {
      pvpAccess a = accessDdVersion();
      printf("DdVersion: %s\n",a.decode());
      if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
        QString s;
        { QTextStream ss(&s);
          ss << "  current value: " << getDdVersion() <<"\n";
          ss << "  min value: " << minDdVersion() <<"\n";
          ss << "  max value: " << maxDdVersion() <<"\n";
          ss << "  default value: " << defaultDdVersion() <<"\n";
        }
        printf("%s",s.toUtf8().data());
      }
    } catch (pvpException) {
       printf("DdVersion: Could not read\n");
    }
    try {
      printf("  count: %i\n",countDdVersion());
    } catch (pvpException) {
      printf("DdVersion: Could not count\n");
    }
  } else {
    printf("DdVersion is not available.\n");
  }
}

bool pvpCamera::availDdRetries() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_RETRIES availability");
  return avail;
}

pvpAccess pvpCamera::accessDdRetries() /*throw(pvpException)*/ {
  uns16 access;
  if (!availDdRetries())
    throw pvpException("DD_RETRIES not available");
  if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_RETRIES accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdRetries() /*throw(pvpException)*/ {
  uns32 count;
  if (!availDdRetries())
    throw pvpException("DD_RETRIES not available");
  if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_RETRIES count");
  return count;
}

uint16_t pvpCamera::getDdRetries() /*throw(pvpException)*/ {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

uint16_t pvpCamera::defaultDdRetries() /*throw(pvpException)*/ {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

uint16_t pvpCamera::minDdRetries() /*throw(pvpException)*/ {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

uint16_t pvpCamera::maxDdRetries() /*throw(pvpException)*/ {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_RETRIES,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_RETRIES");
    return x;
  } else {
    throw pvpException("DD_RETRIES not accessible for reading");
  }
}

void pvpCamera::setDdRetries(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessDdRetries();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_DD_RETRIES,(void*)(&y)))
      throw pvpException("Cannot set DD_RETRIES");
  }
}

void pvpCamera::reportDdRetries() /*throw(pvpException)*/ {
  if (availDdRetries()) {
    try {
      pvpAccess a = accessDdRetries();
      printf("DdRetries: %s\n",a.decode());
      if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
        QString s;
        { QTextStream ss(&s);
          ss << "  current value: " << getDdRetries() <<"\n";
          ss << "  min value: " << minDdRetries() <<"\n";
          ss << "  max value: " << maxDdRetries() <<"\n";
          ss << "  default value: " << defaultDdRetries() <<"\n";
        }
        printf("%s",s.toUtf8().data());
      }
    } catch (pvpException) {
       printf("DdRetries: Could not read\n");
    }
    try {
      printf("  count: %i\n",countDdRetries());
    } catch (pvpException) {
      printf("DdRetries: Could not count\n");
    }
  } else {
    printf("DdRetries is not available.\n");
  }
}

bool pvpCamera::availDdTimeout() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_TIMEOUT availability");
  return avail;
}

pvpAccess pvpCamera::accessDdTimeout() /*throw(pvpException)*/ {
  uns16 access;
  if (!availDdTimeout())
    throw pvpException("DD_TIMEOUT not available");
  if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_TIMEOUT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdTimeout() /*throw(pvpException)*/ {
  uns32 count;
  if (!availDdTimeout())
    throw pvpException("DD_TIMEOUT not available");
  if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_TIMEOUT count");
  return count;
}

uint16_t pvpCamera::getDdTimeout() /*throw(pvpException)*/ {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

uint16_t pvpCamera::defaultDdTimeout() /*throw(pvpException)*/ {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

uint16_t pvpCamera::minDdTimeout() /*throw(pvpException)*/ {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

uint16_t pvpCamera::maxDdTimeout() /*throw(pvpException)*/ {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_DD_TIMEOUT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of DD_TIMEOUT");
    return x;
  } else {
    throw pvpException("DD_TIMEOUT not accessible for reading");
  }
}

void pvpCamera::setDdTimeout(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessDdTimeout();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_DD_TIMEOUT,(void*)(&y)))
      throw pvpException("Cannot set DD_TIMEOUT");
  }
}

void pvpCamera::reportDdTimeout() /*throw(pvpException)*/ {
  if (availDdTimeout()) {
    try {
      pvpAccess a = accessDdTimeout();
      printf("DdTimeout: %s\n",a.decode());
      if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
        QString s;
        { QTextStream ss(&s);
          ss << "  current value: " << getDdTimeout() <<"\n";
          ss << "  min value: " << minDdTimeout() <<"\n";
          ss << "  max value: " << maxDdTimeout() <<"\n";
          ss << "  default value: " << defaultDdTimeout() <<"\n";
        }
        printf("%s",s.toUtf8().data());
      }
    } catch (pvpException) {
       printf("DdTimeout: Could not read\n");
    }
    try {
      printf("  count: %i\n",countDdTimeout());
    } catch (pvpException) {
      printf("DdTimeout: Could not count\n");
    }
  } else {
    printf("DdTimeout is not available.\n");
  }
}

bool pvpCamera::availDdInfo() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get DD_INFO availability");
  return avail;
}

pvpAccess pvpCamera::accessDdInfo() /*throw(pvpException)*/ {
  uns16 access;
  if (!availDdInfo())
    throw pvpException("DD_INFO not available");
  if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_ACCESS,&access))
    throw pvpException("Cannot get DD_INFO accessibility");
  return pvpAccess(access);
}

int pvpCamera::countDdInfo() /*throw(pvpException)*/ {
  uns32 count;
  if (!availDdInfo())
    throw pvpException("DD_INFO not available");
  if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_COUNT,&count))
    throw pvpException("Cannot get DD_INFO count");
  return count;
}

QString pvpCamera::getDdInfo() /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(getDdInfoLength(), 0);
    if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_CURRENT,ar.data()))
      throw pvpException("Cannot read DD_INFO");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("DD_INFO not accessible for reading");
  }
}

QString pvpCamera::defaultDdInfo() /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    QByteArray ar(getDdInfoLength(), 0);
    if (!pl_get_param(camh,PARAM_DD_INFO,ATTR_DEFAULT,ar.data()))
      throw pvpException("Cannot read default of DD_INFO");
    QString y = ar.data();
    return y;
  } else {
    throw pvpException("DD_INFO not accessible for reading");
  }
}

QString pvpCamera::minDdInfo() /*throw(pvpException)*/ {
    return "";
}

QString pvpCamera::maxDdInfo() /*throw(pvpException)*/ {
    return "";
}

void pvpCamera::setDdInfo(QString x) /*throw(pvpException)*/ {
  pvpAccess a = accessDdInfo();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    if (!pl_set_param(camh,PARAM_DD_INFO,(void*)(x.toUtf8().data())))
      throw pvpException("Cannot set DD_INFO");
  }
}

void pvpCamera::reportDdInfo() /*throw(pvpException)*/ {
  if (availDdInfo()) {
    try {
      pvpAccess a = accessDdInfo();
      printf("DdInfo: %s\n",a.decode());
      if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
        QString s;
        { QTextStream ss(&s);
          ss << "  current value: " << getDdInfo() <<"\n";
          ss << "  min value: " << minDdInfo() <<"\n";
          ss << "  max value: " << maxDdInfo() <<"\n";
          ss << "  default value: " << defaultDdInfo() <<"\n";
        }
        printf("%s",s.toUtf8().data());
      }
    } catch (pvpException) {
       printf("DdInfo: Could not read\n");
    }
    try {
      printf("  count: %i\n",countDdInfo());
    } catch (pvpException) {
      printf("DdInfo: Could not count\n");
    }
  } else {
    printf("DdInfo is not available.\n");
  }
}

void pvpCamera::reportClass0() /*throw(pvpException)*/ {
  reportDdInfoLength();
  reportDdVersion();
  reportDdRetries();
  reportDdTimeout();
  reportDdInfo();
}


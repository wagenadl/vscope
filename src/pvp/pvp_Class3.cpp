// pvp_Class3.cpp - generated by pvcam2param.pl. Do not Edit.

#include <pvp/pvpCamera.h>
#include <QTextStream>
#include <pvp/dwpvcam.h>

bool pvpCamera::availExpTime() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXP_TIME availability");
  return avail;
}

pvpAccess pvpCamera::accessExpTime() /*throw(pvpException)*/ {
  uns16 access;
  if (!availExpTime())
    throw pvpException("EXP_TIME not available");
  if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXP_TIME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExpTime() /*throw(pvpException)*/ {
  uns32 count;
  if (!availExpTime())
    throw pvpException("EXP_TIME not available");
  if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXP_TIME count");
  return count;
}

uint16_t pvpCamera::getExpTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExpTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXP_TIME");
    return x;
  } else {
    throw pvpException("EXP_TIME not accessible for reading");
  }
}

uint16_t pvpCamera::defaultExpTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExpTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXP_TIME");
    return x;
  } else {
    throw pvpException("EXP_TIME not accessible for reading");
  }
}

uint16_t pvpCamera::minExpTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExpTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXP_TIME");
    return x;
  } else {
    throw pvpException("EXP_TIME not accessible for reading");
  }
}

uint16_t pvpCamera::maxExpTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExpTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_TIME,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXP_TIME");
    return x;
  } else {
    throw pvpException("EXP_TIME not accessible for reading");
  }
}

void pvpCamera::setExpTime(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessExpTime();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_EXP_TIME,(void*)(&y)))
      throw pvpException("Cannot set EXP_TIME");
  }
}

void pvpCamera::reportExpTime() /*throw(pvpException)*/ {
  if (availExpTime()) {
    pvpAccess a = accessExpTime();
    printf("ExpTime: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExpTime() <<"\n";
        ss << "  min value: " << minExpTime() <<"\n";
        ss << "  max value: " << maxExpTime() <<"\n";
        ss << "  default value: " << defaultExpTime() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countExpTime());
  } else {
    printf("ExpTime is not available.\n");
  }
}

char const *pvpCamera::ExpRes::decode() const {
  switch (x) {
    case Millisec: return "Millisec";
    case Microsec: return "Microsec";
    case Sec: return "Sec";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availExpRes() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXP_RES availability");
  return avail;
}

pvpAccess pvpCamera::accessExpRes() /*throw(pvpException)*/ {
  uns16 access;
  if (!availExpRes())
    throw pvpException("EXP_RES not available");
  if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXP_RES accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExpRes() /*throw(pvpException)*/ {
  uns32 count;
  if (!availExpRes())
    throw pvpException("EXP_RES not available");
  if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXP_RES count");
  return count;
}

pvpCamera::ExpRes pvpCamera::getExpRes() /*throw(pvpException)*/ {
  pvpAccess a = accessExpRes();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXP_RES");
    return x;
  } else {
    throw pvpException("EXP_RES not accessible for reading");
  }
}

pvpCamera::ExpRes pvpCamera::defaultExpRes() /*throw(pvpException)*/ {
  pvpAccess a = accessExpRes();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXP_RES");
    return x;
  } else {
    throw pvpException("EXP_RES not accessible for reading");
  }
}

pvpCamera::ExpRes pvpCamera::minExpRes() /*throw(pvpException)*/ {
  pvpAccess a = accessExpRes();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXP_RES");
    return x;
  } else {
    throw pvpException("EXP_RES not accessible for reading");
  }
}

pvpCamera::ExpRes pvpCamera::maxExpRes() /*throw(pvpException)*/ {
  pvpAccess a = accessExpRes();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_EXP_RES,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXP_RES");
    return x;
  } else {
    throw pvpException("EXP_RES not accessible for reading");
  }
}

void pvpCamera::setExpRes(pvpCamera::ExpRes x) /*throw(pvpException)*/ {
  pvpAccess a = accessExpRes();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_EXP_RES,(void*)(&y)))
      throw pvpException("Cannot set EXP_RES");
  }
}

void pvpCamera::reportExpRes() /*throw(pvpException)*/ {
  if (availExpRes()) {
    pvpAccess a = accessExpRes();
    printf("ExpRes: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExpRes().decode() <<"\n";
        ss << "  min value: " << minExpRes().decode() <<"\n";
        ss << "  max value: " << maxExpRes().decode() <<"\n";
        ss << "  default value: " << defaultExpRes().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countExpRes());
  } else {
    printf("ExpRes is not available.\n");
  }
}

bool pvpCamera::availExpResIndex() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXP_RES_INDEX availability");
  return avail;
}

pvpAccess pvpCamera::accessExpResIndex() /*throw(pvpException)*/ {
  uns16 access;
  if (!availExpResIndex())
    throw pvpException("EXP_RES_INDEX not available");
  if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXP_RES_INDEX accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExpResIndex() /*throw(pvpException)*/ {
  uns32 count;
  if (!availExpResIndex())
    throw pvpException("EXP_RES_INDEX not available");
  if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXP_RES_INDEX count");
  return count;
}

uint16_t pvpCamera::getExpResIndex() /*throw(pvpException)*/ {
  pvpAccess a = accessExpResIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXP_RES_INDEX");
    return x;
  } else {
    throw pvpException("EXP_RES_INDEX not accessible for reading");
  }
}

uint16_t pvpCamera::defaultExpResIndex() /*throw(pvpException)*/ {
  pvpAccess a = accessExpResIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXP_RES_INDEX");
    return x;
  } else {
    throw pvpException("EXP_RES_INDEX not accessible for reading");
  }
}

uint16_t pvpCamera::minExpResIndex() /*throw(pvpException)*/ {
  pvpAccess a = accessExpResIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXP_RES_INDEX");
    return x;
  } else {
    throw pvpException("EXP_RES_INDEX not accessible for reading");
  }
}

uint16_t pvpCamera::maxExpResIndex() /*throw(pvpException)*/ {
  pvpAccess a = accessExpResIndex();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_EXP_RES_INDEX,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXP_RES_INDEX");
    return x;
  } else {
    throw pvpException("EXP_RES_INDEX not accessible for reading");
  }
}

void pvpCamera::setExpResIndex(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessExpResIndex();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_EXP_RES_INDEX,(void*)(&y)))
      throw pvpException("Cannot set EXP_RES_INDEX");
  }
}

void pvpCamera::reportExpResIndex() /*throw(pvpException)*/ {
  if (availExpResIndex()) {
    pvpAccess a = accessExpResIndex();
    printf("ExpResIndex: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExpResIndex() <<"\n";
        ss << "  min value: " << minExpResIndex() <<"\n";
        ss << "  max value: " << maxExpResIndex() <<"\n";
        ss << "  default value: " << defaultExpResIndex() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countExpResIndex());
  } else {
    printf("ExpResIndex is not available.\n");
  }
}

bool pvpCamera::availExposureTime() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get EXPOSURE_TIME availability");
  return avail;
}

pvpAccess pvpCamera::accessExposureTime() /*throw(pvpException)*/ {
  uns16 access;
  if (!availExposureTime())
    throw pvpException("EXPOSURE_TIME not available");
  if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_ACCESS,&access))
    throw pvpException("Cannot get EXPOSURE_TIME accessibility");
  return pvpAccess(access);
}

int pvpCamera::countExposureTime() /*throw(pvpException)*/ {
  uns32 count;
  if (!availExposureTime())
    throw pvpException("EXPOSURE_TIME not available");
  if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_COUNT,&count))
    throw pvpException("Cannot get EXPOSURE_TIME count");
  return count;
}

uint64_t pvpCamera::getExposureTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExposureTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_CURRENT,&x))
      throw pvpException("Cannot read EXPOSURE_TIME");
    return x;
  } else {
    throw pvpException("EXPOSURE_TIME not accessible for reading");
  }
}

uint64_t pvpCamera::defaultExposureTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExposureTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of EXPOSURE_TIME");
    return x;
  } else {
    throw pvpException("EXPOSURE_TIME not accessible for reading");
  }
}

uint64_t pvpCamera::minExposureTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExposureTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_MIN,&x))
      throw pvpException("Cannot read min of EXPOSURE_TIME");
    return x;
  } else {
    throw pvpException("EXPOSURE_TIME not accessible for reading");
  }
}

uint64_t pvpCamera::maxExposureTime() /*throw(pvpException)*/ {
  pvpAccess a = accessExposureTime();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_EXPOSURE_TIME,ATTR_MAX,&x))
      throw pvpException("Cannot read max of EXPOSURE_TIME");
    return x;
  } else {
    throw pvpException("EXPOSURE_TIME not accessible for reading");
  }
}

void pvpCamera::setExposureTime(uint64_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessExposureTime();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint64_t y = x;
    if (!pl_set_param(camh,PARAM_EXPOSURE_TIME,(void*)(&y)))
      throw pvpException("Cannot set EXPOSURE_TIME");
  }
}

void pvpCamera::reportExposureTime() /*throw(pvpException)*/ {
  if (availExposureTime()) {
    pvpAccess a = accessExposureTime();
    printf("ExposureTime: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getExposureTime() <<"\n";
        ss << "  min value: " << minExposureTime() <<"\n";
        ss << "  max value: " << maxExposureTime() <<"\n";
        ss << "  default value: " << defaultExposureTime() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countExposureTime());
  } else {
    printf("ExposureTime is not available.\n");
  }
}

char const *pvpCamera::BofEofEnable::decode() const {
  switch (x) {
    case NoFrameIrqs: return "NoFrameIrqs";
    case BeginFrameIrqs: return "BeginFrameIrqs";
    case EndFrameIrqs: return "EndFrameIrqs";
    case BeginEndFrameIrqs: return "BeginEndFrameIrqs";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availBofEofEnable() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BOF_EOF_ENABLE availability");
  return avail;
}

pvpAccess pvpCamera::accessBofEofEnable() /*throw(pvpException)*/ {
  uns16 access;
  if (!availBofEofEnable())
    throw pvpException("BOF_EOF_ENABLE not available");
  if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BOF_EOF_ENABLE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBofEofEnable() /*throw(pvpException)*/ {
  uns32 count;
  if (!availBofEofEnable())
    throw pvpException("BOF_EOF_ENABLE not available");
  if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_COUNT,&count))
    throw pvpException("Cannot get BOF_EOF_ENABLE count");
  return count;
}

pvpCamera::BofEofEnable pvpCamera::getBofEofEnable() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BOF_EOF_ENABLE");
    return x;
  } else {
    throw pvpException("BOF_EOF_ENABLE not accessible for reading");
  }
}

pvpCamera::BofEofEnable pvpCamera::defaultBofEofEnable() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BOF_EOF_ENABLE");
    return x;
  } else {
    throw pvpException("BOF_EOF_ENABLE not accessible for reading");
  }
}

pvpCamera::BofEofEnable pvpCamera::minBofEofEnable() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BOF_EOF_ENABLE");
    return x;
  } else {
    throw pvpException("BOF_EOF_ENABLE not accessible for reading");
  }
}

pvpCamera::BofEofEnable pvpCamera::maxBofEofEnable() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofEnable();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_ENABLE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BOF_EOF_ENABLE");
    return x;
  } else {
    throw pvpException("BOF_EOF_ENABLE not accessible for reading");
  }
}

void pvpCamera::setBofEofEnable(pvpCamera::BofEofEnable x) /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofEnable();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_BOF_EOF_ENABLE,(void*)(&y)))
      throw pvpException("Cannot set BOF_EOF_ENABLE");
  }
}

void pvpCamera::reportBofEofEnable() /*throw(pvpException)*/ {
  if (availBofEofEnable()) {
    pvpAccess a = accessBofEofEnable();
    printf("BofEofEnable: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBofEofEnable().decode() <<"\n";
        ss << "  min value: " << minBofEofEnable().decode() <<"\n";
        ss << "  max value: " << maxBofEofEnable().decode() <<"\n";
        ss << "  default value: " << defaultBofEofEnable().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countBofEofEnable());
  } else {
    printf("BofEofEnable is not available.\n");
  }
}

bool pvpCamera::availBofEofCount() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BOF_EOF_COUNT availability");
  return avail;
}

pvpAccess pvpCamera::accessBofEofCount() /*throw(pvpException)*/ {
  uns16 access;
  if (!availBofEofCount())
    throw pvpException("BOF_EOF_COUNT not available");
  if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BOF_EOF_COUNT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBofEofCount() /*throw(pvpException)*/ {
  uns32 count;
  if (!availBofEofCount())
    throw pvpException("BOF_EOF_COUNT not available");
  if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_COUNT,&count))
    throw pvpException("Cannot get BOF_EOF_COUNT count");
  return count;
}

uint32_t pvpCamera::getBofEofCount() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BOF_EOF_COUNT");
    return x;
  } else {
    throw pvpException("BOF_EOF_COUNT not accessible for reading");
  }
}

uint32_t pvpCamera::defaultBofEofCount() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BOF_EOF_COUNT");
    return x;
  } else {
    throw pvpException("BOF_EOF_COUNT not accessible for reading");
  }
}

uint32_t pvpCamera::minBofEofCount() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BOF_EOF_COUNT");
    return x;
  } else {
    throw pvpException("BOF_EOF_COUNT not accessible for reading");
  }
}

uint32_t pvpCamera::maxBofEofCount() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint32_t x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_COUNT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BOF_EOF_COUNT");
    return x;
  } else {
    throw pvpException("BOF_EOF_COUNT not accessible for reading");
  }
}

void pvpCamera::setBofEofCount(uint32_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofCount();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint32_t y = x;
    if (!pl_set_param(camh,PARAM_BOF_EOF_COUNT,(void*)(&y)))
      throw pvpException("Cannot set BOF_EOF_COUNT");
  }
}

void pvpCamera::reportBofEofCount() /*throw(pvpException)*/ {
  if (availBofEofCount()) {
    pvpAccess a = accessBofEofCount();
    printf("BofEofCount: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBofEofCount() <<"\n";
        ss << "  min value: " << minBofEofCount() <<"\n";
        ss << "  max value: " << maxBofEofCount() <<"\n";
        ss << "  default value: " << defaultBofEofCount() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countBofEofCount());
  } else {
    printf("BofEofCount is not available.\n");
  }
}

bool pvpCamera::availBofEofClr() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BOF_EOF_CLR availability");
  return avail;
}

pvpAccess pvpCamera::accessBofEofClr() /*throw(pvpException)*/ {
  uns16 access;
  if (!availBofEofClr())
    throw pvpException("BOF_EOF_CLR not available");
  if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BOF_EOF_CLR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBofEofClr() /*throw(pvpException)*/ {
  uns32 count;
  if (!availBofEofClr())
    throw pvpException("BOF_EOF_CLR not available");
  if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_COUNT,&count))
    throw pvpException("Cannot get BOF_EOF_CLR count");
  return count;
}

bool pvpCamera::getBofEofClr() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BOF_EOF_CLR");
    return x;
  } else {
    throw pvpException("BOF_EOF_CLR not accessible for reading");
  }
}

bool pvpCamera::defaultBofEofClr() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BOF_EOF_CLR");
    return x;
  } else {
    throw pvpException("BOF_EOF_CLR not accessible for reading");
  }
}

bool pvpCamera::minBofEofClr() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BOF_EOF_CLR");
    return x;
  } else {
    throw pvpException("BOF_EOF_CLR not accessible for reading");
  }
}

bool pvpCamera::maxBofEofClr() /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofClr();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_BOF_EOF_CLR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BOF_EOF_CLR");
    return x;
  } else {
    throw pvpException("BOF_EOF_CLR not accessible for reading");
  }
}

void pvpCamera::setBofEofClr(bool x) /*throw(pvpException)*/ {
  pvpAccess a = accessBofEofClr();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    rs_bool y = x;
    if (!pl_set_param(camh,PARAM_BOF_EOF_CLR,(void*)(&y)))
      throw pvpException("Cannot set BOF_EOF_CLR");
  }
}

void pvpCamera::reportBofEofClr() /*throw(pvpException)*/ {
  if (availBofEofClr()) {
    pvpAccess a = accessBofEofClr();
    printf("BofEofClr: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBofEofClr() <<"\n";
        ss << "  min value: " << minBofEofClr() <<"\n";
        ss << "  max value: " << maxBofEofClr() <<"\n";
        ss << "  default value: " << defaultBofEofClr() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countBofEofClr());
  } else {
    printf("BofEofClr is not available.\n");
  }
}

bool pvpCamera::availCircBuffer() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CIRC_BUFFER availability");
  return avail;
}

pvpAccess pvpCamera::accessCircBuffer() /*throw(pvpException)*/ {
  uns16 access;
  if (!availCircBuffer())
    throw pvpException("CIRC_BUFFER not available");
  if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CIRC_BUFFER accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCircBuffer() /*throw(pvpException)*/ {
  uns32 count;
  if (!availCircBuffer())
    throw pvpException("CIRC_BUFFER not available");
  if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_COUNT,&count))
    throw pvpException("Cannot get CIRC_BUFFER count");
  return count;
}

bool pvpCamera::getCircBuffer() /*throw(pvpException)*/ {
  pvpAccess a = accessCircBuffer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CIRC_BUFFER");
    return x;
  } else {
    throw pvpException("CIRC_BUFFER not accessible for reading");
  }
}

bool pvpCamera::defaultCircBuffer() /*throw(pvpException)*/ {
  pvpAccess a = accessCircBuffer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CIRC_BUFFER");
    return x;
  } else {
    throw pvpException("CIRC_BUFFER not accessible for reading");
  }
}

bool pvpCamera::minCircBuffer() /*throw(pvpException)*/ {
  pvpAccess a = accessCircBuffer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CIRC_BUFFER");
    return x;
  } else {
    throw pvpException("CIRC_BUFFER not accessible for reading");
  }
}

bool pvpCamera::maxCircBuffer() /*throw(pvpException)*/ {
  pvpAccess a = accessCircBuffer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CIRC_BUFFER,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CIRC_BUFFER");
    return x;
  } else {
    throw pvpException("CIRC_BUFFER not accessible for reading");
  }
}

void pvpCamera::setCircBuffer(bool x) /*throw(pvpException)*/ {
  pvpAccess a = accessCircBuffer();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    rs_bool y = x;
    if (!pl_set_param(camh,PARAM_CIRC_BUFFER,(void*)(&y)))
      throw pvpException("Cannot set CIRC_BUFFER");
  }
}

void pvpCamera::reportCircBuffer() /*throw(pvpException)*/ {
  if (availCircBuffer()) {
    pvpAccess a = accessCircBuffer();
    printf("CircBuffer: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCircBuffer() <<"\n";
        ss << "  min value: " << minCircBuffer() <<"\n";
        ss << "  max value: " << maxCircBuffer() <<"\n";
        ss << "  default value: " << defaultCircBuffer() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCircBuffer());
  } else {
    printf("CircBuffer is not available.\n");
  }
}

bool pvpCamera::availFrameBufferSize() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get FRAME_BUFFER_SIZE availability");
  return avail;
}

pvpAccess pvpCamera::accessFrameBufferSize() /*throw(pvpException)*/ {
  uns16 access;
  if (!availFrameBufferSize())
    throw pvpException("FRAME_BUFFER_SIZE not available");
  if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_ACCESS,&access))
    throw pvpException("Cannot get FRAME_BUFFER_SIZE accessibility");
  return pvpAccess(access);
}

int pvpCamera::countFrameBufferSize() /*throw(pvpException)*/ {
  uns32 count;
  if (!availFrameBufferSize())
    throw pvpException("FRAME_BUFFER_SIZE not available");
  if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_COUNT,&count))
    throw pvpException("Cannot get FRAME_BUFFER_SIZE count");
  return count;
}

uint64_t pvpCamera::getFrameBufferSize() /*throw(pvpException)*/ {
  pvpAccess a = accessFrameBufferSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_CURRENT,&x))
      throw pvpException("Cannot read FRAME_BUFFER_SIZE");
    return x;
  } else {
    throw pvpException("FRAME_BUFFER_SIZE not accessible for reading");
  }
}

uint64_t pvpCamera::defaultFrameBufferSize() /*throw(pvpException)*/ {
  pvpAccess a = accessFrameBufferSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of FRAME_BUFFER_SIZE");
    return x;
  } else {
    throw pvpException("FRAME_BUFFER_SIZE not accessible for reading");
  }
}

uint64_t pvpCamera::minFrameBufferSize() /*throw(pvpException)*/ {
  pvpAccess a = accessFrameBufferSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_MIN,&x))
      throw pvpException("Cannot read min of FRAME_BUFFER_SIZE");
    return x;
  } else {
    throw pvpException("FRAME_BUFFER_SIZE not accessible for reading");
  }
}

uint64_t pvpCamera::maxFrameBufferSize() /*throw(pvpException)*/ {
  pvpAccess a = accessFrameBufferSize();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint64_t x;
    if (!pl_get_param(camh,PARAM_FRAME_BUFFER_SIZE,ATTR_MAX,&x))
      throw pvpException("Cannot read max of FRAME_BUFFER_SIZE");
    return x;
  } else {
    throw pvpException("FRAME_BUFFER_SIZE not accessible for reading");
  }
}

void pvpCamera::setFrameBufferSize(uint64_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessFrameBufferSize();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint64_t y = x;
    if (!pl_set_param(camh,PARAM_FRAME_BUFFER_SIZE,(void*)(&y)))
      throw pvpException("Cannot set FRAME_BUFFER_SIZE");
  }
}

void pvpCamera::reportFrameBufferSize() /*throw(pvpException)*/ {
  if (availFrameBufferSize()) {
    pvpAccess a = accessFrameBufferSize();
    printf("FrameBufferSize: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getFrameBufferSize() <<"\n";
        ss << "  min value: " << minFrameBufferSize() <<"\n";
        ss << "  max value: " << maxFrameBufferSize() <<"\n";
        ss << "  default value: " << defaultFrameBufferSize() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countFrameBufferSize());
  } else {
    printf("FrameBufferSize is not available.\n");
  }
}

char const *pvpCamera::BinningSer::decode() const {
  switch (x) {
    case One: return "One";
    case Two: return "Two";
    case Three: return "Three";
    case Four: return "Four";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availBinningSer() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BINNING_SER availability");
  return avail;
}

pvpAccess pvpCamera::accessBinningSer() /*throw(pvpException)*/ {
  uns16 access;
  if (!availBinningSer())
    throw pvpException("BINNING_SER not available");
  if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BINNING_SER accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBinningSer() /*throw(pvpException)*/ {
  uns32 count;
  if (!availBinningSer())
    throw pvpException("BINNING_SER not available");
  if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_COUNT,&count))
    throw pvpException("Cannot get BINNING_SER count");
  return count;
}

pvpCamera::BinningSer pvpCamera::getBinningSer() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningSer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BINNING_SER");
    return x;
  } else {
    throw pvpException("BINNING_SER not accessible for reading");
  }
}

pvpCamera::BinningSer pvpCamera::defaultBinningSer() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningSer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BINNING_SER");
    return x;
  } else {
    throw pvpException("BINNING_SER not accessible for reading");
  }
}

pvpCamera::BinningSer pvpCamera::minBinningSer() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningSer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BINNING_SER");
    return x;
  } else {
    throw pvpException("BINNING_SER not accessible for reading");
  }
}

pvpCamera::BinningSer pvpCamera::maxBinningSer() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningSer();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_SER,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BINNING_SER");
    return x;
  } else {
    throw pvpException("BINNING_SER not accessible for reading");
  }
}

void pvpCamera::setBinningSer(pvpCamera::BinningSer x) /*throw(pvpException)*/ {
  pvpAccess a = accessBinningSer();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_BINNING_SER,(void*)(&y)))
      throw pvpException("Cannot set BINNING_SER");
  }
}

void pvpCamera::reportBinningSer() /*throw(pvpException)*/ {
  if (availBinningSer()) {
    pvpAccess a = accessBinningSer();
    printf("BinningSer: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBinningSer().decode() <<"\n";
        ss << "  min value: " << minBinningSer().decode() <<"\n";
        ss << "  max value: " << maxBinningSer().decode() <<"\n";
        ss << "  default value: " << defaultBinningSer().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countBinningSer());
  } else {
    printf("BinningSer is not available.\n");
  }
}

char const *pvpCamera::BinningPar::decode() const {
  switch (x) {
    case One: return "One";
    case Two: return "Two";
    case Three: return "Three";
    case Four: return "Four";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availBinningPar() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get BINNING_PAR availability");
  return avail;
}

pvpAccess pvpCamera::accessBinningPar() /*throw(pvpException)*/ {
  uns16 access;
  if (!availBinningPar())
    throw pvpException("BINNING_PAR not available");
  if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_ACCESS,&access))
    throw pvpException("Cannot get BINNING_PAR accessibility");
  return pvpAccess(access);
}

int pvpCamera::countBinningPar() /*throw(pvpException)*/ {
  uns32 count;
  if (!availBinningPar())
    throw pvpException("BINNING_PAR not available");
  if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_COUNT,&count))
    throw pvpException("Cannot get BINNING_PAR count");
  return count;
}

pvpCamera::BinningPar pvpCamera::getBinningPar() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningPar();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_CURRENT,&x))
      throw pvpException("Cannot read BINNING_PAR");
    return x;
  } else {
    throw pvpException("BINNING_PAR not accessible for reading");
  }
}

pvpCamera::BinningPar pvpCamera::defaultBinningPar() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningPar();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of BINNING_PAR");
    return x;
  } else {
    throw pvpException("BINNING_PAR not accessible for reading");
  }
}

pvpCamera::BinningPar pvpCamera::minBinningPar() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningPar();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_MIN,&x))
      throw pvpException("Cannot read min of BINNING_PAR");
    return x;
  } else {
    throw pvpException("BINNING_PAR not accessible for reading");
  }
}

pvpCamera::BinningPar pvpCamera::maxBinningPar() /*throw(pvpException)*/ {
  pvpAccess a = accessBinningPar();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_BINNING_PAR,ATTR_MAX,&x))
      throw pvpException("Cannot read max of BINNING_PAR");
    return x;
  } else {
    throw pvpException("BINNING_PAR not accessible for reading");
  }
}

void pvpCamera::setBinningPar(pvpCamera::BinningPar x) /*throw(pvpException)*/ {
  pvpAccess a = accessBinningPar();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_BINNING_PAR,(void*)(&y)))
      throw pvpException("Cannot set BINNING_PAR");
  }
}

void pvpCamera::reportBinningPar() /*throw(pvpException)*/ {
  if (availBinningPar()) {
    pvpAccess a = accessBinningPar();
    printf("BinningPar: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getBinningPar().decode() <<"\n";
        ss << "  min value: " << minBinningPar().decode() <<"\n";
        ss << "  max value: " << maxBinningPar().decode() <<"\n";
        ss << "  default value: " << defaultBinningPar().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countBinningPar());
  } else {
    printf("BinningPar is not available.\n");
  }
}

bool pvpCamera::availMetadataEnabled() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get METADATA_ENABLED availability");
  return avail;
}

pvpAccess pvpCamera::accessMetadataEnabled() /*throw(pvpException)*/ {
  uns16 access;
  if (!availMetadataEnabled())
    throw pvpException("METADATA_ENABLED not available");
  if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_ACCESS,&access))
    throw pvpException("Cannot get METADATA_ENABLED accessibility");
  return pvpAccess(access);
}

int pvpCamera::countMetadataEnabled() /*throw(pvpException)*/ {
  uns32 count;
  if (!availMetadataEnabled())
    throw pvpException("METADATA_ENABLED not available");
  if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_COUNT,&count))
    throw pvpException("Cannot get METADATA_ENABLED count");
  return count;
}

bool pvpCamera::getMetadataEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessMetadataEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_CURRENT,&x))
      throw pvpException("Cannot read METADATA_ENABLED");
    return x;
  } else {
    throw pvpException("METADATA_ENABLED not accessible for reading");
  }
}

bool pvpCamera::defaultMetadataEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessMetadataEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of METADATA_ENABLED");
    return x;
  } else {
    throw pvpException("METADATA_ENABLED not accessible for reading");
  }
}

bool pvpCamera::minMetadataEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessMetadataEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_MIN,&x))
      throw pvpException("Cannot read min of METADATA_ENABLED");
    return x;
  } else {
    throw pvpException("METADATA_ENABLED not accessible for reading");
  }
}

bool pvpCamera::maxMetadataEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessMetadataEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_METADATA_ENABLED,ATTR_MAX,&x))
      throw pvpException("Cannot read max of METADATA_ENABLED");
    return x;
  } else {
    throw pvpException("METADATA_ENABLED not accessible for reading");
  }
}

void pvpCamera::setMetadataEnabled(bool x) /*throw(pvpException)*/ {
  pvpAccess a = accessMetadataEnabled();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    rs_bool y = x;
    if (!pl_set_param(camh,PARAM_METADATA_ENABLED,(void*)(&y)))
      throw pvpException("Cannot set METADATA_ENABLED");
  }
}

void pvpCamera::reportMetadataEnabled() /*throw(pvpException)*/ {
  if (availMetadataEnabled()) {
    pvpAccess a = accessMetadataEnabled();
    printf("MetadataEnabled: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getMetadataEnabled() <<"\n";
        ss << "  min value: " << minMetadataEnabled() <<"\n";
        ss << "  max value: " << maxMetadataEnabled() <<"\n";
        ss << "  default value: " << defaultMetadataEnabled() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countMetadataEnabled());
  } else {
    printf("MetadataEnabled is not available.\n");
  }
}

bool pvpCamera::availRoiCount() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get ROI_COUNT availability");
  return avail;
}

pvpAccess pvpCamera::accessRoiCount() /*throw(pvpException)*/ {
  uns16 access;
  if (!availRoiCount())
    throw pvpException("ROI_COUNT not available");
  if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get ROI_COUNT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countRoiCount() /*throw(pvpException)*/ {
  uns32 count;
  if (!availRoiCount())
    throw pvpException("ROI_COUNT not available");
  if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_COUNT,&count))
    throw pvpException("Cannot get ROI_COUNT count");
  return count;
}

uint16_t pvpCamera::getRoiCount() /*throw(pvpException)*/ {
  pvpAccess a = accessRoiCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read ROI_COUNT");
    return x;
  } else {
    throw pvpException("ROI_COUNT not accessible for reading");
  }
}

uint16_t pvpCamera::defaultRoiCount() /*throw(pvpException)*/ {
  pvpAccess a = accessRoiCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of ROI_COUNT");
    return x;
  } else {
    throw pvpException("ROI_COUNT not accessible for reading");
  }
}

uint16_t pvpCamera::minRoiCount() /*throw(pvpException)*/ {
  pvpAccess a = accessRoiCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of ROI_COUNT");
    return x;
  } else {
    throw pvpException("ROI_COUNT not accessible for reading");
  }
}

uint16_t pvpCamera::maxRoiCount() /*throw(pvpException)*/ {
  pvpAccess a = accessRoiCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_ROI_COUNT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of ROI_COUNT");
    return x;
  } else {
    throw pvpException("ROI_COUNT not accessible for reading");
  }
}

void pvpCamera::setRoiCount(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessRoiCount();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_ROI_COUNT,(void*)(&y)))
      throw pvpException("Cannot set ROI_COUNT");
  }
}

void pvpCamera::reportRoiCount() /*throw(pvpException)*/ {
  if (availRoiCount()) {
    pvpAccess a = accessRoiCount();
    printf("RoiCount: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getRoiCount() <<"\n";
        ss << "  min value: " << minRoiCount() <<"\n";
        ss << "  max value: " << maxRoiCount() <<"\n";
        ss << "  default value: " << defaultRoiCount() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countRoiCount());
  } else {
    printf("RoiCount is not available.\n");
  }
}

bool pvpCamera::availCentroidsEnabled() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CENTROIDS_ENABLED availability");
  return avail;
}

pvpAccess pvpCamera::accessCentroidsEnabled() /*throw(pvpException)*/ {
  uns16 access;
  if (!availCentroidsEnabled())
    throw pvpException("CENTROIDS_ENABLED not available");
  if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CENTROIDS_ENABLED accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCentroidsEnabled() /*throw(pvpException)*/ {
  uns32 count;
  if (!availCentroidsEnabled())
    throw pvpException("CENTROIDS_ENABLED not available");
  if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_COUNT,&count))
    throw pvpException("Cannot get CENTROIDS_ENABLED count");
  return count;
}

bool pvpCamera::getCentroidsEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CENTROIDS_ENABLED");
    return x;
  } else {
    throw pvpException("CENTROIDS_ENABLED not accessible for reading");
  }
}

bool pvpCamera::defaultCentroidsEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CENTROIDS_ENABLED");
    return x;
  } else {
    throw pvpException("CENTROIDS_ENABLED not accessible for reading");
  }
}

bool pvpCamera::minCentroidsEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CENTROIDS_ENABLED");
    return x;
  } else {
    throw pvpException("CENTROIDS_ENABLED not accessible for reading");
  }
}

bool pvpCamera::maxCentroidsEnabled() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsEnabled();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    rs_bool x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_ENABLED,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CENTROIDS_ENABLED");
    return x;
  } else {
    throw pvpException("CENTROIDS_ENABLED not accessible for reading");
  }
}

void pvpCamera::setCentroidsEnabled(bool x) /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsEnabled();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    rs_bool y = x;
    if (!pl_set_param(camh,PARAM_CENTROIDS_ENABLED,(void*)(&y)))
      throw pvpException("Cannot set CENTROIDS_ENABLED");
  }
}

void pvpCamera::reportCentroidsEnabled() /*throw(pvpException)*/ {
  if (availCentroidsEnabled()) {
    pvpAccess a = accessCentroidsEnabled();
    printf("CentroidsEnabled: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCentroidsEnabled() <<"\n";
        ss << "  min value: " << minCentroidsEnabled() <<"\n";
        ss << "  max value: " << maxCentroidsEnabled() <<"\n";
        ss << "  default value: " << defaultCentroidsEnabled() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCentroidsEnabled());
  } else {
    printf("CentroidsEnabled is not available.\n");
  }
}

bool pvpCamera::availCentroidsRadius() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CENTROIDS_RADIUS availability");
  return avail;
}

pvpAccess pvpCamera::accessCentroidsRadius() /*throw(pvpException)*/ {
  uns16 access;
  if (!availCentroidsRadius())
    throw pvpException("CENTROIDS_RADIUS not available");
  if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CENTROIDS_RADIUS accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCentroidsRadius() /*throw(pvpException)*/ {
  uns32 count;
  if (!availCentroidsRadius())
    throw pvpException("CENTROIDS_RADIUS not available");
  if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_COUNT,&count))
    throw pvpException("Cannot get CENTROIDS_RADIUS count");
  return count;
}

uint16_t pvpCamera::getCentroidsRadius() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsRadius();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CENTROIDS_RADIUS");
    return x;
  } else {
    throw pvpException("CENTROIDS_RADIUS not accessible for reading");
  }
}

uint16_t pvpCamera::defaultCentroidsRadius() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsRadius();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CENTROIDS_RADIUS");
    return x;
  } else {
    throw pvpException("CENTROIDS_RADIUS not accessible for reading");
  }
}

uint16_t pvpCamera::minCentroidsRadius() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsRadius();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CENTROIDS_RADIUS");
    return x;
  } else {
    throw pvpException("CENTROIDS_RADIUS not accessible for reading");
  }
}

uint16_t pvpCamera::maxCentroidsRadius() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsRadius();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_RADIUS,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CENTROIDS_RADIUS");
    return x;
  } else {
    throw pvpException("CENTROIDS_RADIUS not accessible for reading");
  }
}

void pvpCamera::setCentroidsRadius(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsRadius();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_CENTROIDS_RADIUS,(void*)(&y)))
      throw pvpException("Cannot set CENTROIDS_RADIUS");
  }
}

void pvpCamera::reportCentroidsRadius() /*throw(pvpException)*/ {
  if (availCentroidsRadius()) {
    pvpAccess a = accessCentroidsRadius();
    printf("CentroidsRadius: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCentroidsRadius() <<"\n";
        ss << "  min value: " << minCentroidsRadius() <<"\n";
        ss << "  max value: " << maxCentroidsRadius() <<"\n";
        ss << "  default value: " << defaultCentroidsRadius() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCentroidsRadius());
  } else {
    printf("CentroidsRadius is not available.\n");
  }
}

bool pvpCamera::availCentroidsCount() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get CENTROIDS_COUNT availability");
  return avail;
}

pvpAccess pvpCamera::accessCentroidsCount() /*throw(pvpException)*/ {
  uns16 access;
  if (!availCentroidsCount())
    throw pvpException("CENTROIDS_COUNT not available");
  if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_ACCESS,&access))
    throw pvpException("Cannot get CENTROIDS_COUNT accessibility");
  return pvpAccess(access);
}

int pvpCamera::countCentroidsCount() /*throw(pvpException)*/ {
  uns32 count;
  if (!availCentroidsCount())
    throw pvpException("CENTROIDS_COUNT not available");
  if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_COUNT,&count))
    throw pvpException("Cannot get CENTROIDS_COUNT count");
  return count;
}

uint16_t pvpCamera::getCentroidsCount() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_CURRENT,&x))
      throw pvpException("Cannot read CENTROIDS_COUNT");
    return x;
  } else {
    throw pvpException("CENTROIDS_COUNT not accessible for reading");
  }
}

uint16_t pvpCamera::defaultCentroidsCount() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of CENTROIDS_COUNT");
    return x;
  } else {
    throw pvpException("CENTROIDS_COUNT not accessible for reading");
  }
}

uint16_t pvpCamera::minCentroidsCount() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_MIN,&x))
      throw pvpException("Cannot read min of CENTROIDS_COUNT");
    return x;
  } else {
    throw pvpException("CENTROIDS_COUNT not accessible for reading");
  }
}

uint16_t pvpCamera::maxCentroidsCount() /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsCount();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uint16_t x;
    if (!pl_get_param(camh,PARAM_CENTROIDS_COUNT,ATTR_MAX,&x))
      throw pvpException("Cannot read max of CENTROIDS_COUNT");
    return x;
  } else {
    throw pvpException("CENTROIDS_COUNT not accessible for reading");
  }
}

void pvpCamera::setCentroidsCount(uint16_t x) /*throw(pvpException)*/ {
  pvpAccess a = accessCentroidsCount();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uint16_t y = x;
    if (!pl_set_param(camh,PARAM_CENTROIDS_COUNT,(void*)(&y)))
      throw pvpException("Cannot set CENTROIDS_COUNT");
  }
}

void pvpCamera::reportCentroidsCount() /*throw(pvpException)*/ {
  if (availCentroidsCount()) {
    pvpAccess a = accessCentroidsCount();
    printf("CentroidsCount: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getCentroidsCount() <<"\n";
        ss << "  min value: " << minCentroidsCount() <<"\n";
        ss << "  max value: " << maxCentroidsCount() <<"\n";
        ss << "  default value: " << defaultCentroidsCount() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countCentroidsCount());
  } else {
    printf("CentroidsCount is not available.\n");
  }
}

char const *pvpCamera::TrigtabSignal::decode() const {
  switch (x) {
    case Out: return "Out";
    default: return "UNKNOWN";
  }
}

bool pvpCamera::availTrigtabSignal() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get TRIGTAB_SIGNAL availability");
  return avail;
}

pvpAccess pvpCamera::accessTrigtabSignal() /*throw(pvpException)*/ {
  uns16 access;
  if (!availTrigtabSignal())
    throw pvpException("TRIGTAB_SIGNAL not available");
  if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_ACCESS,&access))
    throw pvpException("Cannot get TRIGTAB_SIGNAL accessibility");
  return pvpAccess(access);
}

int pvpCamera::countTrigtabSignal() /*throw(pvpException)*/ {
  uns32 count;
  if (!availTrigtabSignal())
    throw pvpException("TRIGTAB_SIGNAL not available");
  if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_COUNT,&count))
    throw pvpException("Cannot get TRIGTAB_SIGNAL count");
  return count;
}

pvpCamera::TrigtabSignal pvpCamera::getTrigtabSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessTrigtabSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_CURRENT,&x))
      throw pvpException("Cannot read TRIGTAB_SIGNAL");
    return x;
  } else {
    throw pvpException("TRIGTAB_SIGNAL not accessible for reading");
  }
}

pvpCamera::TrigtabSignal pvpCamera::defaultTrigtabSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessTrigtabSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of TRIGTAB_SIGNAL");
    return x;
  } else {
    throw pvpException("TRIGTAB_SIGNAL not accessible for reading");
  }
}

pvpCamera::TrigtabSignal pvpCamera::minTrigtabSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessTrigtabSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_MIN,&x))
      throw pvpException("Cannot read min of TRIGTAB_SIGNAL");
    return x;
  } else {
    throw pvpException("TRIGTAB_SIGNAL not accessible for reading");
  }
}

pvpCamera::TrigtabSignal pvpCamera::maxTrigtabSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessTrigtabSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    uns32 x;
    if (!pl_get_param(camh,PARAM_TRIGTAB_SIGNAL,ATTR_MAX,&x))
      throw pvpException("Cannot read max of TRIGTAB_SIGNAL");
    return x;
  } else {
    throw pvpException("TRIGTAB_SIGNAL not accessible for reading");
  }
}

void pvpCamera::setTrigtabSignal(pvpCamera::TrigtabSignal x) /*throw(pvpException)*/ {
  pvpAccess a = accessTrigtabSignal();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    uns32 y = x;
    if (!pl_set_param(camh,PARAM_TRIGTAB_SIGNAL,(void*)(&y)))
      throw pvpException("Cannot set TRIGTAB_SIGNAL");
  }
}

void pvpCamera::reportTrigtabSignal() /*throw(pvpException)*/ {
  if (availTrigtabSignal()) {
    pvpAccess a = accessTrigtabSignal();
    printf("TrigtabSignal: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getTrigtabSignal().decode() <<"\n";
        ss << "  min value: " << minTrigtabSignal().decode() <<"\n";
        ss << "  max value: " << maxTrigtabSignal().decode() <<"\n";
        ss << "  default value: " << defaultTrigtabSignal().decode() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countTrigtabSignal());
  } else {
    printf("TrigtabSignal is not available.\n");
  }
}

bool pvpCamera::availLastMuxedSignal() /*throw(pvpException)*/ {
  rs_bool avail;
  if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_AVAIL,&avail))
    throw pvpException("Cannot get LAST_MUXED_SIGNAL availability");
  return avail;
}

pvpAccess pvpCamera::accessLastMuxedSignal() /*throw(pvpException)*/ {
  uns16 access;
  if (!availLastMuxedSignal())
    throw pvpException("LAST_MUXED_SIGNAL not available");
  if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_ACCESS,&access))
    throw pvpException("Cannot get LAST_MUXED_SIGNAL accessibility");
  return pvpAccess(access);
}

int pvpCamera::countLastMuxedSignal() /*throw(pvpException)*/ {
  uns32 count;
  if (!availLastMuxedSignal())
    throw pvpException("LAST_MUXED_SIGNAL not available");
  if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_COUNT,&count))
    throw pvpException("Cannot get LAST_MUXED_SIGNAL count");
  return count;
}

unsigned char pvpCamera::getLastMuxedSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessLastMuxedSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    unsigned char x;
    if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_CURRENT,&x))
      throw pvpException("Cannot read LAST_MUXED_SIGNAL");
    return x;
  } else {
    throw pvpException("LAST_MUXED_SIGNAL not accessible for reading");
  }
}

unsigned char pvpCamera::defaultLastMuxedSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessLastMuxedSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    unsigned char x;
    if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_DEFAULT,&x))
      throw pvpException("Cannot read default of LAST_MUXED_SIGNAL");
    return x;
  } else {
    throw pvpException("LAST_MUXED_SIGNAL not accessible for reading");
  }
}

unsigned char pvpCamera::minLastMuxedSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessLastMuxedSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    unsigned char x;
    if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_MIN,&x))
      throw pvpException("Cannot read min of LAST_MUXED_SIGNAL");
    return x;
  } else {
    throw pvpException("LAST_MUXED_SIGNAL not accessible for reading");
  }
}

unsigned char pvpCamera::maxLastMuxedSignal() /*throw(pvpException)*/ {
  pvpAccess a = accessLastMuxedSignal();
  if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
    unsigned char x;
    if (!pl_get_param(camh,PARAM_LAST_MUXED_SIGNAL,ATTR_MAX,&x))
      throw pvpException("Cannot read max of LAST_MUXED_SIGNAL");
    return x;
  } else {
    throw pvpException("LAST_MUXED_SIGNAL not accessible for reading");
  }
}

void pvpCamera::setLastMuxedSignal(unsigned char x) /*throw(pvpException)*/ {
  pvpAccess a = accessLastMuxedSignal();
  if (a==pvpAccess::WriteOnly || a==pvpAccess::ReadWrite) {
    unsigned char y = x;
    if (!pl_set_param(camh,PARAM_LAST_MUXED_SIGNAL,(void*)(&y)))
      throw pvpException("Cannot set LAST_MUXED_SIGNAL");
  }
}

void pvpCamera::reportLastMuxedSignal() /*throw(pvpException)*/ {
  if (availLastMuxedSignal()) {
    pvpAccess a = accessLastMuxedSignal();
    printf("LastMuxedSignal: %s\n",a.decode());
    if (a==pvpAccess::ReadOnly || a==pvpAccess::ReadWrite) {
      QString s;
      { QTextStream ss(&s);
        ss << "  current value: " << getLastMuxedSignal() <<"\n";
        ss << "  min value: " << minLastMuxedSignal() <<"\n";
        ss << "  max value: " << maxLastMuxedSignal() <<"\n";
        ss << "  default value: " << defaultLastMuxedSignal() <<"\n";
      }
      printf("%s",s.toUtf8().data());
    }
    printf("  count: %i\n",countLastMuxedSignal());
  } else {
    printf("LastMuxedSignal is not available.\n");
  }
}

void pvpCamera::reportClass3() /*throw(pvpException)*/ {
  reportExpTime();
  reportExpRes();
  reportExpResIndex();
  reportExposureTime();
  reportBofEofEnable();
  reportBofEofCount();
  reportBofEofClr();
  reportCircBuffer();
  reportFrameBufferSize();
  reportBinningSer();
  reportBinningPar();
  reportMetadataEnabled();
  reportRoiCount();
  reportCentroidsEnabled();
  reportCentroidsRadius();
  reportCentroidsCount();
  reportTrigtabSignal();
  reportLastMuxedSignal();
}


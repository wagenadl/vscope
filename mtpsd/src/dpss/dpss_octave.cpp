/*

Copyright (c) 2010 C. Antonio Sanchez

This file is part of DPSS.

DPSS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DPSS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DPSS.  If not, see <http://www.gnu.org/licenses/>.

*/  

#include <octave/oct.h>
#include "dpss.h"

// parses the input arguments, creates a workspace
// nargin=inargs.length()-1 if the last input argument is 'trace' (checked in DEFUN_DLD)
dpss_workspace oct_parse_args(octave_value_list inargs, int nargin, int nargout);

//prints dpss workspace to console using printf
void print_workspace(dpss_workspace work);
void print_workspace(dpss_workspace work, char *prepend, char *append, char topchar, char bottomchar);

const char helpstr[]={\
"-*- texinfo -*-\n\
@deftypefn  {Loadable Function} {@var{h} =} dpss (@var{n},@var{nW})\n\
@deftypefnx {Loadable Function} {@var{h} =} dpss (@var{n}, @var{nW}, @var{nseq})\n\
@deftypefnx {Loadable Function} {@var{h} =} dpss (@var{n}, @var{nW}, @var{nseq}, @var{'interp'})\n\
@deftypefnx {Loadable Function} {@var{h} =} dpss (@var{n}, @var{nW}, @var{nseq}, @var{'interp'}, @var{nb})\n\
@deftypefnx {Loadable Function} {@var{h} =} dpss (@var{n}, @var{nW}, @var{'interp'})\n\
@deftypefnx {Loadable Function} {@var{h} =} dpss (@var{n}, @var{nW}, @var{'interp'}, @var{nb})\n\
@deftypefnx {Loadable Function} {@var{h} =} dpss (@dots{}, @var{'trace'})\n\
@deftypefnx {Loadable Function} {[ @var{h}, @var{l} ] =} dpss (@dots{})\n\
@cindex dpss slepian\n\
\n\
Computes a set of discrete prolate spheroidal sequences (aka Slepian sequences) using the symmetric tridiagonal matrix formulation, with even-odd splitting.  These sequences are typically used in multitaper spectral analysis.\n\
\n\
The columns of @var{h} are the resulting sequences of length @var{n} and time-bandwidth product @var{nW}.  Typical values of @var{nW} are 2, 2.5, 3, 3.5 and 4.  The output @var{l} is a column vector containing the concentration of energy of each sequence in the normalized frequency range \n\
@iftex\n\
@tex\n\
$f \\in [-W,W].$\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
f in [-W,W].\n\
@end ifinfo\n\
By definition, the first discrete prolate spheroidal sequence maximizes this energy concentration.  The i-th sequence is the one that maximizes the concentration, subject to lying in the subspace perpendicular to that spanned by the previous i-1 sequences.  The initial\n\
@iftex\n\
@tex\n\
$\\lfloor 2nW \\rfloor$\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
floor(2@var{nW})\n\
@end ifinfo\n\
DPSSs have concentrations near one.  After this point, the concentrations rapidly drop to zero.\n\
\n\
If @var{nseq} is not provided, then first \n\
@iftex\n\
@tex\n\
$\\lfloor 2nW \\rfloor$\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
floor(2@var{nW})\n\
@end ifinfo\n\
sequences are returned.  If @var{nseq} is an integer, \n\
@iftex\n\
@tex\n\
$1\\;\\le$ @var{nseq} $ \\le$ @var{n},\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
1 <= @var{nseq} <= @var{n},\n\
@end ifinfo\n\
then the first @var{nseq} sequences are returned.  If @var{nseq} = [@var{seql}, @var{sequ}] is a range, then the @var{seql}-th through @var{sequ}-th sequences are returned.  Note: the first sequence has an index equal to one.\n\
\n\
The maximum sequence length that can be calculated from the definition in this routine is @var{NMAX} = \n\
@iftex\n\
@tex\n\
$2^{17}-1$.\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
2^17-1.\n\
@end ifinfo\n\
For larger values of @var{n}, the DPSSs are approximated using interpolation.  Valid strings for @var{'interp'} are:\n\
\n\
@table @asis\n\
@item @var{'spline'}\n\
Interpolate using natural cubic splines (default).\n\
@item @var{'linear'}\n\
Interpolate linearly.\n\
@end table\n\
\n\
By default, sequences of length @var{n}\n\
@iftex\n\
@tex\n\
$>$\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
>\n\
@end ifinfo\n\
@var{NMAX} are interpolated from the set of sequences generated by\n\
@example\n\
dpss ( NMAX, nW, ... ).\n\
@end example\n\
If a base size, @var{nb}, is supplied, then the sequences are interpolated from\n\
@example\n\
dpss ( min (nb, NMAX), nW, ... ).\n\
@end example\n\
The interpolation routine assumes that the sequences are evaluations of a function at the midpoints of an equally-spaced grid.  For the natural cubic splines, a zero-derivative boundary condition is assumed at the two end-points.\n\
\n\
A final input string @var{'trace'} will print the interpolation method (if any) and the computation parameters to the command window.\n\
\n\
\n\
Examples:\n\
\n\
\n\
Compute basic DPSSs:\n\
@example\n\
h = dpss(12, 3, 2); \n\
@end example\n\
The first two sequences with length 12 and time-bandwidth product @var{nW}=3 are returned.\n\
\n\
Compute a range of DPSSs:\n\
@example\n\
h = dpss(12, 3, [3 5]); \n\
@end example\n\
The third through fifth DPSSs of length 12 and @var{nW}=3 are returned.\n\
\n\
Use interpolation to compute long sequences:\n\
@example\n\
[h, l] = dpss(8388608, 2.5, 'spline', 32768); \n\
@end example\n\
The first 2@var{nW}=5 sequences of length \n\
@iftex\n\
@tex\n\
$2^{23}$\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
2^23\n\
@end ifinfo\n\
and time-bandwidth product @var{nW}=2.5 are returned, along with their energy concentrations.  Note that these were obtained by first computing sequences of length\n\
@iftex\n\
@tex\n\
$2^{15}$\n\
@end tex\n\
@end iftex\n\
@ifinfo\n\
2^15\n\
@end ifinfo\n\
then interpolating using natural cubic splines and re-normalizing to have unit energy.  The interpolated sequences are used to estimate the energy concentrations.\n\
@end deftypefn\n"
};

//case insensitive comparison
int mystrnicmp (const std::string &s1, const std::string &s2, const int n)
{   
    for (int ii=0; ii<n; ii++){
        if (toupper(s1[ii])>toupper(s2[ii]) )
            return 1;
        else if ( toupper(s1[ii])<toupper(s2[ii]) )
            return -1;
    }
    return 0;
}

//creates a string of length n with a repeated character (ie space, '%', or '#')
char *rep_string(char *out, char rep, int n){
    
    if (n<0) n=0;       
    for (int ii=0; ii<n; ii++)
        out[ii]=rep;
    out[n]='\0';
    return out;
    
}

void print_workspace(dpss_workspace work, char *prepend, char *append, char topchar, char bottomchar){
    
    int  lmax=0,li=0,ln;
    char line[4][100];
    char tmp[100];
    
    sprintf(line[li++],"DPSS Summary ");
    sprintf(line[li++],"    Params: N=%d, nW=%.2f, Sequences dpss_%d to dpss_%d ", work.n, work.nW, work.seql+1, work.sequ+1);
    if (work.interp_method==NONE)
        sprintf(line[li++],"    Method: Tridiagonal formulation w/ even-odd splitting");
    else if (work.interp_method==LINEAR)
        sprintf(line[li++],"    Method: Interpolated from N=%d (Linear)",work.interp_base);
    else if (work.interp_method==SPLINE)
        sprintf(line[li++], "    Method: Interpolated from N=%d (Natural Cubic Splines)",work.interp_base);
    
    if (work.energy==true)
        sprintf(line[li++],"    Energy: Concentrations calculated using FFTs (FFTW)");
    
    for (int ii=0; ii<li; ii++)
        lmax=max<int>(lmax,strlen(line[ii]));
    
    int nprep, napp;
    nprep=strlen(prepend); 
    napp=strlen(append);
    
    //print top string
    if (topchar != '\0'){
        printf("\n%s\n",rep_string(tmp,topchar,lmax+nprep+napp));
        printf("%s%s%s\n",prepend,rep_string(tmp,' ',lmax),append);
    }
    
    //print all others
    for (int ii=0; ii<li; ii++){
        ln=strlen(line[ii]);
        printf("%s%s%s%s\n",prepend,line[ii],rep_string(tmp,' ',lmax-ln),append);    
    }
    
    //print bottom string
    if (bottomchar != '\0'){
        printf("%s%s%s\n",prepend,rep_string(tmp,' ',lmax),append);
        printf("%s\n\n",rep_string(tmp,bottomchar,lmax+nprep+napp));
    }
    
}

void print_workspace(dpss_workspace work){
    
    char *blank=(char*)"";
    print_workspace(work,blank,blank,'\0','\0');
    
}

//parses the input arguments to create a dpss workspace
dpss_workspace parse_args(octave_value_list inargs, int nargin, int nargout){
    
    dpss_workspace args;
    
    if (nargin < 2) throw ERR("Not enough arguments");
    
    uint_t n;  double nW;
    
    int iarg=0;  int ii=0;    
    while ( (iarg <= INTERP_BASE) && (ii<nargin) ){
        
        switch(iarg){
            case SEQ_LENGTH:
                if (!inargs(ii).is_scalar_type())
                    throw ERR("Invalid dpss length");
                
                n=inargs(SEQ_LENGTH).int_value();
                args.n=n;
                if ( n > MAX_N ){
                    args.interp_method=SPLINE;
                    args.interp_base=MAX_N;
                }           
                else {                 
                    args.interp_method=NONE;
                    args.interp_base=n;
                }
                ii++; iarg++;
                break;
                
            case TIME_HALF_BANDWIDTH:
                if (!inargs(ii).is_scalar_type())
                    throw ERR("Invalid nW");
                
                //defaults in case only 2 arguments supplied
                nW=inargs(ii).double_value();
                args.nW=nW;
                args.seql=0; args.sequ=floor(2*nW)-1;            
                ii++; iarg++;
                break;
                
            case SEQL:
                if (inargs(ii).is_scalar_type()){
                    args.seql=0;
                    args.sequ=max<int>((inargs(ii).int_value()),1)-1;   //sequences begin at zero in code                                               
                    ii++;
                }
                else if (inargs(ii).is_matrix_type()){
                    args.seql=max<int>(floor(inargs(ii).matrix_value()(0)),1)-1;
                    args.sequ=max<int>(floor(inargs(ii).matrix_value()(1)),1)-1;
                    ii++;
                }
                else if (inargs(ii).is_string()){}
                else
                    throw ERR("Invalid dpss range");
                
                //SEQU option replaced by matrix SEQL
                iarg=iarg+2;
                break;
            case SEQU:
            case INTERP_METHOD: 
                if (!inargs(ii).is_string())
                    throw ERR("Expected INTERP string");
                
                else if ( mystrnicmp(inargs(ii).string_value(),"linear", 6)==0 ){
                    args.interp_method=LINEAR;
                }
                else if ( (mystrnicmp(inargs(ii).string_value(),"spline",6)==0) || (mystrnicmp(inargs(ii).string_value(),"interp",6)==0) )
                    args.interp_method=SPLINE;
                else {
                    throw ERR("Invalid interp method");
                }
                ii++; iarg++;
                break;
            case INTERP_BASE: 
                if (inargs(ii).is_scalar_type()){
                    if ( inargs(ii).int_value() < MAX_N)
                        args.interp_base = inargs(ii).int_value();
                    else
                        args.interp_base=MAX_N;   
                    ii++;
                }
                else{
                    //for compatibility, will allow, but will not interpolate
                    //throw ERR("Invalid interpolant size");
                }
                iarg++;                
                break;
            default:
                throw ERR("Error parsing arguments");
        }
        
    }
    
    if (nargout > 1) 
        args.energy=true;
    else
        args.energy=false;
    
    return args;
    
}

//main interface routine
DEFUN_DLD (dpss, args, nargout, helpstr)
{
    
    octave_value_list retval;
    dpss_workspace dpss_args;
    
    
    bool trace=false;
    int nargin=args.length();
    
    if (args(nargin-1).is_string()){
        if (mystrnicmp(args(nargin-1).string_value(),"trace",5)==0){
            trace=true;
            nargin=nargin-1;
        }
    }
    
    try{
        dpss_args=parse_args(args,nargin,nargout);
    }
    catch (ERR err){
        printf("Error: %s\n", err.getmsg() );
        return retval;
    }
    
    // Since there is no opporunity to call energize()
    // in Octave after interpolating, we force this option
    bool benergy=dpss_args.energy;
    dpss_args.energy=false;
    
    dpss myseq(dpss_args);
    try{
        myseq.compute();        //compute sequences
    }
    catch (ERR err){
        printf("Error: %s\n", err.getmsg() );
        return retval;
    }
    
    // If user requests eigenvalues, use interpolated sequences
    //   (computation time isn't THAT long... you're more likely to 
    //   be limited by memory).
    if (benergy==true)
        myseq.energize();

    Matrix h_filt(myseq.size(0),myseq.size(1)), lambda(myseq.size(1),1);
    
    memcpy((double*)h_filt.fortran_vec(),(double*)myseq.ph(),sizeof(double)*(myseq.length()));
    memcpy((double*)lambda.fortran_vec(),(double*)myseq.pl(),sizeof(double)*(myseq.size(1)));
    
    retval(0)=h_filt;
    if (nargout>1) retval(1)=lambda;
    
    if (trace==true) print_workspace(myseq.getinfo());
    
    return retval;
    
}
